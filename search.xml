<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>安卓前端开发杂谈</title>
    <url>/2021/09/01/android-dev-exp-1/</url>
    <content><![CDATA[<p>安卓的移动端开发，属实让我血压高了一小段时间。毕竟已经接触过类似于 React Native 那种基于 TypeScript 语言的、优秀的跨平台移动端框架，再去尝试用繁琐的 Java 语言写安卓前端自然是不适应且感到烦躁。</p>
<p>但是毕竟是 Java 程序设计训练课程，安卓前端开发作为其最大的特色，不得不消受。</p>
<span id="more"></span>
<h1 id="关于数据绑定">关于数据绑定</h1>
<p>如果要我说最大的不适应的地方，首先就是数据和图形界面的完全分离。在 React Native 框架之中，数据和图形界面的管理大概是这样的：</p>
<figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">(<span class="params">props: AppProps</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Set states &amp; initialize</span></span><br><span class="line">    <span class="keyword">const</span> [bar, setBar] = useState&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some functions to update or rewrite data</span></span><br><span class="line">    <span class="keyword">const</span> update = <span class="function">() =&gt;</span> setBar(<span class="function">(<span class="params">o</span>) =&gt;</span> o + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write UI with TSX, use data freely</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Text</span>&gt;</span> Hello world! <span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Text</span>&gt;</span> &#123;`The val of bar is $&#123;bar&#125;`&#125; <span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Text</span>&gt;</span> &#123;`Property foo is $&#123;props.foo&#125;`&#125; <span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;update&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在安卓之中，图形界面完全定义在 <code>.xml</code> 文件之中，而且一定程度上其定义各个组件摆放方式的语法细节的繁杂程度不低于 HTML。而如果需要将数据载入图形界面，则首先要根据组件的 ID 获取组件，之后才能调用各种方法设定具体属性。</p>
<figure class="highlight java"><figcaption><span>Java</span></figcaption><table><tr><td class="code"><pre><span class="line">((TextView) view.findViewById(R.id.entity_name)).setText(data.name);</span><br></pre></td></tr></table></figure>
<p>这里出现的 <code>R</code> 类据说是相当厉害的。但是我第一次接触安卓的时候，这个符号给我带来的感觉就是不安，因为我再也不能像写 React Native 一样至少自认为自己掌握了程序之中的数据流。换一种说法，即使 React Native 可能做了很多背后工作，但它至少做到了让开发者在很多时候能直观引导数据流。</p>
<p>对于按钮等组件，React Native 框架下可以直接传入回调函数。而众所周知 Java 是纯净的面向对象语言，怎么会有 lambda 这种异端呢（新版本的 Java 已经离经叛道了！）。</p>
<p>所以你需要写监听器对象，重写其中的方法等等。</p>
<hr />
<p>并不是说这样不好，我还记得之前大一小学期的时候写 Qt 很多时候就是各种指针到处乱飞然后到处乱 <code>set</code> 这个那个的，最后一个 <code>draw</code> 函数里面上百行的，成块的各种格式设定、字体设定、内容设定、排列设定，然后这次写安卓让我回忆起了那一段黑暗时光。</p>
<h1 id="并不适应的适配器模式">并不适应的适配器模式</h1>
<p>如果只是想给一个 <code>TextView</code> 载入文字，直接几个 <code>set</code> 函数就结束了。但是给一个格式复杂的列表载入数据，则相当繁琐。比如说现在主流的 <code>RecyclerView</code>，其载入数据，就需要你自己编写一个数据适配器。</p>
<p>我首先是上网找轮子，随后想了一下，干脆自己包装了个简单的 <code>RecyclerViewAdapter</code> 先勉强用用。</p>
<p>将数据塞到图形界面上，最重要的三个东西是上下文、使用什么 <code>layout</code> 和数据本身，那么适配器的构造函数就需要接受这三项。然后就是平凡地重写 <code>RecyclerView.Adapter</code> 所要求的三个函数。不过这里我在重写 <code>onBindViewHolder</code> 的时候留了空，因为这里就是定义适配器最重要部分——数据如何映射到 UI 的函数。我将这一个函数设为虚函数，让子类继承重写就可以实现各种映射方式。最后的成果大致这样：</p>
<figure class="highlight java"><figcaption><span>Java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RecyclerViewAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">RecyclerViewAdapter</span>.<span class="title">ViewHolder</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Context mContext;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> mLayoutId;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;T&gt; mData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecyclerViewAdapter</span><span class="params">(Context context, <span class="keyword">int</span> layoutId, List&lt;T&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = context;</span><br><span class="line">        <span class="keyword">this</span>.mLayoutId = layoutId;</span><br><span class="line">        <span class="keyword">this</span>.mData = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ViewHolder(</span><br><span class="line">                LayoutInflater.from(mContext).inflate(mLayoutId, parent, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(<span class="meta">@NonNull</span> ViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> What is this?</span></span><br><span class="line">        <span class="comment">// holder.updatePosition(position);</span></span><br><span class="line">        <span class="keyword">this</span>.convert(holder, mData.get(position));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">convert</span><span class="params">(ViewHolder holder, T data)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mData.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">private</span> View mConvertView;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ViewHolder</span><span class="params">(View itemView)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(itemView);</span><br><span class="line">            <span class="keyword">this</span>.mConvertView = itemView;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> &lt;K extends View&gt; <span class="function">K <span class="title">getViewById</span><span class="params">(<span class="keyword">int</span> viewId)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (K) mConvertView.findViewById(viewId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用起来也简单，传入三个要素，之后重写 <code>convert</code> 方法定义一下数据到 UI 的映射就好了：</p>
<figure class="highlight java"><figcaption><span>Java</span></figcaption><table><tr><td class="code"><pre><span class="line">binding.entityList.setAdapter(<span class="keyword">new</span> RecyclerViewAdapter&lt;Entity&gt;(</span><br><span class="line">    HomeFragment.<span class="keyword">this</span>.getActivity(), R.layout.home_entity_item, baseEntities</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">convert</span><span class="params">(RecyclerViewAdapter.ViewHolder holder, Entity data)</span> </span>&#123;</span><br><span class="line">        ((TextView) holder.getViewById(R.id.entity_name)).setText(data.getLabel());</span><br><span class="line">        ((TextView) holder.getViewById(R.id.entity_category)).setText(data.getCategory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>你会发现，这比 React Native 要写的东西多太多了。上面这么多需要折腾的，React Native 只需要这样写：</p>
<figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;View&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        baseEntities.map(<span class="function">(<span class="params">val, ind</span>) =&gt;</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">key</span>=<span class="string">&#123;ind&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Text</span>&gt;</span> &#123;val.name&#125; <span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Text</span>&gt;</span> &#123;val.category&#125; <span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">        ))</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/View&gt;</span><br></pre></td></tr></table></figure>
<p>就可以实现一个列表了。</p>
<p>Java 我写了一整个类，光数据转成 UI 也写了好几行长代码，这还没有算 <code>.xml</code> 文件。</p>
]]></content>
      <categories>
        <category>开发杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>大二春季学期学期总结</title>
    <url>/2021/06/19/grade-2-conclusion/</url>
    <content><![CDATA[<p>魔幻的大二春季学期最终还是随着自动机考试的结束而落幕了，随意写一点东西来总结一下吧。</p>
<span id="more"></span>
<p>虽然还没有出分，但我能够预料到这一学期如果按照绩点来评判，可以说过得十分坎坷。但是，这一学期还有更多的比绩点更值得重视的一些东西。</p>
<h2 id="课内学习">课内学习</h2>
<p>课内总体而言过得很不平凡，即使这一学期只有 24 学分的课程。与一年前那种 OOP 作业一发下来就赶快刷榜完成，高代选讲还愿意在课外学习很多内容的热情相比，我这一学期对课内显然是淡薄了很多。标志性的事件可以罗列出来：</p>
<ul>
<li><p>人智导 PA2 是在黄浦江上遥控卫爷写的，PA3 是在上海桌游店里打山屋惊魂的间隙交的；</p></li>
<li><p>在各种情况下写过数电实验报告，包括在人大门口醉酒的时候、在去上海的火车上、在轰趴的自动麻将机上（除了考试，我每一次实验的代码都是抄的）；</p></li>
<li><p>一个学期没有见过数电、自动机、人智导的老师，这三门课均让我在考试周通了宵（一个大二学生用 24 小时创造一个奇迹）；</p></li>
<li><p>软件工程大作业不到最后一周都没有认真写 UI；</p></li>
<li><p>高性能一气之下决定退课，虽然从未后悔过这个决定；</p></li>
<li><p>英语课一个学期就做了一份作业，占比最大的 Task C（团队 pre）只花了三四天准备；</p></li>
<li><p>物理实验报告分数为 9, 8.5, 8.7, 8, 8.7，上学期则是 9, 9, 9, 9.3, 9。</p></li>
</ul>
<p>总之就是这学期浪了一些，或许是认清楚你清贵系的教学水平甚至还不如高中之后的一些合理举动。如果要我来评价大二下学期这些课程的话，我只能说除了《不朽的艺术》这一门课，其他的课程我丝毫没有觉得学习到了什么有用的东西。再加上期末四门专业课考试两门可以说出事故的情况，我更是愿意给这一学期以低评价。</p>
<p>我大概算了一下，反正现在绩点的浮动不会多大，还不如抓紧时间，做一些我觉得有意义的事情。</p>
<h2 id="thuinfo">THUInfo</h2>
<p>我也说过，这是我唯一拿得出来的作品。虽然之前有写过一些小型项目，它们虽然也是我探索的足迹，但总体没有 THUInfo 给我带来的成就感大。</p>
<p>但比较愧疚的是这一学期没有给 THUInfo 作出很大的贡献。寒假的时候翻新了“计划”功能，修了几个小 bug 之后，学期中除了加了比如说“今日高亮”这种小功能之外，我也就没有作出什么贡献了。</p>
<p>但是，暑假确实是想要做很大的事情的。一方面是和校内 iOS Club 搭上了关系，对方也恰好想要找到一个重点支持的项目，双方互相需要，何乐而不为呢。通过它我们找到了美工，目前也有了一个较为简单的 UI 效果图（不得不说，做设计的就是做设计的）。另外一方面是<a href="https://www.zhihu.com/question/63407413">栋栋</a>加入了团队，总之多一个技能熟练的人手是很不错的。</p>
<p>敬请期待暑假过后的 THUInfo 3 系列版本。</p>
<h2 id="社工">社工</h2>
<p>大一下学期一番折腾之后，一个学期没有加入任何学生组织。但是一个转变的契机就是 xge 和我说他和栋栋准备开发日麻，随后将我纳入了 308（科协 &amp; 算协活动室）常驻人员之中。在 308 蹲守的过程中，我也认识了科协的许多同学（再次点名“表扬”大恶人安頔）。最后决定加入科协，大概是那天去出去散心醉酒，隔天回校的时候恰好赶上 C 楼门口的智能体嘉年华。本来是不打算去的，想着去看看也没啥问题，就突然发现科协办的东西还挺有意思。随后又去蹭了智能体决赛，还坑了 Omega Fantasy 一顿饭。</p>
<p>随后大约是某晚和安頔夜谈，经过一番交流，决定去混一个科协副主席。</p>
<p>怎么说呢，或许真的是如同之前一些人的评价——“你大一下学期的那种情况实属罕见，哪有人开局社工就是王炸的”一般，社工并不是我想的那么不堪。现在大概是发现，有一群志同道合的人一起做事情是多么愉悦。</p>
<h2 id="sakana">Sakana</h2>
<p>这一段没有什么特别想说的，总之揭开了一些过往，给一些问题作出了解答，这应该也是这个学期我应该可以说最为重视的一件事。虽然有很多的小细节，有很多的瞬间，但还是就留下我之前发在空间里的一段话吧：</p>
<blockquote class="blockquote-center">
<p>虽然我真的不会挑时间，不会好好规划安排行程，或许会因为冲动把事情做得很离谱。 但真的感谢包容我的愚拙。</p>

</blockquote>
<h2 id="一些总结与闲话">一些总结与闲话</h2>
<p>这一学期的 Holder 发生了相当大的改变，应该是真的去思考过我的大学应该如何度过这个问题了。之后就确立了“<strong>我要帮助后辈们尽可能少走弯路</strong>”这样的一个简单的目标，于是和改制的科协网络部不谋而合，于是和高中班主任谈好了回高中给学弟学妹讲数学竞赛。在确立好自己的真正想做的事情之后，便是卸下一些伪装。先前的我大概因为完全不能找到我自己的目标，而将自己浸没在无意义的内卷之中，也不敢面对自己的一些感情。这一切的一切，都在稍微通透之后被瓦解了。</p>
<p>当然我感觉需要警惕的，就是我暂且需要约束一下自己无限膨胀的野心，不能给自己捞太多的锅，接太多的任务，应该让自己慢慢达到一种平衡。</p>
<p>不如现在，来说说之后想要做的事情吧：</p>
<ul>
<li><p>接着跟进在刘知远实验室的任务，努力发篇文章，发完就撤退；</p></li>
<li><p>翻新 THUInfo 的 UI，开发一些新功能；</p></li>
<li><p>在科协把“技能引导文档”这件事做好，做到宣讲会上的“为了创建一个 user-friendly 的计算机系而奋斗”；</p></li>
<li><p>好好地生活，让自己的大学不仅仅是绩点和社工。</p></li>
</ul>
<p>还有就是一些暑假要做的事情，比如说 GRE，比如说科目二，比如说回高中讲竞赛，比如尝试一下图形学。</p>
<p>写这篇潦草的总结的时候，我应该还因为昨晚通宵复习自动机而头晕目眩，但是我的神志却异常清醒，因为我的大学似乎是真的开始了。</p>
<p>我有分享歌词的习惯，这里也来一句吧。但不同于之前我喜欢分享那种长长的，哲学家写散文式的歌词，这个歌词很朴素：</p>
<blockquote class="blockquote-center">
<p>ケーキも大好き，君も大好き。</p>
<p>ーー「とある一家の御茶会議」</p>

</blockquote>
<p>祝愿我余下的一半本科时光，能过得有意义。这里是 Holder，我们一起接着走下去吧。</p>
]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
  </entry>
  <entry>
    <title>大三秋季学期学期总结</title>
    <url>/2022/01/05/grade-3-mid-conclusion/</url>
    <content><![CDATA[<p>今天考完了最后一门《编译原理》，随后参加了年级会。这样看来，我的大三上学期，这个被学长们称为渡劫的学期，就这样平平无奇结束了。</p>
<span id="more"></span>
<h2 id="对自己的质疑">对自己的质疑</h2>
<p>这学期之所以被称为渡劫，是因为按照教学计划计算机系的最核心的四大原理课是在这学期修读。这四大原理是《计算机组成原理》《计算机网络原理》《编译原理》《信号处理原理》。而我所说的对自己的质疑，就是我发现我完全对这四门课里的大部分提不起任何兴趣。</p>
<p>在成为大三学生之前，我从未质疑过我为什么要来这个专业，甚至一定程度上庆幸虽然选择计算机是随大流，但自己却也莫名其妙混得不算差。大一和大二修读的课程，我大多都能学得比较明白，再不济也能做到考前 overfit 一波混个考试分数。得益于此，我大三之前的 GPA 可以说还挺不错的。</p>
<p>但是进入大三之后，我明显感受到力不从心。比如说造计算机，其实我早就在《数字电路实验》这门大二下学期的入门课里面认识到了我似乎对硬件设计一窍不通，或者说完全没有一种愿意学习这类知识的冲动。另外比如说计算机网络相关，我对网络只是单纯知道一些简单的概念，深入了解却让我相当抗拒，我不是抗拒特定的课程，我是对整个计算机网络这个领域感到深刻的无力，甚至是生理性不适。</p>
<p>所以我有意无意地拖延了造机，不到最后一周没有真正开工。我有意无意地只用一下午复习网原，有意无意地没有去任何一堂除了体育之外的课。</p>
<p>因为我抗拒，我理解不了这些知识背后的逻辑，支撑着我学习新的领域的动力不能直接迁移到计组和网原这些课程上。</p>
<p>与此对应的，我课余在尝试着学习一些数学，研究生方向也想尽量往数学相关方向贴近一下。在学习《信号组成原理》的时候，常常痛斥其数学基础不牢靠（毕竟是工科面向应用的学问，其宁愿牺牲严谨性也要保证易用性），也曾钻牛角尖一样地和别人争执过信号这门课里的数学体系是不是矛盾的。</p>
<p>我发现我对知识有一点奇妙的偏执，我希望我学习的东西是体系的、有逻辑的，或者说我希望学习一个由人类<strong>发现</strong>的学科，而非由人类<strong>发明</strong>的学科。比如说网络协议往往充满了历史包袱、前人的失败经历、欠考虑的机制和随后而来的零碎补丁，它不是一个等待人类来发掘的逻辑体系，它本身就是人类在实践中堆叠的经验谈。与此类似的，还有我拒绝研究 CSS 的那一堆难以理解的属性，不想深究 Web 混沌初开时的前端技术。</p>
<p>所以我开始反思，我或许真的应该当时听从一些劝诫去学习数学什么的，但实际上我也知道这不过是虚无的懊悔，不过是这山望着那山高般的幻觉。但基于这样的自我认识，我尝试着去选择和数学关系较大的计算机领域作为研究生方向，比如说渲染。</p>
<h2 id="课内学习">课内学习</h2>
<p>和之前说的一样，这学期六门课，四大原理加两门限选。网原和网安都是网络方向的课程，考试几乎全都是背诵就行，但悲哀的是我厌恶计算机网络，连课件都懒得打开看两眼。不过还好网安不难，但是网原我估计差不多就是 B+ / B / B- 里面随机给分了，自我认为 3.3 绝对不亏，3.6 绝对血赚。</p>
<p>计组确实硬核，而且我也不喜欢写硬件语言，因为它思维逻辑和我常用的软件语言相当不同，所以造机大实验着实让我一个星期没睡好觉。但是计组和网原最大的不同是，计组学不好我认为原因是客观上我能力不行，网络学不好我认为原因是主观上我厌恶。所以即使计组不简单，考试也不简单，但我依然很努力地去学了三四天，虽然感觉也没考多好。</p>
<p>编原今年史诗级削弱，取消实验考试改为期末周后的附加实验，删减考纲，降低试题难度，提升平时作业占比。就说最明显的，今天在考场上看到 SLR(1) 文法的题选的语言竟然是 <span class="math inline">\(\{a^n: n \geq 1\}\)</span> 的时候，我已经真的深刻领悟到，什么是把分送到你手上。</p>
<p>信号原理自己学得挺开心，毕竟自己也喜欢有事没事钻一钻所谓事物本质的东西。比如说当我期末复习的时候，把数字滤波器、传递函数、 Z 变换、收敛域与系统性质那一套在课间上混乱不堪的概念理清楚的时候，自己真的有一种豁然开朗而想继续深入学习的感觉。</p>
<hr />
<p>要说总体的话，就是这学期估计 GPA 还得继续往下掉，但我也只能说 Who cares。大一大二到大三，自己也经历了微积分不考 4.0 就是挂科，数据结构 3.6 就是胜利到网原 3.3 也不算亏这一路的心态变化。</p>
<p>但似乎 Holder 还是没有摆脱那一种奇妙的思维惯性，peer pressure 还是在隐隐约约给我带来一些不愉悦。</p>
<h2 id="科协">科协</h2>
<p>上学期奇妙地成为了副主席，那这学期就应该做点事情了。</p>
<p>在还没有开始造机、造路由器之前，由于课业压力暂且还不大，我便抽了一点空余时间把技能引导文档搭建起来了，并且写了一些东西进去。</p>
<p>技能引导文档大约是一种课程前置知识的补全，因为我确实见过不少同学都已经开始上课了，却连前置技术栈都不了解，最后只能网上随便找点资料混过去。秉持着能做点什么都是好的的想法，索性借着科协这个平台，搭建起了这样的一个文档共享的网站。</p>
<p>但是随着造机、造路由器和期末周，文档维护也就暂且搁置。现在考试完了，寒假是一大波开工的好时机。</p>
<hr />
<p>说到科协就必须要提到安老板，就要提到我最终估计就会采纳安老板的提议，去媒体所混日子了。</p>
<p>现在还在绝赞学习《GAMES101》，感觉自己摸鱼摸得太过了其实。</p>
<h2 id="摸鱼摸鱼摸">摸鱼摸鱼摸</h2>
<p>这个学期虽然很辛苦，但依然可以忙里偷闲摸不少鱼。小学期莫名其妙搞到了一个日区 App store 账号，于是又可以开始玩 Project Sekai 了。这种又有音游难度，又能抽抽卡养养妹子看看剧情的小游戏我确实喜欢，所以这个学期也基本一直都在玩，Phigros 基本都荒废了。</p>
<p>要说还有什么的话，就是打牌，无穷无尽的打牌。毕竟打牌确实没那么多限制，特别是打网络麻将，随时随地就开一把打着玩就行。所以 Holder 倒也经常在学累了的时候开一把，消遣消遣倒也不错。考试周其实打了不少牌，基本上一天打五六把还是有可能的。可能也是频率上来了，这学期也总算把四人麻将打上玉之间了。</p>
<p>除了网络麻将就是宿舍里搓牌，本学期最大的进展就是大约通过次世代认识了一些八字班学长一起打牌，不过确实也算是见识到了我这类图乐子打牌和认真打牌人的水平差距。</p>
<hr />
<p>另外可能就是通过 V+ 吹水群认识了另外一些人，平常也是交流交流 Vocaloid 相关，吹水聊天。可能偶尔会在周末的时候组织去国贸唱 K，自己也去过两三回了，确实是放松的好机会。</p>
<p>不过也因此渐渐喜欢上了学习的时候唱歌，虽然之前也偶尔会这样，但是真正感觉有意识地哼唱一些歌还是这个学期的事情。</p>
<h2 id="一些碎片">一些碎片</h2>
<h3 id="小学期的精神问题">小学期的精神问题</h3>
<p>暑假的时候我处于一种神经敏感的状态，整个人还在五月份那一次大崩溃的余震之中喜怒无常。而八月中旬的小学期，由于众所周知的屑课《Java 语言程序设计》，以及当时一些早已遗忘的情感问题的引子，Holder 又成功经历了一次情绪崩盘。</p>
<p>大约，那某一个夜晚，在工物馆和美院停车场之间小路上，漫无目的地晃荡着和 Sakana 哭诉着的场景，是我小学期记忆最深刻的事情。</p>
<h3 id="无界美术馆">无界美术馆</h3>
<p>上海的一个美术馆，在一个周末 Holder 偷偷跑去和 Sakana 到那里参观去了。</p>
<p>Holder 向来是不太解风情的，对这个美术馆里展出的那些灯光艺术、雕塑、投影交互等等作品，我只能说“好闪”“好亮”“好鲜艳”这些明显语言贫瘠的评价。所以说 Holder 还只能读死书，或者有事没事和舍友抬抬杠，精神世界倒也是一片荒芜。</p>
<h3 id="造机的三星期">造机的三星期</h3>
<p>其实我也说了，虽然造机确实给了三星期，但实际上我只在最后一个星期加紧做了不少事情。当时最喜欢的工作模式就是在 308 一个人坐着，手机挑一部没有很烧脑剧情的日常番，边看番边等 Vivado 编译或者看波形图。就这样半悠闲半紧张地工作着，倒也几天内写掉了不少东西。但平心而论，我依然没能从硬件设计中获取多少快乐，虽然最终看着自己写的 CPU 上能运行自己写的贪吃蛇游戏，但要让我回到那三星期，我说还不如打两三把牌。</p>
<h2 id="所以呢">所以呢？</h2>
<p>所以说大三上学期也就这样结束了，课业成绩并不理想，人也过得疲惫不堪，其中一大半责任是网原。但是换一种角度，我认识了新的一起打牌的朋友，认识了能和我一起唱 V 曲的同学，Project Sekai 时不时能抽出好看的角色，打牌虽然会恶调但确实缓解了一些紧张情绪。自己也逐步和自己和解，不再纠结于一些得失，自己也在尝试着尽力做一些帮助他人的事。</p>
<p>所以其实我也不知道我这个学期究竟是什么样的，这篇总结我也写得磕磕绊绊不知道什么是这学期的主线。传统意义上四大原理的主线在我这里断裂了，因为我精力分配中它们并不优先。</p>
<p>但总归是看到了本科生活的尽头，自己也已经有了意向性的导师，也对自己究竟想学什么、想做些什么有了模糊的应答。虽然还是时不时感叹我真的不适合计算机系，感叹自己怎么过得这么惨，时不时在空间或者朋友圈发一些意味不明的文字，但总体上 Holder 还是履行了上个学期的诺言，尽力地享受着自己的本科生活。</p>
<p>寒假的话，可能要做不少事了。</p>
<ul>
<li><p>技能引导文档寒假宣传</p></li>
<li><p>THUInfo 翻新</p></li>
<li><p>实验室科研的一些事务</p></li>
<li><p>自学一些数学以及日语</p></li>
</ul>
<p>下学期也选了若干看起来还挺有意思的课程，希望下学期能过得更快乐一些。</p>
<blockquote class="blockquote-center">
<p>失うことに慣れてく中で失くさずにいた大事な思いを、</p>
<p>抱きしめたら不意に涙が落ちたのは、</p>
<p>この街でまだ生きていたいと思うから。</p>
<p>ーー「幽霊東京」</p>

</blockquote>
]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
  </entry>
  <entry>
    <title>大三秋季学期前的一些碎话</title>
    <url>/2021/09/12/grade-3-preview/</url>
    <content><![CDATA[<p>自己似乎就这样莫名其妙成为了一个大三学生，其实还隐隐约约记得一年前刚进实验室的时候刘知远的一句“没想到这么快八字班也要造机了啊”。现在想来，九字班这个词语从原先的代指新生，渐渐地变成了代指一群大三老油条，而自己的一字班学弟也正在憧憬着四年的本科时光，一时间竟觉得大学原来也快结束了。</p>
<p>今夜突然接到 Sakana 的一句“我还是好焦虑”，唐突地自己也开始陷入了一种窘迫的心理。自己，真的准备好去迎接之后的生活了么。</p>
<span id="more"></span>
<h1 id="学业和大三的渡劫">学业和大三的渡劫</h1>
<p>清华大学的计算机系向来会把大三上学期称为渡劫，原因是计算机核心专业课四大原理一大工程（计算机组成原理、计算机网络原理、编译原理、信号处理原理、软件工程）将会在一个学期内学习完成。虽然自己已经提前把软件工程这门课草草了结，但是作为一个对硬件和计算机系统没有感觉的人，四大原理就足以让我恐惧。已经能够预见到，将来的 Holder 或许会被造计算机、造路由器、造编译器、写 Matlab 处理信号等各种困难的作业包围，然后还要抽出时间应付掉 VLSI 和网安两门限选课的平时学习。</p>
<p>其实也正如一些人对我的评价所说，我不是一个害怕困难或者折磨的人，但是我在受折磨的时候会习惯性一个人顶着。我只是默默地担心着自己的心理健康情况，自己这近几个月来时不时的情绪崩溃足以让我感到害怕。</p>
<p>但实际上，我还是在安慰着自己没有问题，劝慰着自己造机造路由器会顺利，或许还会有点乐趣。也或许会安慰自己，信号处理原理全是微积分，自己微积分学得挺明白不用担心。然而即便如此，还是抵挡不住现在的焦虑和不安。</p>
<h1 id="科研的不顺和前途的迷茫">科研的不顺和前途的迷茫</h1>
<p>我大一就跑到组里去了，是一个进组挺早的人，家里人一直比较关心我这么早进组会怎么样，当时还不以为意，但现在看来还是有点不大行。过早的进组让我缺少时间去打基础而过快地投入到实际工作之中，我对人工智能的理解本身就是几乎为零，和同组的那些曾经 C++ 手搓神经网络的大神相比自然不可相提并论。想到自己每周二的组会都会想尽办法编造一个自己没认真做完事情的理由的时候，那种窘迫和尴尬又涌了上来。</p>
<p>至今还记忆犹新的一个场景就是，中期汇报的时候刘知远老师在场，到我上去汇报的时候，应该是说出了大量幼稚或者说根本不合理的想法。那个时候刘知远说了这样一句：“现在 Holder 这个样子，我们需要反思一下我们的指导方式”。</p>
<p>这种看似自责的说法实则，看得出来他们的意见。</p>
<p>或许从那以后，我投入了大量的精力弥补我的基础，我开始看人工智能相关网课，从全联接层开始看到 CNN / RNN，再到 Encoder-decoder 或者 Transformer，然后开始使用 HuggingFace 的 BERT 和 T5 轮子，钻研 API 设计和源码。这一定程度上牵扯了我大量本应该用于课内的时间，但收获也是不错的，我 finetune 的 BERT 模型做出了被学长们称为“ promising ”的成果。</p>
<p>但是后续是无休无止的挫败，我 T5 相关的工作至今都处于停滞状态。在那段时间，我经历了第一次情绪崩溃，一时间万念俱灰，每天醒来只有想睡回去的想法。那段时间，身体也一直不是很好，时不时就会有心脏疼的感觉。这种情况下的我，选择了实质上的彻底放弃，虽然一直没有和带我的学长提出我要退出。</p>
<p>现在我也不想继续学习人工智能了，每每看到那些曾经熟悉且能熟练运用的数学公式、轮子、模型，只会让我想起那段折磨至极的时光。但大三上学期的我，早就已经浪费了一年的时光，现在的 Holder 的后路究竟如何，完全还是未知的，我该如何面临毕业，也还是未知的。</p>
<h1 id="或许还是有些好消息的">或许还是有些好消息的</h1>
<p>稍微能够宽慰我的，就是我现在过得还不错。至少我身边的一切，我的学业成绩、我的感情、我的朋友们、我的家人们都处于稳定的状态上，除了我自己的出路，其余暂且不需要我过多担心。</p>
<p>这已经足够了，如果不去太担忧未来的不确定，活在当下自然是自由而快乐的。中厅的麻将还能用，新笔记本上还有若干没有玩的游戏，Sakana 还在身边，我还是有一群能聊得来的朋友，这一切的一切，暂且能够让我不再过分担忧今后。</p>
<h1 id="holder-的一些自述">Holder 的一些自述</h1>
<p>在别人眼中，特别是我高中的老师眼中，我是一个特别会规划的人。然而实际上，Holder 永远是一个走到哪里算哪里的人，只不过总是喜欢回忆，总是喜欢和过去的自己斤斤计较，懊恼于一时的失误。</p>
<p>Holder 是一个喜欢沉浸在回忆中的人，我对过去的记忆可能过于清晰。我的一个习惯性动作是，无聊的时候将记忆中的场景构建出来，比如说尝试构建出：</p>
<blockquote class="blockquote-center">
<p>2018 年的 8 月份，在高中的三层小楼中，Holder 和同学们正在为升入高三做准备。除去我们升高三的理科实验班同学，其他人早已放假。那座小楼已经老旧不堪，空调毫无用处，电风扇没有力气。外面是炽热的阳光和扭曲的蝉鸣。</p>
<p>Holder 趁着下课偷偷跑出小楼，听着下课铃在早已空荡的学校中回响。</p>

</blockquote>
<p>我或许会把这个场景构建得和刚经历差不多，然后自己沉浸在这个场景里回忆当时自己的所思所想。这个习惯来源于初中睡午觉，当时为了让自己快速入睡，就会使用这种方法——在脑海中完全重建回忆的场景，这种方法消耗脑力很多，有的时候没有构建完成就慢慢睡着了。</p>
<p>这个习惯一般会让我很难忘记一些事情，但是坏处就是：</p>
<blockquote class="blockquote-center">
<p>我忘不掉一些应该忘却的事情。</p>

</blockquote>
<p>所以至今我的思维包袱是很重的，回忆构建的数据库足够庞大，能够支撑我思维的快速切换跳转和联想。但是一旦联想到一些本应该忘却的场景，比如说曾经的尴尬场面、自己伤害别人的行为，那 Holder 可能就会沉溺在这里，然后一遍一遍鞭尸自己。</p>
<p>这还是挺折磨的，这让我很难聚焦于当下应该做的事。</p>
<h1 id="所以说">所以说？</h1>
<p>这些文字其实没有任何意义，可能明天起来就会觉得幼稚和不成熟，但是确实是现在困困的 Holder 想要记录下来的。</p>
<p>Holder 就要成为大三的学生了，在此之前，12 号先要去北大吃一顿烤串，这足以让我暂且安静地睡去。</p>
<p>晚安。</p>
]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
  </entry>
  <entry>
    <title>Hello world</title>
    <url>/2021/06/16/hello-world/</url>
    <content><![CDATA[<p>刚刚建立好这个地方，暂且也没什么特别想说的，不如就来玩一下 hexo 的各个语法吧。</p>
<span id="more"></span>
<p>首先玩玩代码块，自然首先试试 cpp。</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello world!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来试一下 Python。</p>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello world!&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>不如玩一下 JavaScript。</p>
<figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>然后玩一下数学公式。</p>
<p>我们可以把机器学习抽象描述为以下过程，这里 <span class="math inline">\(X\)</span> 表示输入集合，<span class="math inline">\(Y\)</span> 表示输出集合，<span class="math inline">\(L\)</span> 表示损失函数，<span class="math inline">\(\boldsymbol{w}\)</span> 表示模型参数，<span class="math inline">\(f_\boldsymbol{w}\)</span> 表示在某一系列参数之下的模型函数。</p>
<p><span class="math display">\[
\boldsymbol{w}^*=\mathop{\arg\min}_{\boldsymbol{w} \in \Omega}\sum_{x_i \in X, y_i \in Y} L(f_\boldsymbol{w}(x_i), y_i)
\]</span></p>
<p>再来试一下它自带的一些引用块。</p>
<blockquote><p>你成功建好了自己的第一个 hexo 站点！</p>
</blockquote>
<p>hexo 文档里面还提到了一种奇怪的东西，来试一下。</p>
<blockquote class="pullquote"><p>这个东西被称为 Pull Quote。</p>
</blockquote>
<p>似乎还有奇怪的东西。</p>
<div class="note success"><p>这个是提示成功的引用块。</p>
</div>
<p>下面是一个居中引用。</p>
<blockquote class="blockquote-center">
<p>这里我们居中一定的文本。</p>

</blockquote>
<p>这里还似乎提供了用于查询浏览器支持方法的插件。</p>
<iframe data-feature="fetch" src="https://caniuse.bitsofco.de/embed/index.html?feat=fetch&periods=current&accessible-colours=false" frameborder="0" width="100%" height="400px"></iframe>
<p>暂且玩到这里吧，目前的话想要做的一些事情包括：</p>
<ul>
<li><p>写（搬运）点有点价值的东西</p></li>
<li><p>有没有可能做一些类似于管理员才可访问的东西呢</p></li>
<li><p>搞一下评论系统、浏览计数之类的</p></li>
</ul>
<p>当然我们知道明天下午就考数电了，所以 Holder 该滚去复习了。</p>
]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
  </entry>
  <entry>
    <title>日语语法手册（2021 年）</title>
    <url>/2021/11/01/ja-0/</url>
    <content><![CDATA[<p>了解 Holder 的人都明白，我几乎没有按照任何成体系的教材学过日语，所以我对日语语法的理解的变动是很快的，甚至有时会出现整个体系的重构。</p>
<p>这个手册基本基于原先的单词变形手册。但是考虑到 Holder 这段时间又从各处获取到了一些古日语知识、日语历史和一些浅薄的语言学知识，与其在原先的手册上修订，不如重新编写。</p>
<span id="more"></span>
<h2 id="编写准则">编写准则</h2>
<p>本手册会首先介绍现代日语采用的动词、形容词、形容动词等用言的活用规则，随后会介绍若干助词和助动词的词性和活用规则，最后会讲解这些用言各种活用的应用场景。基于此，基本上大多数现代日语句子都可以分析明白了，基础文字阅读上应该不会有特别大的问题（基于词汇量充分的基础）。</p>
<p>本手册的编写依据是我自己对日语语法的理解，并不能作为严谨的语法教材使用。</p>
<h2 id="现代日语用言活用规则">现代日语用言活用规则</h2>
<p>日语中用言的活用一般分为七种，即：</p>
<ul>
<li><p><strong>未然形</strong>。主要用于表述未发生的形态，用言的否定和被动常常使用未然形接续相关助动词表示。</p></li>
<li><p><strong>连用形</strong>。主要用于接续其他用言，部分动词的连用形用于将动词名词化。</p></li>
<li><p><strong>终止形</strong>。一般认为是用言的基础形态，用于接续终止助词表现句子终结。</p></li>
<li><p><strong>连体形</strong>。主要用于接续体言。</p></li>
<li><p><strong>假定性</strong>。古日语中称<strong>已然形</strong>。现代日语中常用于接续表示假定的助动词。</p></li>
<li><p><strong>命令形</strong>。不接续或接续终止助词表示命令。</p></li>
<li><p><strong>意志形</strong>。主要用于表达意志。</p></li>
</ul>
<div class="note info"><p>意志形是现代日语新产生的一种活用类型，部分语法书认为意志形也是未然形的一种。</p>
</div>
<h3 id="动词活用规则">动词活用规则</h3>
<p>现代日语的动词按照活用规则的不同分类为：</p>
<ul>
<li><p><strong>五段动词</strong>。形式为词干加上某一个ウ段假名构成，现代日语中合法的五段动词词尾有「く、ぐ、う、つ、る、ぶ、む、ぬ、す」，比如「書く、読む、話す」。</p></li>
<li><p><strong>一段动词</strong>。形式一般为一个イ段假名或者エ段假名结尾的词干加上「る」构成，比如「食べる、教える、起きる」。有一些细化为<strong>上一段动词</strong>和<strong>下一段动词</strong>的说法，这里可以简单理解为以イ段假名接续的是上一段动词，以エ段假名接续的是下一段动词。</p></li>
<li><p><strong>サ变动词</strong>。形式为「する」或者某一个词干加上「する」，同时也有一些以「ずる」结尾的动词也是サ变动词。比如「する、勉強する、散歩する、感ずる、禁ずる」。</p></li>
<li><p><strong>カ变动词</strong>。只有「来る」是カ变动词。</p></li>
</ul>
<p>下面将给出动词六种活用的变形规则。这里额外说明，动词的连用形分成两类，即第一连用形和第二连用形。动词的第二连用形是第一连用形接续某些特殊助动词时发生音便产生的。此外，还有部分动词是不规则的，会在表后的注释中给出。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">動詞類型</th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">第一連用形</th>
<th style="text-align: center;">第二連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">仮定形</th>
<th style="text-align: center;">命令形</th>
<th style="text-align: center;">意志形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">五段動詞「か行」</td>
<td style="text-align: center;">書く</td>
<td style="text-align: center;">書か</td>
<td style="text-align: center;">書き</td>
<td style="text-align: center;">書い</td>
<td style="text-align: center;">書く</td>
<td style="text-align: center;">書け</td>
<td style="text-align: center;">書け</td>
<td style="text-align: center;">書こ</td>
</tr>
<tr class="even">
<td style="text-align: center;">五段動詞「が行」</td>
<td style="text-align: center;">泳ぐ</td>
<td style="text-align: center;">泳が</td>
<td style="text-align: center;">泳ぎ</td>
<td style="text-align: center;">泳い</td>
<td style="text-align: center;">泳ぐ</td>
<td style="text-align: center;">泳げ</td>
<td style="text-align: center;">泳げ</td>
<td style="text-align: center;">泳ご</td>
</tr>
<tr class="odd">
<td style="text-align: center;">五段動詞「ば行」</td>
<td style="text-align: center;">飛ぶ</td>
<td style="text-align: center;">飛ば</td>
<td style="text-align: center;">飛び</td>
<td style="text-align: center;">飛ん</td>
<td style="text-align: center;">飛ぶ</td>
<td style="text-align: center;">飛べ</td>
<td style="text-align: center;">飛べ</td>
<td style="text-align: center;">飛ぼ</td>
</tr>
<tr class="even">
<td style="text-align: center;">五段動詞「ま行」</td>
<td style="text-align: center;">読む</td>
<td style="text-align: center;">読ま</td>
<td style="text-align: center;">読み</td>
<td style="text-align: center;">読ん</td>
<td style="text-align: center;">読む</td>
<td style="text-align: center;">読め</td>
<td style="text-align: center;">読め</td>
<td style="text-align: center;">読も</td>
</tr>
<tr class="odd">
<td style="text-align: center;">五段動詞「な行」</td>
<td style="text-align: center;">死ぬ</td>
<td style="text-align: center;">死な</td>
<td style="text-align: center;">死に</td>
<td style="text-align: center;">死ん</td>
<td style="text-align: center;">死ぬ</td>
<td style="text-align: center;">死ね</td>
<td style="text-align: center;">死ね</td>
<td style="text-align: center;">死の</td>
</tr>
<tr class="even">
<td style="text-align: center;">五段動詞「あ行」</td>
<td style="text-align: center;">歌う</td>
<td style="text-align: center;"><strong>歌わ</strong></td>
<td style="text-align: center;">歌い</td>
<td style="text-align: center;">歌っ</td>
<td style="text-align: center;">歌う</td>
<td style="text-align: center;">歌え</td>
<td style="text-align: center;">歌え</td>
<td style="text-align: center;">歌お</td>
</tr>
<tr class="odd">
<td style="text-align: center;">五段動詞「た行」</td>
<td style="text-align: center;">立つ</td>
<td style="text-align: center;">立た</td>
<td style="text-align: center;">立ち</td>
<td style="text-align: center;">立っ</td>
<td style="text-align: center;">立つ</td>
<td style="text-align: center;">立て</td>
<td style="text-align: center;">立て</td>
<td style="text-align: center;">立と</td>
</tr>
<tr class="even">
<td style="text-align: center;">五段動詞「ら行」</td>
<td style="text-align: center;">降る</td>
<td style="text-align: center;">降ら</td>
<td style="text-align: center;">降り</td>
<td style="text-align: center;">降っ</td>
<td style="text-align: center;">降る</td>
<td style="text-align: center;">降れ</td>
<td style="text-align: center;">降れ</td>
<td style="text-align: center;">降ろ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">五段動詞「さ行」</td>
<td style="text-align: center;">話す</td>
<td style="text-align: center;">話さ</td>
<td style="text-align: center;">話し</td>
<td style="text-align: center;">話し</td>
<td style="text-align: center;">話す</td>
<td style="text-align: center;">話せ</td>
<td style="text-align: center;">話せ</td>
<td style="text-align: center;">話そ</td>
</tr>
<tr class="even">
<td style="text-align: center;">上一段動詞</td>
<td style="text-align: center;">起きる</td>
<td style="text-align: center;">起き</td>
<td style="text-align: center;">起き</td>
<td style="text-align: center;">起き</td>
<td style="text-align: center;">起きる</td>
<td style="text-align: center;">起きれ</td>
<td style="text-align: center;">起きよ／起きろ</td>
<td style="text-align: center;">起きよ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">下一段動詞</td>
<td style="text-align: center;">教える</td>
<td style="text-align: center;">教え</td>
<td style="text-align: center;">教え</td>
<td style="text-align: center;">教え</td>
<td style="text-align: center;">教える</td>
<td style="text-align: center;">教えれ</td>
<td style="text-align: center;">教えよ／教えろ</td>
<td style="text-align: center;">教えよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">サ変動詞</td>
<td style="text-align: center;">する</td>
<td style="text-align: center;">し／せ／さ</td>
<td style="text-align: center;">し</td>
<td style="text-align: center;">し</td>
<td style="text-align: center;">する</td>
<td style="text-align: center;">すれ</td>
<td style="text-align: center;">しろ／せよ</td>
<td style="text-align: center;">しよ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">カ変動詞</td>
<td style="text-align: center;">くる</td>
<td style="text-align: center;">こ</td>
<td style="text-align: center;">き</td>
<td style="text-align: center;">き</td>
<td style="text-align: center;">くる</td>
<td style="text-align: center;">くれ</td>
<td style="text-align: center;">こい</td>
<td style="text-align: center;">こよ</td>
</tr>
</tbody>
</table>
<p>上述规则的例外包括：</p>
<ul>
<li>五段动词「行く」的第二连用形发生促音便而非イ音变。</li>
</ul>
<div class="note info no-icon"><p>横浜に<strong>行っ</strong>たことがある。</p>
</div>
<ul>
<li>五段动词「問う、乞う」的第二连用形发生罕见的ウ音便而非促音变。</li>
</ul>
<div class="note info no-icon"><p>この大事な件，ぜひ<strong>問う</strong>てください。</p>
</div>
<ul>
<li>五大敬语动词「いらっしゃる、くださる、なさる、おっしゃる、ござる」除去「ござる」之外的四个动词的命令形词尾为「い」而非「れ」。</li>
</ul>
<div class="note info no-icon"><p>鉛筆一本を<strong>ください</strong>。</p>
<p>なんでも<strong>ござれ</strong>。</p>
</div>
<ul>
<li>一段动词「くれる」的命令形为「くれ」而非「くれろ」。</li>
</ul>
<div class="note info no-icon"><p>あの新聞を取って<strong>くれ</strong>。</p>
</div>
<ul>
<li>口语中允许以「する」结尾的サ变动词按照类似五段动词的方式活用，如下表所示。</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">動詞類型</th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">第一連用形</th>
<th style="text-align: center;">第二連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">仮定形</th>
<th style="text-align: center;">命令形</th>
<th style="text-align: center;">意志形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">サ変動詞</td>
<td style="text-align: center;">愛する</td>
<td style="text-align: center;">愛し／愛せ／愛さ</td>
<td style="text-align: center;">愛し</td>
<td style="text-align: center;">愛し</td>
<td style="text-align: center;">愛する</td>
<td style="text-align: center;">愛すれ</td>
<td style="text-align: center;">愛しろ／愛せよ</td>
<td style="text-align: center;">愛しよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">五段動詞</td>
<td style="text-align: center;">愛する</td>
<td style="text-align: center;"><strong>愛さ</strong></td>
<td style="text-align: center;">愛し</td>
<td style="text-align: center;">愛し</td>
<td style="text-align: center;"><strong>愛す</strong></td>
<td style="text-align: center;"><strong>愛せ</strong></td>
<td style="text-align: center;"><strong>愛せ</strong></td>
<td style="text-align: center;">×</td>
</tr>
</tbody>
</table>
<p>而以「ずる」结尾的サ变动词可以按照类似一段动词的方式活用，如下表所示。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">動詞類型</th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">第一連用形</th>
<th style="text-align: center;">第二連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">仮定形</th>
<th style="text-align: center;">命令形</th>
<th style="text-align: center;">意志形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">サ変動詞</td>
<td style="text-align: center;">信ずる</td>
<td style="text-align: center;">信じ／信ぜ</td>
<td style="text-align: center;">信じ</td>
<td style="text-align: center;">信じ</td>
<td style="text-align: center;">信ずる</td>
<td style="text-align: center;">信ずれ</td>
<td style="text-align: center;">信じろ／信ぜよ</td>
<td style="text-align: center;">信じよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">一段動詞</td>
<td style="text-align: center;">信ずる</td>
<td style="text-align: center;"><strong>信じ</strong></td>
<td style="text-align: center;">信じ</td>
<td style="text-align: center;">信じ</td>
<td style="text-align: center;"><strong>信じる</strong></td>
<td style="text-align: center;"><strong>信じれ</strong></td>
<td style="text-align: center;"><strong>信じろ／信じよ</strong></td>
<td style="text-align: center;">信じよ</td>
</tr>
</tbody>
</table>
<h3 id="形容词活用规则">形容词活用规则</h3>
<p>现代日语的形容词缺少命令形和意志形，这两种活用具有其他的替代表达。形容词依然具有两种连用形，其区别在于接续的助动词的不同。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">類型</th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">第一連用形</th>
<th style="text-align: center;">第二連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">仮定形</th>
<th style="text-align: center;">命令形</th>
<th style="text-align: center;">意志形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">形容詞</td>
<td style="text-align: center;">高い</td>
<td style="text-align: center;">高かろ</td>
<td style="text-align: center;">高く</td>
<td style="text-align: center;">高かっ</td>
<td style="text-align: center;">高い／高き</td>
<td style="text-align: center;">高けれ</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
</tbody>
</table>
<p>形容词的命令形一般可以用第一连用形接续动词命令形来完成。</p>
<div class="note info no-icon"><p>もう遅刻から，<strong>はやく</strong>しろう。</p>
</div>
<p>而意志形可以使用助动词「です」的活用表达。</p>
<div class="note info no-icon"><p>この服はデザインが良くて値段が安い，買って<strong>いい</strong>でしょう？</p>
</div>
<p>现代日语中仅有一个不规则形容词，即「いい」。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">類型</th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">第一連用形</th>
<th style="text-align: center;">第二連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">仮定形</th>
<th style="text-align: center;">命令形</th>
<th style="text-align: center;">意志形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">形容詞「特別」</td>
<td style="text-align: center;">いい</td>
<td style="text-align: center;">よかろ</td>
<td style="text-align: center;">よく</td>
<td style="text-align: center;">よかっ</td>
<td style="text-align: center;">いい</td>
<td style="text-align: center;">よけれ</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
</tbody>
</table>
<h3 id="形容动词活用规则">形容动词活用规则</h3>
<p>现代日语的形容动词分为两类，即ダ活用形容动词和タルト活用形容动词，两者分别对应古日语的ナリ活用形容动词和タリ活用形容动词。一般而言，タルト活用形容动词是词干为汉字叠字或者以「然」结尾的汉字词，其一般只具有连用形和连体形，分别作副词和形容词使用。ダ活用形容动词则缺少命令形和意志形，其余活用方式均存在，而缺失的两种活用具有其他的替代表达。另外，ダ活用形容动词有三种连用形，用于不同的场景。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">類型</th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">第一連用形</th>
<th style="text-align: center;">第二連用形</th>
<th style="text-align: center;">第三連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">仮定形</th>
<th style="text-align: center;">命令形</th>
<th style="text-align: center;">意志形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">ダ活用</td>
<td style="text-align: center;">静かだ</td>
<td style="text-align: center;">静かだろ</td>
<td style="text-align: center;">静かで</td>
<td style="text-align: center;">静かだっ</td>
<td style="text-align: center;">静かに</td>
<td style="text-align: center;">静かな</td>
<td style="text-align: center;">静かなら</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="even">
<td style="text-align: center;">タルト活用</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">平然と</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">平然たる</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
</tbody>
</table>
<p>ダ活用形容动词还有一种特殊的终止形，即「静かです」。这并不是严格的形容动词终止形，因为其中包含了助动词「です」，该助动词还可以继续活用表达更多的含义。可以理解为形容动词的某一种终止形必须借助给定的助动词完成，但是后续在这个助动词上的活用并不是形容动词的活用。</p>
<p>ダ活用形容动词命令形的替代表达类似形容词，即连用形接续动词的命令形。</p>
<div class="note info no-icon"><p>うるさ過ぎて，<strong>静かに</strong>しろう。</p>
</div>
<p>ダ活用形容动词意志形的替代表达有两种，一种类似于形容词，即使用助动词「です」的活用表达，一种是使用未然形。</p>
<div class="note info no-icon"><p>この街は<strong>にぎやか</strong>でしょう。</p>
<p>この街は<strong>にぎやかだろ</strong>う。</p>
</div>
<p>形容动词的活用规则具有以下的例外。</p>
<ul>
<li>古日语形容词退化得到的形容动词「同じだ」有两种连体形，除去规则变化的「同じな」，还具有另外一种继承自古日语形容词的「同じ」形式。规则变化的连体形用于接续「の、ので、のに」等助词，而修饰一般体言的时候使用特殊变化的连体形。</li>
</ul>
<div class="note info no-icon"><p>韓国語の文法が日本語のとほとんど<strong>同じな</strong>ので，それほど難しくないです。</p>
<p>私たちは<strong>同じ</strong>学校の卒業生。</p>
</div>
<p>此外，「同じ」可以用作副词使用。并且与之类似的副词「同じく」也在现代日语中使用，但现代日语已经不认为这属于「同じだ」的活用，而是认为是新词汇。</p>
<ul>
<li>部分古日语中的ナリ活用形容动词在现代日语中退化，仅保留了连体形活用，而丢失了其他活用形式。这些形容动词包括「大きな、小さな、おかしな」等。</li>
</ul>
<h2 id="古日语用言活用规则简介">古日语用言活用规则简介</h2>
<p>本部分会简要介绍古日语的用言活用规则，主要目的是解释现代日语语法中部分古语残留。</p>
<p>古日语的动词分为五个正格类型和四个变格类型。</p>
<ul>
<li><p><strong>四段动词</strong>。古语的四段动词基本上演化成为了现代的五段动词，新增加的一段即现代语之中的意志形。四段动词合法的词尾包括「く、ぐ、ふ、つ、る、ぶ、む、す」，这里与现代语相比缺失「ぬ」，这是因为古语中「死ぬ」并非四段动词。</p></li>
<li><p><strong>上一段动词</strong>。古语的上一段动词基本上演化成为了现代的上一段动词。</p></li>
<li><p><strong>下一段动词</strong>。这类动词包括「蹴る」，这些动词演化为现代的五段动词。</p></li>
<li><p><strong>上二段动词</strong>。古语的上二段动词基本上通过将词尾固化为イ段后添加新词尾「る」的方式演化成为了现代的上一段动词。</p></li>
<li><p><strong>下二段动词</strong>。古语的下二段动词基本上通过将词尾固化为エ段后添加新词尾「る」的方式演化成为了现代的下一段动词。</p></li>
<li><p><strong>ラ变动词</strong>。这类动词包括「あり、をり、はべり、いまそかり」，这些动词演化为现代的五段动词。</p></li>
<li><p><strong>ナ变动词</strong>。这类动词包括「死ぬ、往ぬ」，其中「死ぬ」演化为现代的五段动词，而「往ぬ」被废弃不使用。</p></li>
<li><p><strong>カ变动词</strong>。这类动词包括「く」，这些动词演化为现代的カ变动词。</p></li>
<li><p><strong>サ变动词</strong>。这类动词包括「す」，这些动词演化为现代的サ变动词。</p></li>
</ul>
<p>古日语中动词的活用仅有六种，缺失现代语的意志形，且假定性此时称为已然形。另外，古日语动词不区分第一和第二连用形。据此，古日语动词的活用规则表现如下表。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">動詞類型</th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">已然形</th>
<th style="text-align: center;">命令形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">四段動詞「か行」</td>
<td style="text-align: center;">書く</td>
<td style="text-align: center;">書か</td>
<td style="text-align: center;">書き</td>
<td style="text-align: center;">書く</td>
<td style="text-align: center;">書け</td>
<td style="text-align: center;">書け</td>
</tr>
<tr class="even">
<td style="text-align: center;">四段動詞「が行」</td>
<td style="text-align: center;">泳ぐ</td>
<td style="text-align: center;">泳が</td>
<td style="text-align: center;">泳ぎ</td>
<td style="text-align: center;">泳ぐ</td>
<td style="text-align: center;">泳げ</td>
<td style="text-align: center;">泳げ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">四段動詞「ば行」</td>
<td style="text-align: center;">飛ぶ</td>
<td style="text-align: center;">飛ば</td>
<td style="text-align: center;">飛び</td>
<td style="text-align: center;">飛ぶ</td>
<td style="text-align: center;">飛べ</td>
<td style="text-align: center;">飛べ</td>
</tr>
<tr class="even">
<td style="text-align: center;">四段動詞「ま行」</td>
<td style="text-align: center;">読む</td>
<td style="text-align: center;">読ま</td>
<td style="text-align: center;">読み</td>
<td style="text-align: center;">読む</td>
<td style="text-align: center;">読め</td>
<td style="text-align: center;">読め</td>
</tr>
<tr class="odd">
<td style="text-align: center;">四段動詞「は行」</td>
<td style="text-align: center;">歌ふ</td>
<td style="text-align: center;">歌は</td>
<td style="text-align: center;">歌ひ</td>
<td style="text-align: center;">歌ふ</td>
<td style="text-align: center;">歌へ</td>
<td style="text-align: center;">歌へ</td>
</tr>
<tr class="even">
<td style="text-align: center;">四段動詞「た行」</td>
<td style="text-align: center;">立つ</td>
<td style="text-align: center;">立た</td>
<td style="text-align: center;">立ち</td>
<td style="text-align: center;">立つ</td>
<td style="text-align: center;">立て</td>
<td style="text-align: center;">立て</td>
</tr>
<tr class="odd">
<td style="text-align: center;">四段動詞「ら行」</td>
<td style="text-align: center;">降る</td>
<td style="text-align: center;">降ら</td>
<td style="text-align: center;">降り</td>
<td style="text-align: center;">降る</td>
<td style="text-align: center;">降れ</td>
<td style="text-align: center;">降れ</td>
</tr>
<tr class="even">
<td style="text-align: center;">四段動詞「さ行」</td>
<td style="text-align: center;">話す</td>
<td style="text-align: center;">話さ</td>
<td style="text-align: center;">話し</td>
<td style="text-align: center;">話す</td>
<td style="text-align: center;">話せ</td>
<td style="text-align: center;">話せ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">上一段動詞「か行」</td>
<td style="text-align: center;">着る</td>
<td style="text-align: center;">き</td>
<td style="text-align: center;">き</td>
<td style="text-align: center;">きる</td>
<td style="text-align: center;">きれ</td>
<td style="text-align: center;">きよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">上一段動詞「な行」</td>
<td style="text-align: center;">似る</td>
<td style="text-align: center;">に</td>
<td style="text-align: center;">に</td>
<td style="text-align: center;">にる</td>
<td style="text-align: center;">にれ</td>
<td style="text-align: center;">によ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">上一段動詞「は行」</td>
<td style="text-align: center;">干る</td>
<td style="text-align: center;">ひ</td>
<td style="text-align: center;">ひ</td>
<td style="text-align: center;">ひる</td>
<td style="text-align: center;">ひれ</td>
<td style="text-align: center;">ひよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">上一段動詞「ま行」</td>
<td style="text-align: center;">見る</td>
<td style="text-align: center;">み</td>
<td style="text-align: center;">み</td>
<td style="text-align: center;">みる</td>
<td style="text-align: center;">みれ</td>
<td style="text-align: center;">みよ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">上一段動詞「や行」</td>
<td style="text-align: center;">射る</td>
<td style="text-align: center;">い</td>
<td style="text-align: center;">い</td>
<td style="text-align: center;">いる</td>
<td style="text-align: center;">いれ</td>
<td style="text-align: center;">いよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">上一段動詞「わ行」</td>
<td style="text-align: center;">居る</td>
<td style="text-align: center;">ゐ</td>
<td style="text-align: center;">ゐ</td>
<td style="text-align: center;">ゐる</td>
<td style="text-align: center;">ゐれ</td>
<td style="text-align: center;">ゐよ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">下一段動詞</td>
<td style="text-align: center;">蹴る</td>
<td style="text-align: center;">け</td>
<td style="text-align: center;">け</td>
<td style="text-align: center;">ける</td>
<td style="text-align: center;">けれ</td>
<td style="text-align: center;">けよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">上二段動詞「か行」</td>
<td style="text-align: center;">生く</td>
<td style="text-align: center;">生き</td>
<td style="text-align: center;">生き</td>
<td style="text-align: center;">生くる</td>
<td style="text-align: center;">生くれ</td>
<td style="text-align: center;">生きよ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">上二段動詞「が行」</td>
<td style="text-align: center;">過ぐ</td>
<td style="text-align: center;">過ぎ</td>
<td style="text-align: center;">過ぎ</td>
<td style="text-align: center;">過ぐる</td>
<td style="text-align: center;">過ぐれ</td>
<td style="text-align: center;">過ぎよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">上二段動詞「た行」</td>
<td style="text-align: center;">落つ</td>
<td style="text-align: center;">落ち</td>
<td style="text-align: center;">落ち</td>
<td style="text-align: center;">落つる</td>
<td style="text-align: center;">落つれ</td>
<td style="text-align: center;">落ちよ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">上二段動詞「だ行」</td>
<td style="text-align: center;">閉づ</td>
<td style="text-align: center;">閉ぢ</td>
<td style="text-align: center;">閉ぢ</td>
<td style="text-align: center;">閉づる</td>
<td style="text-align: center;">閉づれ</td>
<td style="text-align: center;">閉ぢよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">上二段動詞「は行」</td>
<td style="text-align: center;">恋ふ</td>
<td style="text-align: center;">恋ひ</td>
<td style="text-align: center;">恋ひ</td>
<td style="text-align: center;">恋ふる</td>
<td style="text-align: center;">恋ふれ</td>
<td style="text-align: center;">恋ひよ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">上二段動詞「ば行」</td>
<td style="text-align: center;">詫ぶ</td>
<td style="text-align: center;">詫び</td>
<td style="text-align: center;">詫び</td>
<td style="text-align: center;">詫ぶる</td>
<td style="text-align: center;">詫ぶれ</td>
<td style="text-align: center;">詫びよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">上二段動詞「ま行」</td>
<td style="text-align: center;">恨む</td>
<td style="text-align: center;">恨み</td>
<td style="text-align: center;">恨み</td>
<td style="text-align: center;">恨むる</td>
<td style="text-align: center;">恨むれ</td>
<td style="text-align: center;">恨みよ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">上二段動詞「や行」</td>
<td style="text-align: center;">老ゆ</td>
<td style="text-align: center;">老い</td>
<td style="text-align: center;">老い</td>
<td style="text-align: center;">老ゆる</td>
<td style="text-align: center;">老ゆれ</td>
<td style="text-align: center;">老いよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">上二段動詞「ら行」</td>
<td style="text-align: center;">懲る</td>
<td style="text-align: center;">懲り</td>
<td style="text-align: center;">懲り</td>
<td style="text-align: center;">懲るる</td>
<td style="text-align: center;">懲るれ</td>
<td style="text-align: center;">懲りよ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">下二段動詞「か行」</td>
<td style="text-align: center;">受く</td>
<td style="text-align: center;">受け</td>
<td style="text-align: center;">受け</td>
<td style="text-align: center;">受くる</td>
<td style="text-align: center;">受くれ</td>
<td style="text-align: center;">受けよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">下二段動詞「が行」</td>
<td style="text-align: center;">告げ</td>
<td style="text-align: center;">告げ</td>
<td style="text-align: center;">告げ</td>
<td style="text-align: center;">告ぐる</td>
<td style="text-align: center;">告ぐれ</td>
<td style="text-align: center;">告げよ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">下二段動詞「た行」</td>
<td style="text-align: center;">捨つ</td>
<td style="text-align: center;">捨て</td>
<td style="text-align: center;">捨て</td>
<td style="text-align: center;">捨つる</td>
<td style="text-align: center;">捨つれ</td>
<td style="text-align: center;">捨てよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">下二段動詞「だ行」</td>
<td style="text-align: center;">出づ</td>
<td style="text-align: center;">出で</td>
<td style="text-align: center;">出で</td>
<td style="text-align: center;">出づる</td>
<td style="text-align: center;">出づれ</td>
<td style="text-align: center;">出でよ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">下二段動詞「は行」</td>
<td style="text-align: center;">答ふ</td>
<td style="text-align: center;">答へ</td>
<td style="text-align: center;">答へ</td>
<td style="text-align: center;">答ふる</td>
<td style="text-align: center;">答ふれ</td>
<td style="text-align: center;">答へよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">下二段動詞「ば行」</td>
<td style="text-align: center;">並ぶ</td>
<td style="text-align: center;">並べ</td>
<td style="text-align: center;">並べ</td>
<td style="text-align: center;">並ぶる</td>
<td style="text-align: center;">並ぶれ</td>
<td style="text-align: center;">並べよ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">下二段動詞「さ行」</td>
<td style="text-align: center;">失す</td>
<td style="text-align: center;">失せ</td>
<td style="text-align: center;">失せ</td>
<td style="text-align: center;">失する</td>
<td style="text-align: center;">失すれ</td>
<td style="text-align: center;">失せよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">下二段動詞「ざ行」</td>
<td style="text-align: center;">混ず</td>
<td style="text-align: center;">混ぜ</td>
<td style="text-align: center;">混ぜ</td>
<td style="text-align: center;">混ずる</td>
<td style="text-align: center;">混ずれ</td>
<td style="text-align: center;">混ぜよ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">下二段動詞「ま行」</td>
<td style="text-align: center;">求む</td>
<td style="text-align: center;">求め</td>
<td style="text-align: center;">求め</td>
<td style="text-align: center;">求むる</td>
<td style="text-align: center;">求むれ</td>
<td style="text-align: center;">求めよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">下二段動詞「や行」</td>
<td style="text-align: center;">見ゆ</td>
<td style="text-align: center;">見え</td>
<td style="text-align: center;">見え</td>
<td style="text-align: center;">見ゆる</td>
<td style="text-align: center;">見ゆれ</td>
<td style="text-align: center;">見えよ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">下二段動詞「ら行」</td>
<td style="text-align: center;">入る</td>
<td style="text-align: center;">入れ</td>
<td style="text-align: center;">入れ</td>
<td style="text-align: center;">入るる</td>
<td style="text-align: center;">入るれ</td>
<td style="text-align: center;">入れよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">下二段動詞「わ行」</td>
<td style="text-align: center;">植う</td>
<td style="text-align: center;">植ゑ</td>
<td style="text-align: center;">植ゑ</td>
<td style="text-align: center;">植うる</td>
<td style="text-align: center;">植うれ</td>
<td style="text-align: center;">植ゑよ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">下二段動詞「あ行単字」</td>
<td style="text-align: center;">う（得）</td>
<td style="text-align: center;">え</td>
<td style="text-align: center;">え</td>
<td style="text-align: center;">うる</td>
<td style="text-align: center;">うれ</td>
<td style="text-align: center;">えよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">下二段動詞「な行単字」</td>
<td style="text-align: center;">ぬ（寝）</td>
<td style="text-align: center;">ね</td>
<td style="text-align: center;">ね</td>
<td style="text-align: center;">ぬる</td>
<td style="text-align: center;">ぬれ</td>
<td style="text-align: center;">ねよ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">下二段動詞「は行単字」</td>
<td style="text-align: center;">ふ（経）</td>
<td style="text-align: center;">へ</td>
<td style="text-align: center;">へ</td>
<td style="text-align: center;">ふる</td>
<td style="text-align: center;">ふれ</td>
<td style="text-align: center;">へよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">ラ変動詞</td>
<td style="text-align: center;">有り</td>
<td style="text-align: center;">有ら</td>
<td style="text-align: center;">有り</td>
<td style="text-align: center;">有る</td>
<td style="text-align: center;">有れ</td>
<td style="text-align: center;">有れ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">ナ変動詞</td>
<td style="text-align: center;">死ぬ</td>
<td style="text-align: center;">死な</td>
<td style="text-align: center;">死に</td>
<td style="text-align: center;">死ぬる</td>
<td style="text-align: center;">死ぬれ</td>
<td style="text-align: center;">死ね</td>
</tr>
<tr class="even">
<td style="text-align: center;">サ変動詞</td>
<td style="text-align: center;">す</td>
<td style="text-align: center;">せ</td>
<td style="text-align: center;">し</td>
<td style="text-align: center;">する</td>
<td style="text-align: center;">すれ</td>
<td style="text-align: center;">せよ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">カ変動詞</td>
<td style="text-align: center;">く</td>
<td style="text-align: center;">こ</td>
<td style="text-align: center;">き</td>
<td style="text-align: center;">くる</td>
<td style="text-align: center;">くれ</td>
<td style="text-align: center;">こ／こよ</td>
</tr>
</tbody>
</table>
<p>和现代语对比，可以得到以下的规律。</p>
<ul>
<li><p>古语四段动词几乎完全演化为现代语五段动词，且除了假名标记发生一次变动（即「ふ」转写为「う」）和增加意志形之外，其余保持规则。</p></li>
<li><p>古语的上一段动词几乎完全演化为现代的上一段动词，且几乎没有发生活用规则变动。而古语唯一的下一段动词则直接变为现代的五段动词。</p></li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">已然形</th>
<th style="text-align: center;">命令形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">文語</td>
<td style="text-align: center;">着る</td>
<td style="text-align: center;">き</td>
<td style="text-align: center;">き</td>
<td style="text-align: center;">きる</td>
<td style="text-align: center;">きれ</td>
<td style="text-align: center;">きよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">現代語</td>
<td style="text-align: center;">着る</td>
<td style="text-align: center;">き</td>
<td style="text-align: center;">き</td>
<td style="text-align: center;">きる</td>
<td style="text-align: center;">きれ</td>
<td style="text-align: center;"><strong>きろ／きよ</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>古语的二段动词在现代语之中的残留痕迹较为明显。特征是除去词干外，有类似「きる、ける」这样的以イエ段假名加上「る」结尾的双假名词尾。这里的イエ段假名是古语残留的词尾，但是已经固化，而「る」则是现代语的词尾。另外，由于古语下一段动词完全消失，所以现代的下一段动词几乎全部都是古语下二段动词的演变产物。</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">已然形</th>
<th style="text-align: center;">命令形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">文語</td>
<td style="text-align: center;">捨つ</td>
<td style="text-align: center;">捨て</td>
<td style="text-align: center;">捨て</td>
<td style="text-align: center;">捨つる</td>
<td style="text-align: center;">捨つれ</td>
<td style="text-align: center;">捨てよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">現代語</td>
<td style="text-align: center;">捨てる</td>
<td style="text-align: center;">捨て</td>
<td style="text-align: center;">捨て</td>
<td style="text-align: center;"><strong>捨てる</strong></td>
<td style="text-align: center;"><strong>捨てれ</strong></td>
<td style="text-align: center;"><strong>捨てろ／捨てよ</strong></td>
</tr>
</tbody>
</table>
<p>但是在合流过程中，三个单音节的下二段动词「う、ぬ、ふ」演化路径有差别。「ぬ、ふ」类似一般的下二段动词，演化为现代的下一段动词「寝る、経る」。但是「う」则一定程度上保留了下二段动词的痕迹，演化出了两个动词「うる、える」，汉字表记均为「得る」。一般而言，使用较多的是「える」读音，但是「うる」音依然可能会出现，这也就是一种演化残留。</p>
<ul>
<li>ラ变动词完全合并进现代语五段动词，并且在一部分情况下可以看出遗留。现代语五大敬语动词有一部分实际上是古语中的ラ变复合动词，比如「ござる」来源于「ござあり」。</li>
</ul>
<hr />
<p>古语形容词分为两类，即ク活用形容词和シク活用形容词，活用规则见下。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">形容詞類型</th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">已然形</th>
<th style="text-align: center;">命令形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">ク活用「第一」</td>
<td style="text-align: center;">無し</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">無く</td>
<td style="text-align: center;">無き</td>
<td style="text-align: center;">無けれ</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="even">
<td style="text-align: center;">ク活用「第二」</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">無から</td>
<td style="text-align: center;">無かり</td>
<td style="text-align: center;">無かる</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">無かれ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">シク活用「第一」</td>
<td style="text-align: center;">美し</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">美しく</td>
<td style="text-align: center;">美しき</td>
<td style="text-align: center;">美しけれ</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="even">
<td style="text-align: center;">シク活用「第二」</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">美しから</td>
<td style="text-align: center;">美しかり</td>
<td style="text-align: center;">美しかる</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">美しかれ</td>
</tr>
</tbody>
</table>
<p>这里的第二活用则是一种特殊的使用方法，也就是将形容词连用形「○く」加上「あり」后用「あり」的活用来弥补原先形容词规则中缺失的未然形和命令形。在演变过程中，「○くあり」逐渐连读为「○かり」，从而可以认为这是形容词的一种特殊活用，不将其认为是「あり」的活用。</p>
<p>古语形容词演变为现代语形容词的时候，两种活用合流，并且黏性词尾从「し」变为「い」。具体演变为，ク活用形容词直接将「し」变为「い」，而シク活用形容词直接加上新词尾「い」。而各种活用中，加「あり」词尾产生的活用逐步消失或进一步演变，而现代语中形容词规则占主流的依然是形容词最初的活用规则。对比表如下。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">形容詞類型</th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">已然形</th>
<th style="text-align: center;">命令形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">ク活用「第一」</td>
<td style="text-align: center;">無し</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">無く</td>
<td style="text-align: center;">無き</td>
<td style="text-align: center;">無けれ</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="even">
<td style="text-align: center;">ク活用「第二」</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">無から</td>
<td style="text-align: center;">無かり</td>
<td style="text-align: center;">無かる</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">無かれ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">現代語</td>
<td style="text-align: center;">無い</td>
<td style="text-align: center;">無かろ</td>
<td style="text-align: center;">無く／無かっ</td>
<td style="text-align: center;">無い／無き</td>
<td style="text-align: center;">無けれ</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="even">
<td style="text-align: center;">シク活用「第一」</td>
<td style="text-align: center;">美し</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">美しく</td>
<td style="text-align: center;">美しき</td>
<td style="text-align: center;">美しけれ</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="odd">
<td style="text-align: center;">シク活用「第二」</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">美しから</td>
<td style="text-align: center;">美しかり</td>
<td style="text-align: center;">美しかる</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">美しかれ</td>
</tr>
<tr class="even">
<td style="text-align: center;">現代語</td>
<td style="text-align: center;">美しい</td>
<td style="text-align: center;">美しかろ</td>
<td style="text-align: center;">美しく／美しかっ</td>
<td style="text-align: center;">美しい／美しき</td>
<td style="text-align: center;">美しけれ</td>
<td style="text-align: center;">×</td>
</tr>
</tbody>
</table>
<p>这种演变解释了一个语言现象，即现代语中有大量的「しい」结尾的形容词，这些形容词几乎全部是古语シク活用形容词演变的遗留。另外，现代语的形容词依然保留了部分古语用法，比如以「し」作词尾的形容词依然存留于口语中，比如「なし、よし」等惯用语。</p>
<hr />
<p>古语形容动词分为两类，即ナリ活用形容词和タリ活用形容词，活用规则见下。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">形容動詞類型</th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">已然形</th>
<th style="text-align: center;">命令形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">ナリ活用</td>
<td style="text-align: center;">静かなり</td>
<td style="text-align: center;">静かなら</td>
<td style="text-align: center;">静かなり／静かに</td>
<td style="text-align: center;">静かなる</td>
<td style="text-align: center;">静かなれ</td>
<td style="text-align: center;">静かなれ</td>
</tr>
<tr class="even">
<td style="text-align: center;">タリ活用</td>
<td style="text-align: center;">平然たり</td>
<td style="text-align: center;">平然たら</td>
<td style="text-align: center;">平然たり／平然と</td>
<td style="text-align: center;">平然たる</td>
<td style="text-align: center;">平然たれ</td>
<td style="text-align: center;">平然たれ</td>
</tr>
</tbody>
</table>
<p>这里所有的活用和ラ变动词很类似。有一种看法是，形容动词活用本身就是词干连用形接续「あり」后用「あり」的活用表达的，而和形容词第二活用类似「○にあり／○とあり」随后连读为「○なり／○たり」，从而形成了形容动词活用规则。</p>
<p>古语形容动词演变为现代语形容词的时候，两种活用并未合流，并且活用词尾发生了较大的变化。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">形容動詞類型</th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">已然形</th>
<th style="text-align: center;">命令形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">ナリ活用</td>
<td style="text-align: center;">静かなり</td>
<td style="text-align: center;">静かなら</td>
<td style="text-align: center;">静かなり／静かに</td>
<td style="text-align: center;">静かなる</td>
<td style="text-align: center;">静かなれ</td>
<td style="text-align: center;">静かなれ</td>
</tr>
<tr class="even">
<td style="text-align: center;">現代語ダ活用</td>
<td style="text-align: center;">静かだ</td>
<td style="text-align: center;">静かだろ</td>
<td style="text-align: center;">静かで／静かだっ／静かに</td>
<td style="text-align: center;">静かな</td>
<td style="text-align: center;">静かなら</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="odd">
<td style="text-align: center;">タリ活用</td>
<td style="text-align: center;">平然たり</td>
<td style="text-align: center;">平然たら</td>
<td style="text-align: center;">平然たり／平然と</td>
<td style="text-align: center;">平然たる</td>
<td style="text-align: center;">平然たれ</td>
<td style="text-align: center;">平然たれ</td>
</tr>
<tr class="even">
<td style="text-align: center;">現代語タルト活用</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">平然と</td>
<td style="text-align: center;">平然たる</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
</tbody>
</table>
<p>目前来看，形容动词的演变是相当不规则的。</p>
<div class="note info no-icon"><p>目前我正使用的古日语课程之中，是这样介绍ナリ活用形容动词演变的。</p>
<p>首先是「○で」连用形的产生。在使用ナリ活用形容动词修饰的时候常常需要使用连用形接续助词「て」，也就是ナリ活用形容动词常常具有词尾「○にて」。最后「に」音脱落并发生浊化，将助词「て」吸收产生现代语第一连用形「○で」。</p>
<p>室町时代，ナリ活用形容动词已经出现了尾音「る」脱落的现象，即连体形已经逐步以「な」音结尾，并且在部分情况下，终止形也开始使用「な」结尾的形式。另一方面，新产生的连用形「○で」接续动词「ある」产生了新的连体和终止形「○である」，这种形式之后又发生了尾音「る」脱落，演变为「○であ」。而这个形式在关西演化为「○ぢゃ」，在关东演化为「○だ」。此时这些形式均处于混用状态，最后「○だ」使用频率压过其余形式变为现代语的终止形，「○な」则压过其他形式变为现代语的连体形。</p>
<p>上述演化中的连体·终止形「○ぢゃ」开始用于接续「う、た」两个助词，分别表示意识和过去，这分别是未然形和连用形的作用。也就是说未然形接续「う」开始出现「○ぢゃらう」的形式，连用形接续「た」开始出现「○ぢゃった」的形式。随后「ぢゃら」和「ぢゃっ」音便为「だろ」和「だっ」，形成了现代语的未然形和第二连用形。</p>
<p>现代语假定形「○なら」则是由古语已然形「○なれ」接续助词「ば」得到「○なれば」后约音产生。</p>
<p>命令形则在演化的时候由于可以使用动词命令形代替表示而逐步丢失。</p>
</div>
<h2 id="现代日语常用助动词和活用">现代日语常用助动词和活用</h2>
<p>用言的各种活用需要通过助动词进行辅助表意，这里介绍现代日语中较为常用的助动词。另外注意，助动词本身还可以继续活用，一方面是可以表达更深的含义，另一方面是为了补偿用言为了接续助动词而牺牲的进一步活用可能。</p>
<p>此外，这里可能会介绍部分接续体言的助动词。</p>
<p>首先给出接续列表，即这些助动词前面的用言应当使用何种形式。这里可能会遇到用词干接续的情况，词干本身不属于活用的一种，所以没有在上述部分介绍。形容词的词干是终止形去掉「い」，形容动词的词干是终止形去掉「だ」，而动词词干比较模糊，这里不介绍。</p>
<p>另外，这里形容动词一般特指ダ活用形容动词，现代日语的タルト活用形容动词几乎不接续助动词。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">助動詞</th>
<th style="text-align: center;">五段動詞</th>
<th style="text-align: center;">一段動詞</th>
<th style="text-align: center;">サ変動詞</th>
<th style="text-align: center;">カ変動詞</th>
<th style="text-align: center;">形容詞</th>
<th style="text-align: center;">形容動詞</th>
<th style="text-align: center;">体言</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">だ</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">（終止形）</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">原形</td>
</tr>
<tr class="even">
<td style="text-align: center;">です</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">（終止形）</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">原形</td>
</tr>
<tr class="odd">
<td style="text-align: center;">ない</td>
<td style="text-align: center;">未然形</td>
<td style="text-align: center;">未然形</td>
<td style="text-align: center;">「し」未然形</td>
<td style="text-align: center;">未然形</td>
<td style="text-align: center;">第一連用形</td>
<td style="text-align: center;">第一連用形</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="even">
<td style="text-align: center;">ぬ（ん）</td>
<td style="text-align: center;">未然形</td>
<td style="text-align: center;">未然形</td>
<td style="text-align: center;">「せ」未然形</td>
<td style="text-align: center;">未然形</td>
<td style="text-align: center;">第一連用形</td>
<td style="text-align: center;">第一連用形</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="odd">
<td style="text-align: center;">れる</td>
<td style="text-align: center;">未然形</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">「さ」未然形</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="even">
<td style="text-align: center;">られる</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">未然形</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">未然形</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="odd">
<td style="text-align: center;">せる</td>
<td style="text-align: center;">未然形</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">「さ」未然形</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="even">
<td style="text-align: center;">させる</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">未然形</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">未然形</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="odd">
<td style="text-align: center;">ます</td>
<td style="text-align: center;">第一連用形</td>
<td style="text-align: center;">第一連用形</td>
<td style="text-align: center;">第一連用形</td>
<td style="text-align: center;">第一連用形</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="even">
<td style="text-align: center;">たい</td>
<td style="text-align: center;">第一連用形</td>
<td style="text-align: center;">第一連用形</td>
<td style="text-align: center;">第一連用形</td>
<td style="text-align: center;">第一連用形</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="odd">
<td style="text-align: center;">たがる</td>
<td style="text-align: center;">第一連用形</td>
<td style="text-align: center;">第一連用形</td>
<td style="text-align: center;">第一連用形</td>
<td style="text-align: center;">第一連用形</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="even">
<td style="text-align: center;">そうだ「様態」</td>
<td style="text-align: center;">第一連用形</td>
<td style="text-align: center;">第一連用形</td>
<td style="text-align: center;">第一連用形</td>
<td style="text-align: center;">第一連用形</td>
<td style="text-align: center;">詞幹</td>
<td style="text-align: center;">詞幹</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="odd">
<td style="text-align: center;">た</td>
<td style="text-align: center;">第二連用形</td>
<td style="text-align: center;">第二連用形</td>
<td style="text-align: center;">第二連用形</td>
<td style="text-align: center;">第二連用形</td>
<td style="text-align: center;">第二連用形</td>
<td style="text-align: center;">第二連用形</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="even">
<td style="text-align: center;">ようだ</td>
<td style="text-align: center;">連体形</td>
<td style="text-align: center;">連体形</td>
<td style="text-align: center;">連体形</td>
<td style="text-align: center;">連体形</td>
<td style="text-align: center;">連体形</td>
<td style="text-align: center;">連体形</td>
<td style="text-align: center;">+「の」</td>
</tr>
<tr class="odd">
<td style="text-align: center;">そうだ「伝聞」</td>
<td style="text-align: center;">終止形</td>
<td style="text-align: center;">終止形</td>
<td style="text-align: center;">終止形</td>
<td style="text-align: center;">終止形</td>
<td style="text-align: center;">終止形</td>
<td style="text-align: center;">終止形</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="even">
<td style="text-align: center;">らしい</td>
<td style="text-align: center;">終止形</td>
<td style="text-align: center;">終止形</td>
<td style="text-align: center;">終止形</td>
<td style="text-align: center;">終止形</td>
<td style="text-align: center;">終止形</td>
<td style="text-align: center;">詞幹</td>
<td style="text-align: center;">原形</td>
</tr>
<tr class="odd">
<td style="text-align: center;">べし</td>
<td style="text-align: center;">終止形</td>
<td style="text-align: center;">終止形</td>
<td style="text-align: center;">*終止形</td>
<td style="text-align: center;">終止形</td>
<td style="text-align: center;">（×）</td>
<td style="text-align: center;">（×）</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="even">
<td style="text-align: center;">まい</td>
<td style="text-align: center;">終止形</td>
<td style="text-align: center;">*終止形</td>
<td style="text-align: center;">*終止形</td>
<td style="text-align: center;">*終止形</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="odd">
<td style="text-align: center;">う</td>
<td style="text-align: center;">意志形</td>
<td style="text-align: center;">意志形</td>
<td style="text-align: center;">意志形</td>
<td style="text-align: center;">意志形</td>
<td style="text-align: center;">未然形</td>
<td style="text-align: center;">未然形</td>
<td style="text-align: center;">×</td>
</tr>
</tbody>
</table>
<p>首先解释表中打括号的项，这表示这一项可能不正确。其一是形容词终止形接续「だ、です」的问题。现代日语确实常常使用形容词终止形直接接续「だ、です」，但有一种说法是这种用法来源于形容词连体首先接续形式体言「の」，之后由形式体言「の」接续助动词「だ、です」形成的，最后形式体言「の」脱落才有这种用法，此时由于现代日语形容词连体形和终止形同构才有这类说法。</p>
<p>其二是形容词、形容动词接续「べし」的问题。现代日语中这类用法已经很罕见了，所以一般而言认为不存在，但是古日语中存在相关用法。</p>
<p>之后是打星号的项，这表示可能的接续方式不唯一。这里一段动词、カ变动词和サ变动词接续「まい」的时候还可以使用未然形接续。另一方面，由于「まい、べし」均为古日语助动词，サ变动词还可以使用古语终止形「す」接续。</p>
<hr />
<p>之后介绍这些接续规则的特例</p>
<ul>
<li>五段动词「ある」使用未然形接续助动词「ない」的时候直接变为「ない」而非「あらない」。</li>
</ul>
<div class="note info no-icon"><p>この部屋に何も<strong>ない</strong>ので，静かだったんだ。</p>
</div>
<p>而其未然形接续其他助动词的时候形成的「あられる、あらせる、あらぬ」理论存在，但实际很少使用。所以有的时候也有语法书称「ある」的未然形就是「ない」。</p>
<ul>
<li>五大敬语动词「いらっしゃる、くださる、なさる、おっしゃる、ござる」为五段动词，但是其第一连用形接续助动词「ます」的时候词尾变为「い」而非「り」。</li>
</ul>
<div class="note info no-icon"><p>嫌だから近づかないで<strong>ください</strong>ませんか？</p>
</div>
<p>但是这些动词的第一连用形在其他场景下词尾依然为「り」。</p>
<div class="note info no-icon"><p>先生はそのように<strong>おっしゃり</strong>たかったようですが，結局口に出されなかったです。</p>
</div>
<ul>
<li>表示样态的助动词「そうだ」在接续形容词「いい、ない」的时候变为「よさそうだ、なさそうだ」而非「いいそうだ、ないそうだ」。</li>
</ul>
<div class="note info no-icon"><p>元気が<strong>よさ</strong>そうだね。</p>
<p>あいつは少しも楽しく<strong>なさ</strong>そうな顔なんですね。</p>
</div>
<hr />
<p>这些助动词的含义和使用细节会在后面详细讲解，这里首先讲解它们的活用。助动词的活用可以类似于正常的用言，但是它们可能会因为语意的问题缺失一些活用类型。</p>
<p>「たがる」的活用类似于五段动词。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">類型</th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">仮定形</th>
<th style="text-align: center;">命令形</th>
<th style="text-align: center;">意志形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">五段</td>
<td style="text-align: center;">降る</td>
<td style="text-align: center;">降ら</td>
<td style="text-align: center;">降り／降っ</td>
<td style="text-align: center;">降る</td>
<td style="text-align: center;">降れ</td>
<td style="text-align: center;">降れ</td>
<td style="text-align: center;">降ろ</td>
</tr>
<tr class="even">
<td style="text-align: center;">助動詞</td>
<td style="text-align: center;">たがる</td>
<td style="text-align: center;">たがら</td>
<td style="text-align: center;">たがり／たがっ</td>
<td style="text-align: center;">たがる</td>
<td style="text-align: center;">たがれ</td>
<td style="text-align: center;"><strong>×</strong></td>
<td style="text-align: center;">たがろ</td>
</tr>
</tbody>
</table>
<p>「れる、られる、せる、させる」的活用类似于五段动词。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">類型</th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">仮定形</th>
<th style="text-align: center;">命令形</th>
<th style="text-align: center;">意志形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">一段</td>
<td style="text-align: center;">生きる</td>
<td style="text-align: center;">生き</td>
<td style="text-align: center;">生き</td>
<td style="text-align: center;">生きる</td>
<td style="text-align: center;">生きれ</td>
<td style="text-align: center;">生きろ／生きよ</td>
<td style="text-align: center;">生きよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">助動詞</td>
<td style="text-align: center;">れる</td>
<td style="text-align: center;">れ</td>
<td style="text-align: center;">れ</td>
<td style="text-align: center;">れる</td>
<td style="text-align: center;">れれ</td>
<td style="text-align: center;">れろ／れよ</td>
<td style="text-align: center;">れよ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">助動詞</td>
<td style="text-align: center;">られる</td>
<td style="text-align: center;">られ</td>
<td style="text-align: center;">られ</td>
<td style="text-align: center;">られる</td>
<td style="text-align: center;">られれ</td>
<td style="text-align: center;">られろ／られよ</td>
<td style="text-align: center;">られよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">助動詞</td>
<td style="text-align: center;">せる</td>
<td style="text-align: center;">せ</td>
<td style="text-align: center;">せ</td>
<td style="text-align: center;">せる</td>
<td style="text-align: center;">せれ</td>
<td style="text-align: center;">せろ／せよ</td>
<td style="text-align: center;">せよ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">助動詞</td>
<td style="text-align: center;">させる</td>
<td style="text-align: center;">させ</td>
<td style="text-align: center;">させ</td>
<td style="text-align: center;">させる</td>
<td style="text-align: center;">させれ</td>
<td style="text-align: center;">させろ／させよ</td>
<td style="text-align: center;">させよ</td>
</tr>
</tbody>
</table>
<p>「たい、らしい、ない」的活用类似于形容词，这里忽略形容词以「き」结尾的连体形。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">類型</th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">仮定形</th>
<th style="text-align: center;">命令形</th>
<th style="text-align: center;">意志形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">形容詞</td>
<td style="text-align: center;">高い</td>
<td style="text-align: center;">高かろ</td>
<td style="text-align: center;">高く／高かっ</td>
<td style="text-align: center;">高い</td>
<td style="text-align: center;">高けれ</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="even">
<td style="text-align: center;">助動詞</td>
<td style="text-align: center;">たい</td>
<td style="text-align: center;">たかろ</td>
<td style="text-align: center;">たく／たかっ</td>
<td style="text-align: center;">たい</td>
<td style="text-align: center;">たけれ</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="odd">
<td style="text-align: center;">助動詞</td>
<td style="text-align: center;">らしい</td>
<td style="text-align: center;"><strong>×</strong></td>
<td style="text-align: center;">らしく／らしかっ</td>
<td style="text-align: center;">らしい</td>
<td style="text-align: center;">らしけれ</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="even">
<td style="text-align: center;">助動詞</td>
<td style="text-align: center;">ない</td>
<td style="text-align: center;">なかろ</td>
<td style="text-align: center;">なく／なかっ</td>
<td style="text-align: center;">ない</td>
<td style="text-align: center;">なけれ</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
</tbody>
</table>
<p>「だ、ようだ、そうだ（様態）」的活用类似于ダ活用形容动词。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">類型</th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">仮定形</th>
<th style="text-align: center;">命令形</th>
<th style="text-align: center;">意志形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">ダ活用形容動詞</td>
<td style="text-align: center;">静かだ</td>
<td style="text-align: center;">静かだろ</td>
<td style="text-align: center;">静かで／静かだっ／静かに</td>
<td style="text-align: center;">静かな</td>
<td style="text-align: center;">静かなら</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="even">
<td style="text-align: center;">助動詞</td>
<td style="text-align: center;">だ</td>
<td style="text-align: center;">だろ</td>
<td style="text-align: center;">で／だっ／（に）</td>
<td style="text-align: center;">（な）</td>
<td style="text-align: center;">なら</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="odd">
<td style="text-align: center;">助動詞</td>
<td style="text-align: center;">ようだ</td>
<td style="text-align: center;">ようだろ</td>
<td style="text-align: center;">ようで／ようだっ／ように</td>
<td style="text-align: center;">ような</td>
<td style="text-align: center;">ようなら</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="even">
<td style="text-align: center;">助動詞</td>
<td style="text-align: center;">そうだ「様態」</td>
<td style="text-align: center;">そうだろ</td>
<td style="text-align: center;">そうで／そうだっ／そうに</td>
<td style="text-align: center;">そうな</td>
<td style="text-align: center;">そうなら</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
</tbody>
</table>
<p>「べし」的活用类似于古语形容词。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">類型</th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">仮定形</th>
<th style="text-align: center;">命令形</th>
<th style="text-align: center;">意志形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">文語形容詞</td>
<td style="text-align: center;">高し</td>
<td style="text-align: center;">高から</td>
<td style="text-align: center;">高く</td>
<td style="text-align: center;">高き</td>
<td style="text-align: center;">高けれ</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="even">
<td style="text-align: center;">助動詞</td>
<td style="text-align: center;">べし</td>
<td style="text-align: center;">べから</td>
<td style="text-align: center;">べく</td>
<td style="text-align: center;">べき</td>
<td style="text-align: center;">べけれ</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
</tbody>
</table>
<p>其余助动词大多不具有多数的活用或者活用很不规则。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">類型</th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">仮定形</th>
<th style="text-align: center;">命令形</th>
<th style="text-align: center;">意志形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">助動詞</td>
<td style="text-align: center;">そうだ「伝聞」</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">そうで</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">そうなら</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="even">
<td style="text-align: center;">助動詞</td>
<td style="text-align: center;">です</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">でし</td>
<td style="text-align: center;">（です）</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">でしょ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">助動詞</td>
<td style="text-align: center;">ます</td>
<td style="text-align: center;">ませ</td>
<td style="text-align: center;">まし</td>
<td style="text-align: center;">ます</td>
<td style="text-align: center;">ますれ</td>
<td style="text-align: center;">まし／ませ</td>
<td style="text-align: center;">ましょ</td>
</tr>
<tr class="even">
<td style="text-align: center;">助動詞</td>
<td style="text-align: center;">う</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">（う）</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="odd">
<td style="text-align: center;">助動詞</td>
<td style="text-align: center;">た</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">た</td>
<td style="text-align: center;">たら</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">たろ</td>
</tr>
<tr class="even">
<td style="text-align: center;">助動詞</td>
<td style="text-align: center;">ぬ（ん）</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">ず</td>
<td style="text-align: center;">ぬ（ん）</td>
<td style="text-align: center;">ね</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
<tr class="odd">
<td style="text-align: center;">助動詞</td>
<td style="text-align: center;">まい</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">（まい）</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
</tbody>
</table>
<h2 id="现代日语用言活用的应用">现代日语用言活用的应用</h2>
<p>下述的用言包含动词、形容词、形容动词和助动词。另外，助动词中类似「れる、られる、せる、させる」等实际上可以认为是动词的一种，「たい、ない、らしい、べし」也可以认为是形容词的一种，「だ、ようだ、そうだ」则认为是形容动词的一种。我们把去掉上述提到的这些词后剩余的变形不规则的助动词称为<strong>（狭义）助动词</strong>，做出这样的区分是为了方便后续的讨论。</p>
<h3 id="用言终止形">用言终止形</h3>
<h4 id="直接终结句子">直接终结句子</h4>
<p>动词终止形一般用于终结一句话，但是不同种类用言的终止形被用来结句的常见程度有不同。一般而言，狭义助动词终止形用于结句相对多见，形容动词和形容动词型助动词终止形次之，形容词和形容词型助动词终止形又次，动词和动词型助动词终止形则较为少见。</p>
<p>考虑下述用狭义助动词终止形结句的例子，这些句子都是常见的教科书例句。</p>
<div class="note info no-icon"><p>わたしは今二十四歳，学生<strong>です</strong>。</p>
<p>わたしは毎日公園で散歩してい<strong>ます</strong>。</p>
<p>一緒に食事に行きましょ<strong>う</strong>。</p>
<p>この部屋に誰もいませ<strong>ん</strong>。</p>
</div>
<p>而形容动词或形容词终止形结句例句有这些，这些句子大多偏口语化。</p>
<div class="note info no-icon"><p>ほら見て，あの犬はめっちゃ<strong>可愛い</strong>。</p>
<p>昨夜睡眠不足だから，今眠くてとても寝<strong>たい</strong>。</p>
<p>そう言っても，わたし実は歌が<strong>上手だ</strong>。</p>
<p>ドアの鍵はまた忘れてしまうん<strong>だ</strong>。</p>
</div>
<p>而使用动词终止形结局，则显得较为直白，故这种用法相对上述较为少见。</p>
<div class="note info no-icon"><p>春になると，桜が<strong>咲く</strong>。</p>
</div>
<h4 id="接续助动词表意">接续助动词表意</h4>
<p>使用用言终止形接续的助动词包括：</p>
<ul>
<li>用言终止形接续表示传闻的「そうだ」</li>
<li>动词和形容词终止形接续「らしい」</li>
<li>动词终止形接续「べし」「まい」</li>
<li>形容词终止形接续「だ」「です」</li>
</ul>
<p>用言终止形接续表示传闻的「そうだ」，一般表示传闻：</p>
<div class="note info no-icon"><p>天気予報によると，明日は雨になる<strong>そうだ</strong>。</p>
<p>新聞によると，今年の冬は暖かい<strong>そうだ</strong>。</p>
</div>
<p>这两句话也就分别表示“根据天气预报，明天似乎要下雨”以及“根据报纸，今年冬天似乎会暖和”，这些都是根据传闻得到的推断的结果。</p>
<hr />
<p>动词和形容词终止形接续「らしい」（也可以使用体言原形接续）则可能有两种含义。其一表达当前描述对象具有某种事物的特征：</p>
<div class="note info no-icon"><p>学生なら，学生<strong>らしく</strong>勉強しなさい。</p>
<p>「自分<strong>らしく</strong>生きて」なんて言わないで，<strong>らしさ</strong>なんて最初からないから。</p>
</div>
<p>这里类似「学生らしい」这样的结构就表示“像学生那样”，即表示描述对象具有学生的特征。所以第一句话就表示“是学生的话就要像学生一样学习”，或者意译为“学生就要有学生学习的样”。第二句话则表示“不要说什么‘活出自我’，因为自我从一开始就不存在”，这里“活出自我”就是「自分らしく生きて」的意译。</p>
<p>其二则用于表达“根据外部信息得到的较为确切的推断”，这一点和表示传闻的「そうだ」有一定的类似之处：</p>
<div class="note info no-icon"><p>天気予報によると，明日は雨になる<strong>らしい</strong>。</p>
</div>
<p>这句话依然表示“根据天气预报，明天似乎要下雨”。</p>
<p>但是在表达通过其他类型的间接信息获取推断的时候，比如通过所见得到的信息获得推断的时候，就不能用表示传闻的「そうだ」，而更倾向于「らしい」：</p>
<div class="note info no-icon"><p>バスで田中さん<strong>らしい</strong>人を見かけました。</p>
<p>道が濡れていると言うことで，昨日雨が降った<strong>らしい</strong>。</p>
</div>
<p>「らしい」的特点是推断较为确信，所以有时也用于表示语气婉转的断定：</p>
<div class="note info no-icon"><p>どうやら事実<strong>らしい</strong>。</p>
<p>彼女は落選した<strong>らしい</strong>。</p>
</div>
<p>这两句实际上表达的是一种断定的语气，分别为“无论怎样都像事实”以及“她好像落选了”。</p>
<hr />
<p>「べし」为古语助动词，表示“应当”的语气：</p>
<div class="note info no-icon"><p>気づいたらもう一袋のお菓子を食べちゃった。食欲の秋，恐る<strong>べし</strong>。</p>
<p>静寂，流れる時間と守る<strong>べき</strong>何か。</p>
<p>なる<strong>べく</strong>永く一緒にいたいんだよ。</p>
</div>
<p>这里第一句「恐るべし」就表示“应当惧怕的”，意译为“可怕的”，所以一整句话的含义为“回过神来已经吃了一袋点心。食欲之秋，令人恐惧”。而第二句话则含义为“寂静，流逝的时间与应当守护的事物”。</p>
<p>这里第三句的「なるべく」目前已经成为固定表达，含义为“尽可能”，所以整句话含义为“想尽可能和你多在一起”。</p>
<hr />
<p>「まい」也是古语助动词，其表达否定的意志或者推测：</p>
<div class="note info no-icon"><p>ケーキを買う<strong>まい</strong>と思っても買ってしまった。</p>
<p>あの紛争は簡単に解決す<strong>まい</strong>と思うから，両方の努力は必要だ。</p>
</div>
<p>这两句中，第一句表达的是否定的意志，句子含义为“本不想买蛋糕的最后还是买了”。第二句话则表达否定的推断，含义为“那种纠纷我想不太能简单解决，所以两方的努力是必要的”。</p>
<hr />
<p>形容词终止形接续「だ」「です」则是先前提过的话题，这里不再赘述。</p>
<h3 id="用言连体形">用言连体形</h3>
<h4 id="用于修饰体言">用于修饰体言</h4>
<p>连体形顾名思义是接续体言的，其用途就是具体修饰一个名词具有的性质：</p>
<div class="note info no-icon"><p>明日の会議に<strong>使う書類</strong>。</p>
<p><strong>勉強する時</strong>に。</p>
</div>
<p>这个可以说是相当常用的一种用法了，不过这里要介绍几个东西，也就是<strong>形式体言</strong>，这种体言没有实际含义，但是可以辅助作为句子成分。形式体言往往是实际的体言退化得到的，虽然保留了原先体言的部分含义，但基本上已经固化成为固定搭配的一部分，用于构成表达固定含义的词组。</p>
<h5 id="形式体言事ことの">形式体言：事「こと」／の</h5>
<p>这是相当常见的形式体言，其汉字表示为「事」，常常用来接在连体后表达一种抽象的概念，常常构成类似「ことがある」「ことになる」「ことにする」「と言うことだ」这样的短语存在。</p>
<p>「の」也是相当常见的形式体言，但显然比较“轻量级”。</p>
<p>一般情况下，只是单纯完成动词名词化的时候，这两个形式体言是可以互换的：</p>
<div class="note info no-icon"><p>日本語を<strong>勉強すること</strong>は楽しいです。</p>
<p>日本語を<strong>勉強するの</strong>は楽しいです。</p>
</div>
<p>不过这两者之间存在一些小区别，这里首先说一下一般用「の」的情况。比如说如果名词化的动词是「みる」「聞こえる」等表示感知的动词的宾语的时候，或者比如说名词化的动词比较具像化的时候。</p>
<div class="note info no-icon"><p>あいつが本を<strong>読むの</strong>を聞こえます。</p>
<p>山田さんが<strong>来るの</strong>を待っています。</p>
</div>
<p>常常用「こと」的情况可能是接续的动词是「言う」「話す」「考える」「決める」等发言动词或决定性动词，也可以是直接接续「です」「だ」等动词，或者是构成了常用短语：</p>
<div class="note info no-icon"><p>アメリカに<strong>留学すること</strong>を考えている。</p>
<p>日本語を勉強し<strong>続くこと</strong>を決めました。</p>
<p>団長の仕事は団員を<strong>守ること</strong>だ。</p>
<p>今日からタバコを<strong>止めること</strong>にしました。</p>
</div>
<p>额外说明一点，有的时候「のです／のだ」也可以使用，但是在口语之中常常简化为「んです／んだ」。</p>
<hr />
<p>这里可能需要进一步说明的是包含有「こと」的一些常用短语，这些短语一般已经具有了固定的含义。</p>
<p>「ことがある」表示“这样的事件可能存在”：</p>
<div class="note info no-icon"><p>自分で料理を<strong>作ることがある</strong>。</p>
</div>
<p>「ことになる」表示“事态发展到了某一种状况，这种发展不是主观可控的”：</p>
<div class="note info no-icon"><p>学校のプールは六月一日から<strong>始まることになっ</strong>ている。</p>
</div>
<p>「ことにする」表示“下决心做什么事”：</p>
<div class="note info no-icon"><p>最後，彼はアメリカに<strong>留学することにし</strong>ました。</p>
</div>
<p>「ことには」有的时候用于表达一种强烈的情感和强调：</p>
<div class="note info no-icon"><p><strong>困ることには</strong>，今お金がないんです。</p>
</div>
<p>「ことができる」表示“有能力做到”：</p>
<div class="note info no-icon"><p>彼はこの歌を<strong>歌うことができ</strong>ます。</p>
</div>
<p>「ないことには」表示“如果不...就...”：</p>
<div class="note info no-icon"><p>やってみ<strong>ないことには</strong>，何もわからないです。</p>
</div>
<p>这句话就可以翻译为“不试试看的话，就什么都不知道了”。</p>
<p>「たことにする」表示“知道这件事，但是主观上不想重视”的意思：</p>
<div class="note info no-icon"><p>そんな話を聞こえなかっ<strong>たことにし</strong>よう。</p>
</div>
<p>这句话就可以翻译为“就当作没听见这样的话吧”。</p>
<p>「たことがある」表示“曾经有过这个经验”：</p>
<div class="note info no-icon"><p>横浜へ行っ<strong>たことがある</strong>よ。</p>
</div>
<p>这句话就可以翻译为“我曾去过横滨”。</p>
<h5 id="形式体言物もの">形式体言：物「もの」</h5>
<p>这种形式体言最为重要的应用就是表示“情理之中的行为”或者“真理”。</p>
<div class="note info no-icon"><p>太陽は東方から<strong>登るもの</strong>です。</p>
<p>そんなことを言わ<strong>ないもの</strong>です。</p>
</div>
<p>与「こと」类似，「もの」这个词也形成了如下所述的大量固定短语。</p>
<p>「たいものだ」表示“相当强的欲望”：</p>
<div class="note info no-icon"><p>世界各地を旅行し<strong>たいものだ</strong>。</p>
</div>
<p>「ものがある」表示相当强调的语气：</p>
<div class="note info no-icon"><p>あいつがやったことには，目に<strong>余るものがある</strong>。</p>
</div>
<p>「目に余る」表示“看不下去”，所以这句话的含义为“那家伙所做的事根本看不下去”。</p>
<p>「たものだ」表示“对过去经历的怀念”：</p>
<div class="note info no-icon"><p>これで君とよく遊びに来<strong>たものだ</strong>。</p>
</div>
<p>「もの／もので／ものだから」这三个词应用于表达原因，其语气一个比一个强烈。第一个含有一种轻微的因果感觉，而第三个则为相当强的因果关系：</p>
<div class="note info no-icon"><p>子供と<strong>いうもの</strong>，仕方ないですね。</p>
<p>あまり天気が<strong>いいもので</strong>，どこかへ遊びに行きたくなった。</p>
<p>雨が<strong>酷いものだから</strong>，どうしても出掛けたくない。</p>
</div>
<p>「ものなら」表示一种假设。如果接续表示可能的动词连体形，就表示“如果...的话，就...”，如果接续助动词「う」就表示“万一...的话，就...”：</p>
<div class="note info no-icon"><p><strong>できるものなら</strong>，やってみなさい。</p>
<p>失敗しよ<strong>うものなら</strong>，大目玉を食う。</p>
</div>
<p>「大目玉を食う」表示“受到严厉训斥”。这两句话分别表示“如果能做到的话，做做试试看吧”以及“万一失败了的话，就会被骂得很惨”。</p>
<p>「ものの」表示“虽然...但是...”：</p>
<div class="note info no-icon"><p>苦しいことは<strong>苦しいものの</strong>，楽しいこともあるんだ。</p>
</div>
<p>「ものを」是一个逆接的助词，表达转折含义：</p>
<div class="note info no-icon"><p>そんな上手に<strong>歌えるものを</strong>，なぜ歌わなかったのですか？</p>
</div>
<h5 id="形式体言所ところ">形式体言：所「ところ」</h5>
<p>这个体言最基本的含义就是“地点”或者“场所”，所以也可以表示虚化的“场合”：</p>
<div class="note info no-icon"><p>お<strong>忙しいところ</strong>をおいでくださいましてありがとうございました。</p>
</div>
<p>这里「おいで」是「来ること」等的尊敬语格式，这里可以理解为“出席”。这句话直译就是“能从繁忙的事务之中抽身出席，非常感谢”，也就是“感谢您百忙之中出席”。</p>
<p>这个体言也可以被引申后用来表示“某一点”或者“某一方面”：</p>
<div class="note info no-icon"><p>あなただって足りてい<strong>ないところ</strong>だらけ。</p>
<p>あなたの<strong>悪いところ</strong>はすぐ怒ることです。</p>
</div>
<p>同时也可以被引申为“范围”：</p>
<div class="note info no-icon"><p>私が知っているのは大体<strong>こんなところ</strong>です。</p>
</div>
<p>之后就是一些更为抽象的引申义。首先是表示程度，可以理解为“已经到了这个地步了”这样的意思：</p>
<div class="note info no-icon"><p>もう少しで車に引かれて<strong>しまうところ</strong>だった。</p>
</div>
<h5 id="形式体言訳わけ">形式体言：訳「わけ」</h5>
<h5 id="形式体言筈はず">形式体言：筈「はず」</h5>
<h5 id="形式体言為ため">形式体言：為「ため」</h5>
<h5 id="形式体言つもり">形式体言：つもり</h5>
<p>这个体言最基本的意义就是“计划、打算”。</p>
<div class="note info no-icon"><p>僕もタバコを<strong>やめるつもり</strong>だ。</p>
</div>
<p>另一方面，这个词语就可以表示主观意愿上的“估算、评价”（下述第一句），但有的时候会翻译为“自以为”（下述第二句），带有一定的贬义色彩：</p>
<div class="note info no-icon"><p><strong>君のつもり</strong>では，どれほど費用がかかるんだか？</p>
<p>あの人は自分が<strong>有能なつもり</strong>だが，彼の仕事ぶりに対する周囲の評価は低い。</p>
</div>
<p>另外一种是表示假设，翻译为“就当作”。但一般形成短语「たつもり」：</p>
<div class="note info no-icon"><p>先生になっ<strong>たつもり</strong>で，みんなに説明しよう。</p>
</div>
<p>另外说一下这个体言的否定，「〜ないつもり」表示“不打算这么做”，「〜つもりはない」则根本上否定，表示“完全不打算”：</p>
<div class="note info no-icon"><p>進学し<strong>ないつもり</strong>だ。</p>
<p>率直的にいう，俺は<strong>進学するつもりはない</strong>んだ。</p>
</div>
<h5 id="形式体言方ほう">形式体言：方「ほう」</h5>
<p>这个词一般被运用在比较句之中，用来形成比较的语气：</p>
<div class="note info no-icon"><p><strong>あちらの方</strong>はデザインがいいんだ。</p>
</div>
<h5 id="形式体言儘まま">形式体言：儘「まま」</h5>
<p>这个词核心意思就是“保持某一种状态不变”：</p>
<div class="note info no-icon"><p><strong>そのまま</strong>でいいでしょう？</p>
<p>前に<strong>向こうまま</strong>歩いている。</p>
<p>自分の<strong>意のまま</strong>にいこう。</p>
</div>
<p>第一句表示“就这样下去也不错吧？”，而第二句意思为“一直向前走”，第三句意思为“随着自己的意思行动”。这三句话都蕴含着“保持一种状态不变”或者“跟随某一种状态不变”的含义。而如果表明的是“跟随自己的意见”，这个词可以酌情翻译为“任性”，并且这个时候常常带有些许贬义。比如说常见的形容动词「わがままだ」。</p>
<h5 id="形式体言通とおり">形式体言：通「とお」り</h5>
<p>这个词核心意思为“按照”或者“正如”：</p>
<div class="note info no-icon"><p>教え<strong>た通り</strong>にやってみよう。</p>
<p><strong>ご覧の通り</strong>なんでもない。</p>
</div>
<p>这两句话的意思就是“按着刚刚教的做做试试看吧”以及“正如您所见，什么都没有”。</p>
<h5 id="形式体言上うえ">形式体言：上「うえ」</h5>
<p>首先这个词有个非常直观的意思，就是“...上”，用来表示一个方面：</p>
<div class="note info no-icon"><p><strong>仕事の上</strong>で問題はない。</p>
</div>
<p>这句话很简单的翻译为“工作上没有问题”。</p>
<p>另外，这个词还可以表示“添加评注”，也就是添加一段对某个人或物性质的描述：</p>
<div class="note info no-icon"><p>このカメラはよく<strong>映る上</strong>に，値段がやすいです。</p>
</div>
<p>这句话直接翻译的话就是“这个照相机除了拍照片很好，还很便宜”。</p>
<p>另外，如果用「た」接续，就表明“在...之后再...”：</p>
<div class="note info no-icon"><p>お目にかかっ<strong>た上</strong>で決めましょう。</p>
</div>
<p>这里「お目にかかる」表示“会面”，所以这句话意思为“见面之后再决定吧”。</p>
<p>还有一种意思表示“既然...那么...”：</p>
<div class="note info no-icon"><p>事実はそうであっ<strong>た上</strong>で，仕方はないでしょう？</p>
</div>
<h5 id="形式体言うち">形式体言：うち</h5>
<p>这个词的核心意思就是“范围”：</p>
<div class="note info no-icon"><p><strong>三人のうち</strong>で誰が一番年長ですか？</p>
</div>
<p>这句话可以简单翻译为“这三个人（的范围）里面，谁年龄最大？”</p>
<h5 id="形式体言元もと">形式体言：元「もと」</h5>
<p>这个词核心的意思就是“范围”，进而引申出“在...之下”的含义：</p>
<div class="note info no-icon"><p><strong>親のもと</strong>を離れる。</p>
<p>先生の<strong>指導のもと</strong>で研究を続ける。</p>
</div>
<p>第一句话直接翻译就是“离开了父母的范围”，意思就是“与父母分离”。第二句话使用了引申义，意思是“在老师的指导之下，研究得以继续”。</p>
<h5 id="形式体言限かぎり">形式体言：限「かぎ」り</h5>
<p>这个词最简单的含义就是表示“极限”。但是作为形式体言，其可以构成“只要...就...”的句式：</p>
<div class="note info no-icon"><p>このうるさい音が<strong>続く限り</strong>，私は眠れない。</p>
</div>
<p>这句话就表示“只要那烦人的声音还在响，我就睡不着”。</p>
<p>当然，这个词如果接续在否定的「ない」后面，就表达“除非...就不...”，这实际上就是上面的“只要...就...”的否定：</p>
<div class="note info no-icon"><p>病気が<strong>ない限り</strong>学校を休まない。</p>
</div>
<p>这句话就可以翻译为“只要没生病就不能请假”。</p>
<h5 id="形式体言代かわりに">形式体言：代「か」わりに</h5>
<p>这个词可以作为实际含义的词，表示“代替”：</p>
<div class="note info no-icon"><p>私の<strong>母の代わりに</strong>，ご挨拶します。</p>
</div>
<p>但是其作为形式体言，有一个作用就是构成“虽然...但也...”的句式：</p>
<div class="note info no-icon"><p>スポーツがあまり上手では<strong>ない代わりに</strong>，大病もしたことがない。</p>
</div>
<p>这句话就被翻译为“虽然我运动不是很好，但是也从未生过大病”。</p>
<p>同时，这个形式体言也可以表示两者之间的一个交换条件：</p>
<div class="note info no-icon"><p>英語を教えて<strong>もらう代わりに</strong>，日本語を教えてあげます。</p>
</div>
<p>这句话可以形象翻译为“你来教我英语，作为交换，我教你日语”，实际上就是表明两个行为是一种交换的行为。</p>
<h5 id="形式体言次第しだい">形式体言：次第「しだい」</h5>
<p>这个词本质上也是一个实质体言，意思为“次序”，但是其作为形式体言就表示“全凭，全靠”的意思：</p>
<div class="note info no-icon"><p>全ては君の<strong>決心の次第</strong>です。</p>
</div>
<p>这句话意为“这全靠你的决心”。</p>
<h5 id="形式体言癖くせに">形式体言：癖「くせ」に</h5>
<p>这个词附加在动词上往往表达一种不满的、责备的语气，一般含有“明明怎么样，却怎么样”的感觉：</p>
<div class="note info no-icon"><p>お前は知って<strong>いるくせに</strong>，なんで私に教えてくれなかったの？</p>
<p>あいつはバスケットボールが<strong>下手なくせに</strong>，選手になりたいなんて夢を見ている。</p>
</div>
<p>这两句话可以根据语气分别翻译为“你明明知道，为什么不告诉我”以及“他篮球明明打得不好，却还想做当运动员的梦”。</p>
<h2 id="不视作活用的变形">不视作活用的变形</h2>
<p>在现代日语中，我们有时还是能看到一些比较规律的变形。比如说形容词词尾变为「さ、み、め」似乎就可以变为名词，某些自动词和他动词存在较为规则的对应关系等等。</p>
<h2 id="现代日语常用助词和简介">现代日语常用助词和简介</h2>
<p>助词和助动词的差别在于，助词一般不具有活用。日语中的助词相当庞杂，含义也各异，和用言的接续方式更是杂乱，且在实际使用中也可能是不完全严谨的。所以我们将其脱离用言变形的体系独立进行讲解。</p>
]]></content>
      <categories>
        <category>日语</category>
      </categories>
  </entry>
  <entry>
    <title>日语单词变形手册</title>
    <url>/2021/06/18/ja-1/</url>
    <content><![CDATA[<p>这是一个相当长的文档，几乎可以说记录了我对日语单词变形能想到的一切。即使日语有的时候和中文很相似，但是它作为黏着语还是让它的语法成为了汉语母语者学习的巨大障碍。</p>
<p>这个文档随时更新，欢迎大家关注。</p>
<span id="more"></span>
<p>首先说一下这个文档整理的原则。由于日语的词汇可以很灵活地变形，比如「書く」先变成第一连用形后接续「たい」形成类似形容词的「書きたい」，之后再按照形容词过去否定的规则变为「書きたくなかった」后，在按照连体形规则接上助动词「ので」变成「書きたくなかったので」。在这样的背景下，本文档不可能穷尽所有的变形以及这种变形的所有应用方式，不过本文档会这样表述：“这样变形之后，词汇将类似于形容词”。这样的话后续进行第二次变形的时候就可以在形容词栏目之下进行寻找。</p>
<h1 id="日语动词的变形">日语动词的变形</h1>
<p>在介绍变形之前，我们要首先介绍日语动词的分类。日语动词按照活用类型可以分为四类：</p>
<ul>
<li>五段动词</li>
</ul>
<p>形式为词干加上某一个ウ段假名构成，比如「書く、読む、話す」。</p>
<ul>
<li>一段动词</li>
</ul>
<p>形式一般为一个イ段假名或者エ段假名结尾的词干加上「る」构成，比如「食べる、教える、起きる」。</p>
<p>有一些细化为上一段动词和下一段动词的说法，这里可以简单理解为以イ段假名接续的是上一段动词，以エ段假名接续的是下一段动词。</p>
<ul>
<li>サ变动词</li>
</ul>
<p>形式为「する」或者某一个词干加上「する」，同时也有一些以「ずる」结尾的动词也是サ变动词。比如「する、勉強する、散歩する、感ずる、禁ずる」。</p>
<ul>
<li>カ变动词</li>
</ul>
<p>只有「来る」是カ变动词。</p>
<h2 id="原形辞书形连体形">原形/辞书形/连体形</h2>
<p>这种形式就是字典上表示动词的形式，所以称为“原形”或者“辞书形”。其用途也是较为多的。</p>
<h3 id="用于终结一句话">用于终结一句话</h3>
<p>动词原形可以直接用于终结一个句子，提示动作：</p>
<div class="note info no-icon"><p>今朝，朝ごはんを<strong>食べる</strong>。 そこで<strong>立つ</strong>。</p>
</div>
<p>但是用原形终结一句话有的时候会给人一种语气直接了当的感觉，现实对话之中也较少使用原形直接终结句子。</p>
<h3 id="用于修饰体言">用于修饰体言</h3>
<p>实际上，动词原形同时也是连体形。连体形顾名思义是接续体言的，其用途就是具体修饰一个名词具有的性质：</p>
<div class="note info no-icon"><p>明日の会議に<strong>使う書類</strong>。 <strong>勉強する時</strong>に。</p>
</div>
<p>这个可以说是相当常用的一种用法了，不过这里要介绍几个东西，也就是<strong>形式体言</strong>，这种体言没有实际含义，但是可以辅助作为句子成分。</p>
<h4 id="形式体言事ことの">形式体言：事「こと」／の</h4>
<p>这是相当常见的形式体言，其汉字表示为「事」，常常用来接在连体后表达一种抽象的概念，常常构成类似「ことがある」「ことになる」「ことにする」「と言うことだ」这样的短语存在。</p>
<p>「の」也是相当常见的形式体言，但显然比较“轻量级”。</p>
<p>一般情况下，只是单纯完成动词名词化的时候，这两个形式体言是可以互换的：</p>
<div class="note info no-icon"><p>日本語を<strong>勉強すること</strong>は楽しいです。 日本語を<strong>勉強するの</strong>は楽しいです。</p>
</div>
<p>不过这两者之间存在一些小区别，这里首先说一下一般用「の」的情况。比如说如果名词化的动词是「みる」「聞こえる」等表示感知的动词的宾语的时候，或者比如说名词化的动词比较具像化的时候。</p>
<div class="note info no-icon"><p>あいつが本を<strong>読むの</strong>を聞こえます。 山田さんが<strong>来るの</strong>を待っています。</p>
</div>
<p>常常用「こと」的情况可能是接续的动词是「言う」「話す」「考える」「決める」等发言动词或决定性动词，也可以是直接接续「です」「だ」等动词，或者是构成了常用短语：</p>
<div class="note info no-icon"><p>アメリカに<strong>留学すること</strong>を考えている。 日本語を<strong>勉強し続くこと</strong>を決めました。 団長の仕事は団員を<strong>守ること</strong>だ。 今日からタバコを<strong>止めること</strong>にしました。</p>
</div>
<p>额外说明一点，有的时候「のです／のだ」也可以使用，但是在口语之中常常简化为「んです／んだ」。</p>
<p>这里可能需要进一步说明的是包含有「こと」的一些常用短语，这些短语一般已经具有了独特的含义了。</p>
<p>「ことがある」表示“这样的事件可能存在”：</p>
<div class="note info no-icon"><p>自分で料理を<strong>作ることがある</strong>。</p>
</div>
<p>「ことになる」表示“事态发展到了某一种状况，这种发展不是主观可控的”：</p>
<div class="note info no-icon"><p>学校のプールは六月一日から<strong>始まることになっ</strong>ている。</p>
</div>
<p>「ことにする」表示“下决心做什么事”：</p>
<div class="note info no-icon"><p>最後，彼はアメリカに<strong>留学することにし</strong>ました。</p>
</div>
<p>「ことには」有的时候用于表达一种强烈的情感和强调：</p>
<div class="note info no-icon"><p><strong>困「こま」ることには</strong>，今お金がないんです。</p>
</div>
<p>「ことができる」表示“有能力做到”：</p>
<div class="note info no-icon"><p>彼はこの歌を<strong>歌うことができ</strong>ます。</p>
</div>
<p>这里我们发现接续「こと」的全都是原形，但很多时候还可以使用第二连用形加「た／だ」之后接续「こと」，或者使用未然形加上「ない」之后接续「こと」，并且这些时候意思会产生一些微妙的变化。</p>
<div class="note default"><p><strong>注解：</strong>从这里开始，形式体言部分会涉及到许多不是原形进行接续的场合，但这些东西不会拆分到对应的条目（比如第二连用形加「た／だ」之后接续就不会放到第二连用形部分），这是因为形容词或者第二连用形加「た／だ」之后接续体言是相当自然的事情，故不如只设定一个条目统一管理。在第二连用形部分以及形容词部分会设置跳转提示，提示形式体言均放在此处记录。</p>
</div>
<p>「ないことには」表示“如果不...就...”：</p>
<div class="note info no-icon"><p>やって<strong>みないことには</strong>，何もわからないです。</p>
</div>
<p>这句话就可以翻译为“不试试看的话，就什么都不知道了”。</p>
<p>「たことにする」表示“知道这件事，但是主观上不想重视”的意思：</p>
<div class="note info no-icon"><p>そんな話を<strong>聞こえなかったことにし</strong>よう。</p>
</div>
<p>这句话就可以翻译为“就当作没听见这样的话吧”。</p>
<p>「たことがある」表示“曾经有过这个经验”：</p>
<div class="note info no-icon"><p>横浜へ<strong>行ったことがある</strong>よ。</p>
</div>
<p>这句话就可以翻译为“我曾去过横滨”。</p>
<h4 id="形式体言物もの">形式体言：物「もの」</h4>
<p>这种形式体言最为重要的应用就是表示“情理之中的行为”或者“真理”。补充说明一下，这里也可以使用未然形加上「ない」之后接续：</p>
<div class="note info no-icon"><p>太陽は東方から<strong>登るもの</strong>です。 そんなことを<strong>言わないもの</strong>です。</p>
</div>
<p>与「こと」类似，「もの」这个词的灵魂在于大量的短语以及固定表达，这里直接介绍。</p>
<p>「たいものだ」表示“相当强的欲望”：</p>
<div class="note info no-icon"><p>世界各地を<strong>旅行したいものだ</strong>。</p>
</div>
<p>「ものがある」表示相当强调的语气：</p>
<div class="note info no-icon"><p>あいつがやったことには，目に<strong>余るものがある</strong>。</p>
</div>
<p>「目に余る」表示“看不下去”，所以这句话就是说“那家伙所做的事根本看不下去”。</p>
<p>「たものだ」表示“对过去经历的怀念”：</p>
<div class="note info no-icon"><p>これで君とよく遊びに<strong>来たものだ</strong>。</p>
</div>
<p>「もの／もので／ものだから」这三个词应用于表达原因，其语气是一个比一个强烈。第一个含有一种轻微的因果感觉，而第三个就是相当强的因果关系：</p>
<div class="note info no-icon"><p><strong>子供というもの</strong>，仕方ないですね。 あまり天気が<strong>いいもので</strong>，どこかへ遊びに行きたくなった。 雨が<strong>酷いものだから</strong>，どうしても出掛けたくない。</p>
</div>
<p>「ものなら」表示一种假设。如果接续在表示可能的动词原形后面，就表示“如果...的话，就...”，如果接续在助动词「よう／う」后面就表示“万一...的话，就...”：</p>
<div class="note info no-icon"><p><strong>できるものなら</strong>，やってみなさい。 <strong>失敗しようものなら</strong>，大目玉を食う。</p>
</div>
<p>「大目玉を食う」表示“受到严厉训斥”。这两句话分别表示“如果能做到的话，做做试试看吧”以及“万一失败了的话，就会被骂得很惨”。</p>
<p>「ものの」表示“虽然...但是...”：</p>
<div class="note info no-icon"><p>苦しいことは<strong>苦しいものの</strong>，楽しいこともあるんだ。</p>
</div>
<p>「ものを」是一个逆接的助词，表达转折含义：</p>
<div class="note info no-icon"><p>そんな上手に<strong>歌えるものを</strong>，なぜ歌わなかったのですか？</p>
</div>
<h4 id="形式体言所ところ">形式体言：所「ところ」</h4>
<p>这个体言最基本的含义就是“地点”或者“场所”，所以也可以表示虚化的“场合”：</p>
<div class="note info no-icon"><p>お<strong>忙しいところ</strong>をおいでくださいましてありがとうございました。</p>
</div>
<p>这里「おいで」是「来ること」等的尊敬语格式，这里可以理解为“出席”。这句话直译就是“能从繁忙的事务之中抽身出席，非常感谢”，也就是“感谢您百忙之中出席”。</p>
<p>这个体言也可以被引申后用来表示“某一点”或者“某一方面”：</p>
<div class="note info no-icon"><p>あなただって足りて<strong>いないところ</strong>だらけ。 あなたの<strong>悪いところ</strong>はすぐ怒ることです。</p>
</div>
<p>同时也可以被引申为“范围”：</p>
<div class="note info no-icon"><p>私が知っているのは大体<strong>こんなところ</strong>です。</p>
</div>
<p>之后就是一些更为抽象的引申义。首先是表示程度，可以理解为“已经到了这个地步了”这样的意思：</p>
<div class="note info no-icon"><p>もう少しで車に引かれて<strong>しまうところ</strong>だった。</p>
</div>
<h4 id="形式体言訳わけ">形式体言：訳「わけ」</h4>
<h4 id="形式体言筈はず">形式体言：筈「はず」</h4>
<h4 id="形式体言為ため">形式体言：為「ため」</h4>
<h4 id="形式体言つもり">形式体言：つもり</h4>
<p>这个体言最基本的意义就是“计划、打算”。</p>
<div class="note info no-icon"><p>僕もタバコを<strong>やめるつもり</strong>だ。</p>
</div>
<p>另一方面，这个词语就可以表示主观意愿上的“估算、评价”（下述第一句），但有的时候会翻译为“自以为”（下述第二句），带有一定的贬义色彩：</p>
<div class="note info no-icon"><p><strong>君のつもり</strong>では，どれほど費用がかかるんだか？ あの人は自分が<strong>有能なつもり</strong>だが，彼の仕事ぶりに対する周囲の評価は低い。</p>
</div>
<p>另外一种是表示假设，翻译为“就当作”。但一般形成短语「たつもり」：</p>
<div class="note info no-icon"><p>先生に<strong>なったつもり</strong>で，みんなに説明しよう。</p>
</div>
<p>另外说一下这个体言的否定，「〜ないつもり」表示“不打算这么做”，「〜つもりはない」则根本上否定，表示“完全不打算”：</p>
<div class="note info no-icon"><p><strong>進学しないつもり</strong>だ。 率直的「そっちょくてき」にいう，俺は<strong>進学するつもりはない</strong>んだ。</p>
</div>
<h4 id="形式体言方ほう">形式体言：方「ほう」</h4>
<p>这个词一般被运用在比较句之中，用来形成比较的语气：</p>
<div class="note info no-icon"><p><strong>あちらの方</strong>はデザインがいいんだ。</p>
</div>
<h4 id="形式体言儘まま">形式体言：儘「まま」</h4>
<p>这个词核心意思就是“保持某一种状态不变”：</p>
<div class="note info no-icon"><p><strong>そのまま</strong>でいいでしょう？ 前に<strong>向こうまま</strong>歩いている。 自分の<strong>意のまま</strong>にいこう。</p>
</div>
<p>第一句表示“就这样下去也不错吧？”，而第二句意思为“一直向前走”，第三句意思为“随着自己的意思行动”。这三句话都蕴含着“保持一种状态不变”或者“跟随某一种状态不变”的含义。而如果表明的是“跟随自己的意见”，这个词可以酌情翻译为“任性”，并且这个时候常常带有些许贬义。比如说常见的形容动词「わがままだ」。</p>
<h4 id="形式体言通とおり">形式体言：通「とお」り</h4>
<p>这个词核心意思为“按照”或者“正如”：</p>
<div class="note info no-icon"><p><strong>教えた通り</strong>にやってみよう。 <strong>ご覧の通り</strong>なんでもない。</p>
</div>
<p>这两句话的意思就是“按着刚刚教的做做试试看吧”以及“正如您所见，什么都没有”。</p>
<h4 id="形式体言上うえ">形式体言：上「うえ」</h4>
<p>首先这个词有个非常直观的意思，就是“...上”，用来表示一个方面：</p>
<div class="note info no-icon"><p><strong>仕事の上</strong>で問題はない。</p>
</div>
<p>这句话很简单的翻译为“工作上没有问题”。</p>
<p>另外，这个词还可以表示“添加评注”，也就是添加一段对某个人或物性质的描述：</p>
<div class="note info no-icon"><p>このカメラはよく<strong>映る上</strong>に，値段がやすいです。</p>
</div>
<p>这句话直接翻译的话就是“这个照相机除了拍照片很好，还很便宜”。</p>
<p>另外，如果用「た」接续，就表明“在...之后再...”：</p>
<div class="note info no-icon"><p>お目に<strong>かかった上</strong>で決めましょう。</p>
</div>
<p>这里「お目にかかる」表示“会面”，所以这句话意思为“见面之后再决定吧”。</p>
<p>还有一种意思表示“既然...那么...”：</p>
<div class="note info no-icon"><p>事実はそうで<strong>あった上</strong>で，仕方はないでしょう？</p>
</div>
<h4 id="形式体言うち">形式体言：うち</h4>
<p>这个词的核心意思就是“范围”：</p>
<div class="note info no-icon"><p><strong>三人のうち</strong>で誰が一番年長ですか？</p>
</div>
<p>这句话可以简单翻译为“这三个人（的范围）里面，谁年龄最大？”</p>
<h4 id="形式体言元もと">形式体言：元「もと」</h4>
<p>这个词核心的意思就是“范围”，进而引申出“在...之下”的含义：</p>
<div class="note info no-icon"><p><strong>親のもと</strong>を離れる。 先生の<strong>指導のもと</strong>で研究を続ける。</p>
</div>
<p>第一句话直接翻译就是“离开了父母的范围”，意思就是“与父母分离”。第二句话使用了引申义，意思是“在老师的指导之下，研究得以继续”。</p>
<h4 id="形式体言限かぎり">形式体言：限「かぎ」り</h4>
<p>这个词最简单的含义就是表示“极限”。但是作为形式体言，其可以构成“只要...就...”的句式：</p>
<div class="note info no-icon"><p>このうるさい音が<strong>続く限り</strong>，私は眠れない。</p>
</div>
<p>这句话就表示“只要那烦人的声音还在响，我就睡不着”。</p>
<p>当然，这个词如果接续在否定的「ない」后面，就表达“除非...就不...”，这实际上就是上面的“只要...就...”的否定：</p>
<div class="note info no-icon"><p>病気が<strong>ない限り</strong>学校を休まない。</p>
</div>
<p>这句话就可以翻译为“只要没生病就不能请假”。</p>
<h4 id="形式体言代かわりに">形式体言：代「か」わりに</h4>
<p>这个词可以作为实际含义的词，表示“代替”：</p>
<div class="note info no-icon"><p>私の<strong>母の代わりに</strong>，ご挨拶します。</p>
</div>
<p>但是其作为形式体言，有一个作用就是构成“虽然...但也...”的句式：</p>
<div class="note info no-icon"><p>スポーツがあまり上手では<strong>ない代わりに</strong>，大病もしたことがない。</p>
</div>
<p>这句话就被翻译为“虽然我运动不是很好，但是也从未生过大病”。</p>
<p>同时，这个形式体言也可以表示两者之间的一个交换条件：</p>
<div class="note info no-icon"><p>英語を教えて<strong>もらう代わりに</strong>，日本語を教えてあげます。</p>
</div>
<p>这句话可以形象翻译为“你来教我英语，作为交换，我教你日语”，实际上就是表明两个行为是一种交换的行为。</p>
<h4 id="形式体言次第しだい">形式体言：次第「しだい」</h4>
<p>这个词本质上也是一个实质体言，意思为“次序”，但是其作为形式体言有两种意思。如果接在连用形后面，就表示“全凭，全靠”的意思，如果接在第一连用形后面，就表示“一...就...”的意思：</p>
<div class="note info no-icon"><p>全ては君の<strong>決心の次第</strong>です。 <strong>出来次第</strong>，お届けいたします。</p>
</div>
<p>这里「出来次第」可能一下子看不出来，实际上就是动词「できる」的第一连用形「出来」加上「次第」的形式。这两句话意为“这全靠你的决心”以及“一旦做出来就给您送过去”。</p>
<h4 id="形式体言癖くせに">形式体言：癖「くせ」に</h4>
<p>这个词附加在动词上往往表达一种不满的、责备的语气，一般含有“明明怎么样，却怎么样”的感觉：</p>
<div class="note info no-icon"><p>お前は知って<strong>いるくせに</strong>，なんで私に教えてくれなかったの？ あいつはバスケットボールが<strong>下手なくせに</strong>，選手になりたいなんて夢を見ている。</p>
</div>
<p>这两句话可以根据语气分别翻译为“你明明知道，为什么不告诉我”以及“他篮球明明打得不好，却还想做当运动员的梦”。</p>
<h3 id="接续助词辅助表意">接续助词辅助表意</h3>
<p>另外，还可以接续一些助词，比如说表达客观原因的「ので」。</p>
<div class="note info no-icon"><p>横浜へ行ったことがあるよ。</p>
</div>
<h2 id="第一连用形">第一连用形</h2>
<p>首先我们给出第一连用形的变形规则：</p>
<ul>
<li><p>五段动词将词尾ウ段假名改为イ段假名</p></li>
<li><p>一段动词将词尾「る」删去</p></li>
<li><p>サ变动词删去词尾「する／ずる」加上「し／じ」</p></li>
<li><p>カ变动词变为「き」</p></li>
</ul>
<p>这里直接给出变形例子：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">動詞類型</th>
<th style="text-align: center;">原形／辞書形</th>
<th style="text-align: center;">語幹／第一連用形</th>
<th style="text-align: center;">第一連用形＋ます</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">五段動詞「く」</td>
<td style="text-align: center;">書く</td>
<td style="text-align: center;">書き</td>
<td style="text-align: center;">書きます</td>
</tr>
<tr class="even">
<td style="text-align: center;">五段動詞「ぐ」</td>
<td style="text-align: center;">泳ぐ</td>
<td style="text-align: center;">泳ぎ</td>
<td style="text-align: center;">泳ぎます</td>
</tr>
<tr class="odd">
<td style="text-align: center;">五段動詞「す」</td>
<td style="text-align: center;">話す</td>
<td style="text-align: center;">話し</td>
<td style="text-align: center;">話します</td>
</tr>
<tr class="even">
<td style="text-align: center;">五段動詞「つ」</td>
<td style="text-align: center;">立つ</td>
<td style="text-align: center;">立ち</td>
<td style="text-align: center;">立ちます</td>
</tr>
<tr class="odd">
<td style="text-align: center;">五段動詞「ぬ」</td>
<td style="text-align: center;">死ぬ</td>
<td style="text-align: center;">死に</td>
<td style="text-align: center;">死にます</td>
</tr>
<tr class="even">
<td style="text-align: center;">五段動詞「ぶ」</td>
<td style="text-align: center;">飛ぶ</td>
<td style="text-align: center;">飛び</td>
<td style="text-align: center;">飛びます</td>
</tr>
<tr class="odd">
<td style="text-align: center;">五段動詞「む」</td>
<td style="text-align: center;">読む</td>
<td style="text-align: center;">読み</td>
<td style="text-align: center;">読みます</td>
</tr>
<tr class="even">
<td style="text-align: center;">五段動詞「る」</td>
<td style="text-align: center;">降る</td>
<td style="text-align: center;">降り</td>
<td style="text-align: center;">降ります</td>
</tr>
<tr class="odd">
<td style="text-align: center;">五段動詞「う」</td>
<td style="text-align: center;">歌う</td>
<td style="text-align: center;">歌い</td>
<td style="text-align: center;">歌います</td>
</tr>
<tr class="even">
<td style="text-align: center;">上一段動詞</td>
<td style="text-align: center;">起きる</td>
<td style="text-align: center;">起き</td>
<td style="text-align: center;">起きます</td>
</tr>
<tr class="odd">
<td style="text-align: center;">下一段動詞</td>
<td style="text-align: center;">教える</td>
<td style="text-align: center;">教え</td>
<td style="text-align: center;">教えます</td>
</tr>
<tr class="even">
<td style="text-align: center;">サ変動詞「基本」</td>
<td style="text-align: center;">する</td>
<td style="text-align: center;">し</td>
<td style="text-align: center;">します</td>
</tr>
<tr class="odd">
<td style="text-align: center;">サ変動詞「語幹ある」</td>
<td style="text-align: center;">勉強する</td>
<td style="text-align: center;">勉強し</td>
<td style="text-align: center;">勉強します</td>
</tr>
<tr class="even">
<td style="text-align: center;">サ変動詞「濁点ある」</td>
<td style="text-align: center;">感ずる</td>
<td style="text-align: center;">感じ</td>
<td style="text-align: center;">感じます</td>
</tr>
<tr class="odd">
<td style="text-align: center;">カ変動詞</td>
<td style="text-align: center;">くる</td>
<td style="text-align: center;">き</td>
<td style="text-align: center;">きます</td>
</tr>
</tbody>
</table>
<p>之后我们就可以介绍第一连用形的用途了。</p>
<h3 id="接续助词辅助表意-1">接续助词辅助表意</h3>
<h4 id="助动词ます">助动词ます</h4>
<p>「ます」在一定程度上是一种很常用的助动词，常常用来表示一种稍稍表敬意的语气。</p>
<p>「ます」在一定意义上也具有各种的变形来表达各种含义（毕竟原本的动词为了接续「ます」只能变为第一连用形，从而就不能再变形来表达含义了）。</p>
<ul>
<li>基本形「ます」</li>
</ul>
<p>最为基本的用法，不做介绍。</p>
<ul>
<li>未然形「ませ」</li>
</ul>
<p>接续「ん／ぬ」表示否定。不过要注意，接续「ぬ」已经是比较古老的用法，现今基本不使用。</p>
<div class="note info no-icon"><p>私はお茶を飲み<strong>ません</strong>。 そんなことを知り<strong>ませぬ</strong>。</p>
</div>
<ul>
<li>连用形「まし」</li>
</ul>
<p>接续「て」表示停顿或者接续「た」表达过去。</p>
<div class="note info no-icon"><p>昨日は新聞を読み<strong>ました</strong>。 昨日は雑誌を読み<strong>ませんでした</strong>。 初め<strong>まして</strong>。</p>
</div>
<p>这里稍微说说「ませんでした」这样的形式是怎么样构成的。因为日语构建过去否定都是先否定再过去，在形容词上面就已经有较多体现：</p>
<p>暑い　<span class="math inline">\(\Rightarrow\)</span>　暑くない　<span class="math inline">\(\Rightarrow\)</span>　暑くなかった</p>
<p>那么我们对「ます」的否定形式「ません」该如何处理呢？它不是用言，我们必须用助动词修饰之后才能进行过去化：</p>
<p>ません　<span class="math inline">\(\Rightarrow\)</span>　ませんです　<span class="math inline">\(\Rightarrow\)</span>　ませんでした</p>
<p>这里的「ませんです」只是一个变形中间体，不具有任何语言用途，不能在实际用语中出现。</p>
<ul>
<li>终止形「ます」</li>
</ul>
<p>终结句子用，没有实际含义。</p>
<ul>
<li>推量形「ましょ」</li>
</ul>
<p>接续「う」表示劝说、意见或者推论。</p>
<div class="note info no-icon"><p>今夜，一緒に食事をし<strong>ましょう</strong>。</p>
</div>
<h4 id="助动词たいたがる">助动词たい／たがる</h4>
<p>「たい／たがる」是表达欲望的助动词，其中第一人称常用「たい」，而其他人称常用「たがる」。不过要注意的是使用「たい」之后，其行为类似于形容词，而「たがる」行为类似于动词。</p>
<div class="note info no-icon"><p>私はお菓子を<strong>食べたい</strong>です。 今何も<strong>したくない</strong>です。 昨日は買い物<strong>したかった</strong>。 昨夜は宿題を<strong>やりたくなかった</strong>。 <strong>遊びたければ</strong>，一緒にいこう。 うちの子は，いつもケーキを<strong>食べたがる</strong>のよ。</p>
</div>
<p>不过要注意的一点是，「たがる」是用来推测别人的愿望的，是蕴涵着自上而下审视的语气的。比如说上面的例句，实际上有一种“孩子爱吃蛋糕，别给吃胖了”或者“吃这么多，多费钱啊”这样的隐含负面语气，所以尽量少使用。</p>
<h4 id="助动词ながらつつ">助动词ながら／つつ</h4>
<p>「ながら」最为基本的意思是“一边”或者“同时”。如果要描述某个人一边如何一边如何，就可以用这个助词：</p>
<div class="note info no-icon"><p>山を<strong>登りながら</strong>，こう思った。</p>
</div>
<p>但是这个词有的时候会表达一种很轻微的转折，在一定程度上可以酌情表达为“但是”：</p>
<div class="note info no-icon"><p>我が国の労働者は仕事を<strong>しながら</strong>，勉強もできる。</p>
</div>
<p>这句话可以理解为“劳动者一边工作一边学习”，但是实际上如果语气适当，会表现出一种“我国劳动者会工作，但是也可以一边学习”种种带有转折含义的语气。</p>
<p>「つつ」有的时候也可以表达这种“一边”或者“同时”的含义，比如说：</p>
<div class="note info no-icon"><p>帰りのバスで外の景色を<strong>眺めつつ</strong>，明日の仕事を考えていた。</p>
</div>
<p>但是这个词似乎在更多的场合会被用来强调“言行不一”的转折含义，并且常常和主观动词「言う」「思う」「考える」「悩む」「知る」「嫌う」等连接使用，并且常常形成「つつも」的形式：</p>
<div class="note info no-icon"><p>今日は勉強しようと<strong>思いつつも</strong>，テレビを見てしまった。</p>
</div>
<p>这个助词还可以构成「つつある」的形式在口语中表示动作的持续，一定程度上类似后面要说到的「ている」形式：</p>
<div class="note info no-icon"><p>彼は今自分が<strong>死につつある</strong>ことを意識していた。</p>
</div>
<h3 id="接续辅助动词构成复合动词">接续辅助动词构成复合动词</h3>
<p>复合动词是日语中常用的一种动词，常常是动词后面接续辅助动词或者形容动词接续辅助动词构成的，前面的动词或者形容动词构成主要意思，后面的辅助动词提供补充含义。当然，也有一些复合动词演化出了较为独特的含义。这里简单举出一些例子。</p>
<ul>
<li>辅助动词「合う」</li>
</ul>
<p>这个辅助动词的含义一般是“互相”，所以经常用来表达一些双方之间互相进行的行为，比如“互相帮助”或者“互相理解”。但是有的时候这个动词也可以表达出“汇合”的感觉。这类复合动词有：</p>
<div class="note info no-icon"><p>愛し合う、巡り合う、話し合う、語り合う、助け合う、理解し合う、分かり合う</p>
</div>
<ul>
<li>辅助动词「込む」</li>
</ul>
<p>这个辅助动词的含义一般是“程度深”，所以一般用来表示前面的动词进行的较为深入。所以可以接在“申请”后面表示“申请进入”或者接在“饮用”后面表示“吞噬”等含义。这种这类复合动词有：</p>
<div class="note info no-icon"><p>申し込む、読み込む、落ち込む、飲み込む、飛び込む</p>
</div>
<ul>
<li>辅助动词「出す」</li>
</ul>
<p>这个辅助动词的含义一般是“...出来”，这样的表述在汉语里也很多，类似“说出来”或者“飞出来”等等，所以这种复合动词很好理解。这类复合动词有：</p>
<div class="note info no-icon"><p>言い出す、思い出す、呼び出す、飛び出す、逃げ出す、考え出す</p>
</div>
<ul>
<li>辅助动词「上がる／上げる」</li>
</ul>
<p>这个辅助动词的含义一般是“完成”，但是会根据前面的动词是自动词还是他动词进行区分使用。如果是自动词就使用「上がる」，如果是他动词就使用「上げる」。这类复合动词有：</p>
<div class="note info no-icon"><p>飛び上がる、打ち上げる、晴れ上がる</p>
</div>
<p>实际上复合动词接续的辅助动词绝对不限于这些，比如说「始める」「続ける」「終わる」「残す」「返す」「かける」「切る」「兼ねる」都可以作为辅助动词使用。</p>
<h3 id="接续辅助形容词构成复合形容词">接续辅助形容词构成复合形容词</h3>
<p>这里着重介绍「やすい」「にくい」这两个形容词。这两个形容词常常接续在第一连用形之后，分别表示“这个动作容易做”以及“这个动作不好做”的意思。由于不是重点，这里简单写两个例句表明用法：</p>
<div class="note info no-icon"><p>この薬は<strong>飲みやすい</strong>です。 冬の日に食べ物は悪く<strong>なりにくい</strong>です。</p>
</div>
]]></content>
      <categories>
        <category>日语</category>
      </categories>
  </entry>
  <entry>
    <title>日本高中课程《漢文》学习笔记</title>
    <url>/2021/08/16/ja-2/</url>
    <content><![CDATA[<p>这门课大致就是讲日本人是如何阅读中文文言文的。学这个纯属是觉得日语这门语言真的很有意思，借鉴中文的文字，却采用了和中文几乎完全不一样的语法。另一方面也是因为好奇中国的典籍传到日本是如何被翻译的。</p>
<p>虽然自己现代日语都还没学明白，但作为随缘学习人，不如再开新坑。</p>
<span id="more"></span>
<h1 id="基本语序">基本语序</h1>
<p>首先我们需要知道，汉语之中的语序是“主谓宾”，而日语却是“主宾谓”。</p>
<p>所以说日本人在阅读文言文的时候，第一件事就是要把各种词语的顺序调节成日本人能够用日语思维理解的样子。这个时候，日本人发明了<strong>返点（返り点）</strong>和<strong>送假名（送り仮名）</strong>，将其标注在文言文原文旁，用于辅助阅读。</p>
<h2 id="送假名">送假名</h2>
<p>日本人阅读文言文的时候，为了标记出宾语（日本一般称为“目的语”）的位置，常常在表示宾语的汉字右下侧标记「ヲ／ニ／ト」三个假名之一，这就是送假名。这三个假名也是现代日语之中相当重要的三个助词，其表明了三种不同的语法关系。比如说（按理应该使用竖排文字，但是考虑到排版问题，就使用横排文字了。角标位置相应逆时针旋转九十度）：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \text{陳康粛公善}_{\text{レ}}^{\text{クス}} \text{射}^{\text{ヲ}}。\\
&amp; \text{項梁乃}^{\text{チ}}\text{教}^{\text{フ}}_{\text{一}}\text{籍}^{\text{ニ}}\text{兵法}^{\text{ヲ}}_{\text{二}}。　\\
\end{aligned}
\]</span></p>
<p>这里“射”“籍”以及“兵法”右上方（由于改为横排，故旋转到右上方）标注的「ヲ／ニ／ト」就是送假名了，其作用就是标注出宾语的位置。</p>
<p>除去这三个假名，还有一些送假名的目的是将汉语汉字添加上黏性词尾转化为日语词。比如说这里的“教”标注了「フ」假名，实际上代表了「教ふ」这个日语词（注意这里使用古代假名用法而非现代用法）。</p>
<h2 id="返点">返点</h2>
<p>返点指的是用于提示读者调换文字阅读顺序的提示文字，常常标记在汉字左下角（横排的时候位于右下角）。返点常用的三种为「レ点」「一二点」「上下点」，写法就是汉字左下角的「レ」假名、汉字数字「一二三」和汉字「上下」。</p>
<p>「レ点」的作用是<strong>标记此处返回一个文字</strong>，也就是说位于「レ点」两侧的汉字实际的阅读顺序是反过来的。比如说此句：</p>
<p><span class="math display">\[
\text{行}^{\text{ク}}_{\text{レ}}\text{海}^{\text{ニ}}。
\]</span></p>
<p>这里「レ点」表明“行”和“海”两个汉字的阅读顺序恰好和印刷顺序是相反的，也就是先读“海”，再读“行”。</p>
<p>如果返回汉字的数量超过一个，则使用「一二点」标记。阅读顺序是从标有「一」的位置跳转到标有「二」的位置。比如说此句：</p>
<p><span class="math display">\[
\text{思}^{\text{フ}}_{\text{二}}\text{君}^{\text{ノ}}\text{事}^{\text{ヲ}}_{\text{一}}。
\]</span></p>
<p>此时的阅读顺序是首先跳过“思”，先阅读“君”和“事”，之后跳转去阅读“思”。</p>
<p>「上下点」用于标记嵌套的跳转。在两个「一二点」嵌套的时候，为了消歧义，将外层的「一二点」变为「上下点」。比如说此句：</p>
<p><span class="math display">\[
\text{有}^{\text{リ}}_{\text{下}} \text{観}^{\text{ル}}_{\text{二}} {}^{\text{ばい}}\text{梅} {}^{\text{か}}\text{花}^{\text{ヲ}}_{\text{一}} \text{者}_{\text{上}}。
\]</span></p>
<p><strong>注解：</strong>这里在右上方（横排的时候在左上方）标注的平假名是这个汉字的注音。</p>
<p>此时的阅读顺序是从“梅花”开始，从“花”跳转到“観”，之后向下阅读到“者”，再跳转到“有”。</p>
<p>如果涉及到更为深层的跳转嵌套，可能会使用到天干地支。但对于大部分的转读，这三类就已经够用了。</p>
<hr />
<p>综合这三种返点的话，可以看这一个例句（只保留返点）：</p>
<p><span class="math display">\[
\text{無}_{\text{下}} \text{不}_{\text{レ}} \text{知}_{\text{レ}} \text{愛}_{\text{二}} \text{其} \text{親}_{\text{一}} \text{者}_{\text{上}}。
\]</span></p>
<p>这一句话首先阅读“其親”，之后根据「一二点」跳转到“愛”，遇到「レ点」则逐个倒着读“知不”，之后向下读到“者”，最后根据「上下点」读到“無”。所以最后的汉字阅读顺序是“其親愛知不者無”，当然这和真正的日语还有距离，但至少汉字顺序已经符合日语思维了，之后就是需要利用送假名填充各种助词和词尾。</p>
<h2 id="其他的一些概念">其他的一些概念</h2>
<p>首先需要介绍<strong>置字（置き字）</strong>，其含义是在转读为日语的时候不需要读出的汉字。其不会直接在文章中标出来，基本靠读者自身的文言能力来判定。比如说：</p>
<p><span class="math display">\[
\text{念} \text{莫}_{\text{下}} \text{可}_{\text{レ}} \text{使}_{\text{レ}} \text{用}_{\text{二}} \text{於} \text{秦}_{\text{一}} \text{者}_{\text{上}}。
\]</span></p>
<p>这里的“於”实际上是不会读出来的，所以说阅读顺序是“念秦用使可者莫”，并不包含汉字“於”。</p>
<p>置字常常是古汉语之中常见的一些助词，比如说“而”“於”“乎”“矣”“焉”之类的。</p>
<p>另外，有的时候「レ点」「一二点」或者「レ点」「上下点」会出现在同一个汉字的左下角，这个时候就会发生<strong>合写</strong>。这种合写形式的返点是有专门的 Unicode 字符的，但是这里无法打出来，所以直接分立写出：</p>
<p><span class="math display">\[
\text{勿}^{\text{カレ}}_{\text{下}} \text{以}^{\text{テ}}_{\text{二}} \text{悪}^{\text{ノ}} \text{小}^{\text{ナルヲ}}_{\text{一}} \text{為}^{\text{ス}}_{\text{上レ}} \text{之}^{\text{ヲ}}。
\]</span></p>
<p>这个时候「レ点」「上下点」虽然合写，但发挥各自作用。</p>
<p>此外，有些时候文言之中有部分双字或者四字熟语不能拆分理解，这些熟语的汉字之间会用短横连接，表示作为整体处理（这里由于短横渲染问题，使用左右括号标志）。比如：</p>
<p><span class="math display">\[
\text{欲}^{\text{ス}}_{\text{三}} (\text{学}_{\text{二}} \text{習}^{\text{セント}}) \text{漢} \text{文}^{\text{ヲ}}_{\text{一}}。
\]</span></p>
<h1 id="书下文">书下文</h1>
<p>书下文（書き下し文）指的是通过返点和送假名，将文言文直接转化成的，符合日语语法习惯但不一定完全通顺的文句。其转写方式是，首先通过返点调转汉字阅读顺序，最后通过送假名填入日语助词和词尾。</p>
<p>比如说这一句：</p>
<p><span class="math display">\[
\text{有}^{\text{リ}}_{\text{下}} \text{観}^{\text{ル}}_{\text{二}} {}^{\text{ばい}}\text{梅} {}^{\text{か}}\text{花}^{\text{ヲ}}_{\text{一}} \text{者}_{\text{上}}。
\]</span></p>
<p>首先通过返点得到汉字顺序为“梅花観者有”，之后在各个汉字后补上送假名之后就得到这句话的书下文：</p>
<p><span class="math display">\[
\text{梅花を観る者有り。}
\]</span></p>
<p>不过在转写书下文的时候，要注意三点：</p>
<ul>
<li><p>注意日语助词和助动词不写作汉字。</p></li>
<li><p>注意置字不写入书下文。</p></li>
<li><p>注意再读汉字的转写（具体转写方式见后续）。</p></li>
</ul>
<p>比如说这一句：</p>
<p><span class="math display">\[
\text{子} \text{曰}^{\text{ク}} \text{温}^{\text{メテ}}_{\text{レ}} \text{故}^{\text{キヲ}} \text{而} \text{知}^{\text{ラバ}}_{\text{レ}} \text{新}^{\text{シキヲ}} \text{可}^{\text{シ}}_{\text{二}} \text{以}^{\text{テ}} \text{為}^{\text{ル}}_{\text{一レ}} \text{師} \text{矣}。
\]</span></p>
<p>首先得到汉字的阅读顺序为“子曰故温新知以師為可”，这里“而”和“矣”是置字，不需要写入书下文。之后填充假名得到书下文：</p>
<p><span class="math display">\[
\text{子曰く故きを温めて新しきを知らば以て師為るべし。}
\]</span></p>
<p>这里注意，「可し（べし）」是一个助动词，不应当写为汉字。</p>
<p>常见的助词包括：</p>
<div class="note info no-icon"><p>の，か，や，より，と，かな，のみ</p>
</div>
<p>这里，「の」常写作“之”，「のみ」常写作“耳”。</p>
<p>常见的助动词包括：</p>
<div class="note info no-icon"><p>ず，しむ，る，らる，なり，べし，ごとし</p>
</div>
<p>这里，「べし」常写作“可”，「ごとし」常写作“若”，「なり」常写作“也”。</p>
<h1 id="再读汉字">再读汉字</h1>
<p>再读汉字指的就是在转写的时候需要读两次的汉字，其往往代表了日语之中的一些固定句式。再读汉字的第一次读的注音用平假名标在汉字右上角（横排的时候在左上方），第二次读的注音用平假名标在汉字左上角（横排的时候在左下方），而第二次的送假名则和返点一样在左下角（横排的时候在右下方），以表区分，这里用空格隔开。</p>
<p>另外注意，<strong>一般而言，再读汉字第一遍读的时候作实词写成汉字，而第二遍读的时候作虚词不写成汉字</strong>。比如说这样的例句：</p>
<p><span class="math display">\[
{}^{\text{まさ}}_{\text{べ}}\text{当}^{\text{ニ}}_{\text{二 シ}} \text{勉} \text{強}^{\text{ス}}_{\text{一}}。
\]</span></p>
<p>注意到再读汉字“当”读两次，这句话汉字的阅读顺序应该为“当勉强当”，第二遍读“当”的时候不写为汉字。则书下文为：</p>
<p><span class="math display">\[
\text{当に勉強すべし。}
\]</span></p>
<p>日本高中要求掌握的再读汉字包括：</p>
<div class="note info no-icon"><p>宜，当，未，猶，応，将，盍，須，且</p>
</div>
<p>这些汉字的读法为（这里平假名标注的是汉字本身的读音，片假名标注的是相应的送假名。而在「」之中标注的，则是紧接在再读汉字第二次读之前的汉字的送假名。「動詞形式」指的是紧接在再读汉字第二次读之前的动词应当采取的变形）：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">再読漢字</th>
<th style="text-align: center;">読み方</th>
<th style="text-align: center;">意味</th>
<th style="text-align: center;">動詞形式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">未</td>
<td style="text-align: center;">　いまダ〜ず　</td>
<td style="text-align: center;">まだ〜ない</td>
<td style="text-align: center;">未然形</td>
</tr>
<tr class="even">
<td style="text-align: center;">且 &amp; 将</td>
<td style="text-align: center;">　まさニ〜「ント」す　</td>
<td style="text-align: center;">これから〜しようとする</td>
<td style="text-align: center;">未然形</td>
</tr>
<tr class="odd">
<td style="text-align: center;">当 &amp; 応</td>
<td style="text-align: center;">　まさニ〜べシ　</td>
<td style="text-align: center;">当然〜すべきだ</td>
<td style="text-align: center;">終止形／ラ変連体形</td>
</tr>
<tr class="even">
<td style="text-align: center;">須</td>
<td style="text-align: center;">　すべかラク〜べシ　</td>
<td style="text-align: center;">ぜひとも〜する必要がある</td>
<td style="text-align: center;">終止形／ラ変連体形</td>
</tr>
<tr class="odd">
<td style="text-align: center;">宜</td>
<td style="text-align: center;">　よろシク〜べシ　</td>
<td style="text-align: center;">〜するのがよい</td>
<td style="text-align: center;">終止形／ラ変連体形</td>
</tr>
<tr class="even">
<td style="text-align: center;">猶</td>
<td style="text-align: center;">　なホ〜ごとシ　</td>
<td style="text-align: center;">ちょうど〜のようだ</td>
<td style="text-align: center;">名詞＋「の」／動詞連体形＋「が」</td>
</tr>
<tr class="odd">
<td style="text-align: center;">盍</td>
<td style="text-align: center;">　なんゾ〜ざル　</td>
<td style="text-align: center;">どうして〜しないのか</td>
<td style="text-align: center;">未然形</td>
</tr>
</tbody>
</table>
<h1 id="使役动词">使役动词</h1>
]]></content>
      <categories>
        <category>日语</category>
      </categories>
  </entry>
  <entry>
    <title>怎么读日语汉字</title>
    <url>/2021/11/27/ja-3/</url>
    <content><![CDATA[<p>日语这门语言的文字系统中依然存在着汉字，然而其汉字的读法却往往和我们的理解不一样。最经典的就是，日语的汉字往往具有多个读音，这和汉语中汉字少有多音的特征明显不同。另一方面，某些日语汉字的读音和现代汉语几乎一致，也有一些则完全不相像。所以，作为中国人，阅读汉字较多的日语文本的时候往往能理解，但是我们很难正确将这些汉字读正确。</p>
<p>Holder 初学日语的时候，困顿于完全不知道如何断定日语汉字的读音。不过随着词汇量的上升，我似懂非懂地理解了一些日语汉字发音规律，这里也就权且当闲聊，把自己了解到的一些东西写出来。</p>
<span id="more"></span>
<h1 id="日语书写体系">日语书写体系</h1>
<div class="note warning"><p>为了理清楚日语汉字读音，我们最好是日语书写体系开始，最好能完全理解为什么汉字会出现在日语中。这一部分还会讲解很多细致的书面日语习惯，和本文主题并不完全一致，所以如果并不感兴趣，则可以跳过本部分。</p>
</div>
<h2 id="三套书写体系的历史">三套书写体系的历史</h2>
<p>汉语传入日本，为日本带来了两样新事物。一是汉字这一书写系统，二是大量日语中本不具有的词汇。</p>
<p>汉字传入前的日语不具有书写系统，而汉字的传入让日本人开始尝试使用汉字表记日语。</p>
<p>表记的思路有两个，一个是把汉字直接当成表音符号，每一个日语音都用一个读音类似的汉字代表。这种表记方式《万叶集》为代表，即为<strong>万叶假名</strong>。比如日语发音为 i，书面语则使用发音类似的汉字「以」表记。而日语词 iroha 则表记为「以呂波」。</p>
<p>当然，万叶假名中日语音与表音汉字的对应并不是完全严格的，比如说 i 音除了使用「以」表记，还可以使用「伊」表记。并且，万叶假名也不是一个完全遵守汉字表音的书写系统，其依然具有一些例外。比如说，一个字可以表记多个音节，如「信」可以表记 shina 两个音节。另外，部分情况下可能考虑到汉字的表意性，比如说，i 音在表示数词的时候还可以表记为「五十」。此外还有一些文字游戏，比如说，表达“出”的含义的日语词 ide 可以利用汉字表意性，用单字「出」表记，但是有时可能会因为“出”字的字形原因表记为「山上復有山」这样的词。</p>
<p>但是万叶假名使用一个笔画繁杂的汉字仅仅是表达一个音节显得冗余且低效，于是人们在传抄万叶假名编写的日语文本的时候，会将高频万叶假名替换为笔画更少的、公认的惯用简体。这些惯用简体在后续的演变中逐步固化成为日语使用者均认可的两套现代假名，即<strong>平假名</strong>和<strong>片假名</strong>。比如说日语 no 音常用汉字「乃」表记，这个表音汉字在后续传抄中逐步简化，形成了平假名「の」。平假名和片假名的诞生保证了书写效率，而且基本上确保了一种假名对应一种音节，减少了一种音节对应多种文字的繁杂情况。</p>
<p>也就是说<strong>现代日语的假名实际上是古代表音汉字的简化结果</strong>。</p>
<p>另外一种用汉字表记日语的思路是将汉字当成表意符号，将日语词用与之同义或者意思相近的汉字表记。比如说表示“草”这个事物的日语词 kusa 就可以表记为单字「草」。这里的汉字保留了其原有的含义，与万叶假名的表音汉字不同。</p>
<p>此外，先前还提到过汉语传入日本为日语带来了很多新词汇，这些直接借自汉语的词汇在书面上自然沿用其原先的汉字表记。</p>
<h2 id="三套书写体系的使用惯例">三套书写体系的使用惯例</h2>
<p>现在我们总结一下，日语的书面表记就有三套系统，即平假名、片假名和汉字。之后的讨论基本基于下述现代日语句：</p>
<div class="note info no-icon"><p>わたしは漢字を書くことができます。</p>
</div>
<h3 id="汉字">汉字</h3>
<p>例句有两个表记为汉字的词汇，即「漢字」和「書」。其中前者表记的是直接从汉语中借用的汉字词“汉字”，后者则是表记的日语固有词 kaku 中读音为 ka 的部分，这个词的含义为“书写”。</p>
<p>在讲解汉字如何引入日语的时候已经提到过，日语中的汉字往往仅有两种用法，即表记汉语借词和作为表意文字表记日语固有词。</p>
<p>而实际上汉字还可以表记和制汉语词。和制汉语词指的是近代以来，日本翻译家模仿汉字词创造的一批描述新生事物、概念的词语。这些词语原先不存在于汉语之中，甚至是在创造后回流入汉语的。但是其基本和汉语借词保持类似的读音和构词规则，所以表记上也习惯用汉字。比如说 kyouwa，这个词回流入汉语称为现代汉语词“共和”，其日语表记为「共和」。</p>
<p>另外，表音汉字依然在现代日语中有少许残留，其中一部分可以认为是万叶假名的残余。比如说姓名用词 mana，可以按照万叶假名的写法表记为「麻奈」。而另外一部分比如形容动词 sutekida，其常常使用汉字表记为「素敵だ」，这里的汉字仅仅关注了其读音，并未考虑其含义。这种并非是万叶假名残留的表音汉字，一般而言都是一种称为「当て字」的汉字表记法，可以理解为“假借”。</p>
<p>「当て字」的核心思维就是在没有合适的表意汉字表记词语的时候（一般都是日语固有词、外来语词这些本不具有汉字表记的词汇），假借已有的汉字表其音或者表其意以充当其汉字表记，「素敵だ」是其一例。这里再举出一例，比如说音译自 romantic 的日语词 romanchikku 既可以按照一般表记方法写为「ロマンチック」，也可以假借汉字，表记为「浪漫的」。</p>
<p>上述提到的汉字表记用法实际上就对应了后续讲解的如何确定汉字读音的部分。</p>
<h3 id="平假名">平假名</h3>
<p>例句除了汉字，其余的部分则全都是平假名，每一种平假名代表一种日语音节，其不表意，仅表音。现代日语中使用假名书写的词汇，往往是各种实词的语法成分（送假名）、含义虚化的词语（助词、助动词及作为补助成分的实词）、不习惯写为汉字的词语（或词语部分）、对应汉字生僻的词语。</p>
<h4 id="黏性词缀">黏性词缀</h4>
<p>日语是黏着语，动词、形容词等实词往往是具有语法功能的黏性词缀，这些词缀没有含义，仅仅用于表达语法作用（参见日语语法手册）。习惯上，实词的汉字表记不会涵盖这些词缀，而是使用假名表记（即<strong>送假名</strong>）以凸显词缀的黏性变化。比如说，kaku 这个固有动词中，ku 就是黏性词缀，所以表记为假名，ka 则是词干，使用表意汉字表记。</p>
<p>此外，送假名表示的词缀并不一定会变形。比如说古日语二段动词固化形成的现代日语一段动词往往具有不少于一个送假名，但是其语法变化仅限于最后一个送假名。如固有动词 ikiru 一般表记为「生きる」，其送假名包括「きる」，但是实际的变形中仅有词尾「る」变化，另一个送假名「き」不参与变形。</p>
<p>然而，在部分固化的复合单词中黏性词缀有时候也会被涵盖在汉字表记之中。比如说，表达“接待”含义的固有复合名词 uketuke，严格而言这里两个 ke 音均是黏性词缀，应该使用送假名表记，整个名词表记为「受け付け」。但是忽略送假名，表记为「受付」也是常见的。而这种将词缀收纳入汉字表记中的现象，在动词的第一连用形名词化中相当常见，比如 hikari 等词，本身应该为 hikaru 的第一连用形，用送假名表记为「光り」，而实际上更常见的表记是没有送假名的「光」。</p>
<h4 id="含义虚化的词语">含义虚化的词语</h4>
<p>含义虚化的词语一般不使用汉字表记。比如说，上述例句中的格助词 wa 和 wo 只能表记为假名「は、を」，助动词 masu 只能表记为假名「ます」，这些词几乎不表记为汉字。而固有名词 koto 是具有汉字表记「事」的，但是只有在 koto 表达实在的“事情”这一个含义的时候才会使用。上述句子中 koto 是形式体言，仅仅发挥承接动词连体形以完成名词化的语法作用，不具有实在含义，所以使用假名表记「こと」。</p>
<p>含义虚化是一个比较模糊的概念，实际上上述例句中，即使 koto 使用汉字表记，大多数人依然能正确认读，只是稍显不自然。而对于意义虚化后具有较大含义差别的实词，使用假名还是汉字表记，可能带来并不太一样的语义：</p>
<div class="note info no-icon"><p>資料を出して<strong>ください</strong>。</p>
<p>資料を出して<strong>下さい</strong>。</p>
</div>
<p>这里，固有动词 kudasaru 的命令形 kudasai 的词干分别使用了假名表记和汉字表记。使用假名表记的时候，kudasaru 往往理解为补助动词，表达“请求”的语气，所以第一句话表达的是“请取出资料”的含义。而使用汉字表记的时候，kudasaru 则作为实词理解为“从他人处获取某物品”，第二句话往往理解为“取出资料后给我”的含义。</p>
<p>但是这两个含义在口语中则完全不可以分辨，而书面上也往往根据上下文可以断定。另一方面，汉字表记往往占用更少的空间，所以在需要浓缩信息的书面表达场合（新闻标题、告示板、文书），即使严格意义上有歧义的可能，依然更倾向于使用汉字表记。</p>
<h4 id="习惯与生僻字">习惯与生僻字</h4>
<p>不习惯写为汉字的词语和对应生僻字的词语一般不使用汉字表记。上述例句中，固有词 watashi 是第一人称代词，其确实具有汉字表记「私」，但是比例并不小的日语使用者会倾向于假名表记「わたし」。而第二人称代词 anata 即使具有汉字表记「貴方」，其假名表记写法「あなた」依然占据上风。此外，汉语借词 kaizan 的汉字表记为「改竄」，但是由于汉字「竄」生僻，更通用的书面表记则是将生僻字部分用假名表记的「改ざん」。</p>
<h3 id="片假名">片假名</h3>
<p>现代日语中片假名几乎只用于表记外来语和现代汉语借词，部分时候可能表记拟声词等：</p>
<div class="note info no-icon"><p>ご覧の<strong>スポンサー</strong>の提供でお送りします。</p>
<p>彼女は<strong>シクシク</strong>と泣いている。</p>
</div>
<p>这里前者借自英语词 sponsor，而后者是一个拟声词。</p>
<h3 id="惯例的例外">惯例的例外</h3>
<p>事实上，上述的规律只是描述性的，并不强制。比如说片假名表记还可以用于强调句子的特定部分：</p>
<div class="note info no-icon"><p>見て見ぬ<strong>フリ</strong>なだけ。</p>
</div>
<p>这里的固有词 furi 表达含义“装作”，是一个虚化含义，常常使用平假名表记为「ふり」。这里使用片假名，是因为需要强调“我确实知道，我只是视而不见”这样的语感。</p>
<p>此外，尽可能多地用汉字表记（即使习惯上不使用），甚至将假名替换为表音汉字的书写方法也是存在的，虽然有可能造成一定的阅读障碍。</p>
<hr />
<p>这里的另外一个例外就是现代汉语借词。这些词汇借自汉语，所以这些词汇在汉语中就有汉字表记。原则上，现代外来语应该使用片假名表记，但是为了方便交流，很多时候还是会保持汉字表记。最经典的就是现代中国城市「上海」，其原则上应该表记为片假名「シャンハイ」，但是其汉字写法还是占据较大比例。为了区分现代汉语借词和古汉语借词，人们往往在给这些现代汉语借词注音（即<strong>振假名</strong>）的时候使用片假名而非平假名。</p>
<h1 id="训读和音读">训读和音读</h1>
<div class="note warning"><p>注意，这里的<strong>训读</strong>概念和语言学中并不完全一致，我们认为<strong>只有在汉字表记的是日本固有词的时候才是训读</strong>，类似「煙草」训读作 tabako 这类的读法，一律归类到假借表记之中。</p>
</div>
<p>上面的分析中简要介绍了日语汉字的各种情况，现在我们回顾初学日语的时候就会了解的训读和音读的概念。在此基础上，或许就会对日语汉字的读音有所把握了。</p>
<p>我们提到过日语汉字可能用于：</p>
<ul>
<li>表记汉语借词或和制汉语词</li>
<li>作为表意文字表记日语固有词</li>
<li>残留的万叶假名作为表音文字表记日语固有词</li>
<li>假借表记</li>
</ul>
<p>第一个用法中，汉字的读音往往会尽力模仿汉语读音，这也就是一般称作的<strong>音读</strong>，第三个用法则可以认为是一种广义的音读。而第二个用法则是常说的<strong>训读</strong>，此时汉字的读音取决于日语固有词的读音而非这个汉字的汉语音。第四个用法中汉字的读音具有一定规律性，但是依然是经常遇到例外的。</p>
<h2 id="训读">训读</h2>
<h3 id="单字训">单字训</h3>
<p>单字训是训读中最常见的一种方式。所谓单字训，就是找一个和该日语词意思一致或意思类似的汉字，作为这个日语词的表记。此时这个汉字就训读作这个日语词的音。</p>
<p>比如说表达“山”这一事物的日语词 yama，就使用汉字「山」表记，所以就称汉字「山」训读作 yama。</p>
<p>而动词或者形容词需要注意黏性词缀。比如说动词 yameru，在表示“停止”的含义的时候，可以用汉字「止」表记，而 meru 是黏性词缀表记为平假名，所以整个动词汉字表记为「止める」。此时就称汉字「止」训读作 ya-meru。</p>
<p>注意这里把黏性词缀的读音跟在后面是有必要的，否则多个表记为同一个汉字的动词会导致混乱。比如说动词 oriru 表达“下来”的含义的时候可以用「下」表记，整体汉字表记为「下りる」。而动词 sageru 表达“下降”的时候也用「下」表记，整体汉字表记为「下げる」。所以「下」具有两个不同的训读 o-riru 和 sa-geru。不接上黏性词缀的话，即直接认为「下」训为 o 或者 sa 均可，则可能将「下げる」误读作 ogeru。</p>
<hr />
<p>上面已经体现出，多义汉字可以用于表记不同的日语词，导致日语汉字的训读多音。同样的还有汉字「生」，其表达“未经加工的”这一含义的时候可以训为 nama，应用在「生ビール」等词语中。表达“生长”这一含义的时候可以训为 ha-eru，出现在动词「生える」中。表达“生存”这一含义的时候，则训为 i-kiru，出现在动词「生きる」中。</p>
<p>同样的，同一个日语词可以使用多种意义相近但含义稍有差别的汉字表记，以表达微妙的语感差别。比如说动词 warau，其常常表记为「笑う」。而在表达“嘲笑”这个含义的时候，表记为「嗤う」也是可以的。</p>
<h3 id="熟字训">熟字训</h3>
<p>部分日语词不会使用单个汉字表记，而是会使用一个汉语词组表记。此时我们没有办法指出这个汉语词组中具体每个字训读的读音，只能说整个词组训读作这个日语词。熟字训往往出现在表达基本概念或者具有日本文化特色的概念的词语中。</p>
<p>名词 samidare 表达的含义为“梅雨”，其汉字表记为「梅雨」，这里词组「梅雨」整体训读作 samidare。类似还有「時雨」训读作 shigure，「吹雪」训读作 fubuki 等。这些概念是具有日本文化特色的。</p>
<p>而描述一些基本的概念的词语也会出现熟字训。比如 koko 表达“这里”，其汉字表记为「此処」。kesa 表达“今早”，其汉字表记为「今朝」。</p>
<h3 id="词组训读">词组训读</h3>
<p>词组训读指的是将一组日语词用单字或者汉字词组表记，此时该单字或者词组训成这个日语词组的读音。词组训读和熟字训的差别在，词组训读是表记一组日语词，而熟字训本质上还只是表达一个日语词。</p>
<p>考虑动词 maturu 和名词 koto，前者使用第一连用形接续后者后发生音便得到词组 maturigoto，其直接含义为“祭祀之事”，引申为“政治”。由于 maturu 和 koto 分别具有汉字表记「祭る」和「こと」，该词组可以表记为「祭り事／祭事」。但是也可以整体表记为「政」，此时汉字「政」训读为 maturigoto 共计五个音节。</p>
<p>同样的还有 yomigae-ru。这里 yomi 是熟字训，汉字表记为「黄泉」，而 kae-ru 表记为「帰る」。这个动词直接翻译为“从黄泉归来”，引申为“苏醒”，即可以直接表记为「蘇る」。</p>
<p>词组训读很多时候是表记为单字的，所以这一部分词组训读甚至就可以认为是一般的单字训。比如说「宿る」训作 yado-ru，其实际上用单字训写出的汉字表记应该为「屋取る」。另外，「雷」训作 kaminari，而这个用单字训应该表记为「神鳴」。</p>
<h2 id="音读">音读</h2>
<p>由于音读几乎是模拟汉字的汉语读音，所以基本遵循一个汉字一到两个音节的对应规则，出现一个汉字对应两个音节大多是因为古汉语的入声被保留为音节。</p>
<p>汉语借词曾在多个时期借入日语，所以这些词语所模仿的是不同时期、不同地域的汉语读音，所以即使大多数情况下一个汉字仅对应一种音读读音，但依然存在音读多音字。比如说目前日语中存在的音读，按照传入时期从先到后可以划分为古音、吴音、汉音、唐音，目前大部分的日语音读均基于汉音，和制汉语词的发音也基本是按照汉音。这些音读体系在语音学上都具有一定的特征，但是我并没有多少语音学知识，所以也没办法讲解。</p>
<p>一个比较著名的音读词是「老若男女」，其应该按照吴音读作 rounyakunannyo，但实际上这四个字单独发音时，应该按照汉音分别读作 rou、jaku、dan、jo。</p>
<hr />
<p>广义的音读还包括万叶假名残留，其与常见的音读不同，这些词语的汉字表记不表意，仅仅表音。这些词语几乎仅存在于专用名词中，所以这里不做介绍。</p>
<h2 id="音训混合">音训混合</h2>
<p>日语的部分词汇是将汉语借词和日语本土词拼接形成的，这些词语往往会出现一个汉字使用训读而另一个汉字使用音读的情况。这类词语内部同时出现音读和训读的现象称为音训混合。另外，部分音训混合词语可能起源于误读，而在后续使用中错误读法固化为通用读法。</p>
<p>音训混合分为两类，前训后音的称为<strong>汤桶读法</strong>，前音后训的称为<strong>重箱读法</strong>。</p>
<p>汤桶读法源于日语词「湯桶」，其第一个汉字使用训读，读作 yu，而第二个汉字使用音读，读作 tou。此外，汤桶读法词汇还包括「合図」（读作 aizu）、「大勢」（读作 oozei）、「高台」（读作 takadai）等词汇。</p>
<p>重箱读法则源于「重箱」，其前音后训，读作 jyuubako。重箱读法词汇还包括「馬鹿」（读作 baka）、「残高」（读作 zandaka）、「番組」（读作 bangumi）、「額縁」（读作 gakubuchi）等词汇。重箱读法中，后面的汉字常常浊化。</p>
<h2 id="假借字">假借字</h2>
<p>在日语书写系统中，大部分词语的表记遵循这样的规律：</p>
<ul>
<li>日语本土词
<ul>
<li>词干使用与之同义的汉字单字或汉字组表记，黏性词缀使用平假名表记【训读】</li>
<li>部分专有名词采用残留的万叶假名表记【广义音读】</li>
</ul></li>
<li>汉语借词
<ul>
<li>采用和汉语几乎一致的汉字表记【音读】</li>
</ul></li>
<li>外来词、现代汉语借词、拟声词
<ul>
<li>采用片假名表记，但是现代汉语借词可以采用汉字表记</li>
</ul></li>
</ul>
<p>而这种规律的例外就是假借字。比如说，部分日语本土词难以找到很合适的汉字或者汉字组表示，或者需要给外来词语赋予汉字表记的时候会使用假借字。另外，在文学、文艺领域，有时即使某些词已经有了通用的汉字表记，也往往为了表达效果故意使用其他汉字表记。</p>
<p>选择假借字的时候，可以从汉字含义的角度选取，也可以单纯考虑汉字发音，如果能做到兼顾音和义，则是假借字运用的顶点。</p>
<p>这里举出几例假借字。首先是没有合适汉字表记的日语固有词：</p>
<ul>
<li><p>sutekida。仅考虑汉字读音，表记为「素敵だ」。含义为“美好的”。</p></li>
<li><p>shituke。shi 音使用音读汉字「仕」表记，tu 音使用训作 tu 音的汉字「付」表记，ke 为黏性词缀。整体表记为「仕付け」。含义为“管教”。</p></li>
<li><p>gomakasu。仅考虑汉字读音，表记为「誤魔化す」。含义为“糊弄、搪塞”。</p></li>
</ul>
<p>值得一提的是「仕」字是相当常见的假借字，大量以 shi 音开头的日语固有词都会用到这个假借字。比如「仕事、仕方、仕舞う、仕草」，这些词含义分别为“工作”、“方法”、“结束、终结”、“台词、说辞”。</p>
<div class="note warning"><p>这种假借字几乎是并不明白日语的中国人尝试阅读日语的最大障碍，因为这些字确实常见但却根本不表意，甚至连起来显得莫名其妙。比如说：</p>
<div class="note info no-icon">
<p>
夢ならば<strong>何程</strong>良かったでしょう。ーー「 Lemon 」
</p>
</div>
<p>
这里「何程」就是副词 dorehodo 的假借字，这个词的意思是“多么”，整句话的意思是“如果这是梦境的话该多好啊”。显然这里的汉字根本没有为我们理解句子带来积极作用，甚至起到了反作用。
</p>
<p>
另外，之前提到过，含义虚化的实词原则上应该写为假名，如果完全写成汉字，也可以为理解句子提供反面作用：
</p>
<div class="note info no-icon">
<p>
遣り直す事出来れば遣って見よう。
</p>
</div>
<p>
这里「遣」是动词 ya-ru 词干的汉字表记，含义为“做、干”。「直す」则是动词 nao-su 的表记，其含义为“重来”，这是经典的单字训，但是词语含义和汉字含义几乎对不上。「出来」是假借字，即借用训为 de 的「出」字和训为 ki 的「来」字来表记日语固有动词 deki-ru，其含义为“能做到”。「見」则是 mi-ru 词干的表记，其作为实义动词的时候含义为“看”，但是这里作为补助动词含义为“尝试”。
</p>
<p>
这句话整体含义为“如果能重来，就试着做吧”，可以发现句子含义和汉字含义可以说没有关系。
</p>
<p>
然而这句话在更多时候并不会用这么多的汉字表记，更常见的写法是：
</p>
<div class="note info no-icon">
<p>
やり直すことできればやってみよう。
</p>
</div>
<p>
所以说，正是因为假借字、虚化动词和并不一定直观的训读的存在，并不是说汉字越多就越容易理解日语句子的。
</p>
</div>
<hr />
<p>外来语的汉字表记则一定会使用假借字，这些假借字可能是纯表音的：</p>
<ul>
<li>借自英语 Asia 的 ajia。仅考虑汉字读音表记为「亜細亜」。含义为“亚洲”。</li>
</ul>
<p>也可以是纯表意的：</p>
<ul>
<li>借自英语 beer 的 biiru。仅考虑汉字含义表记为「麦酒」。含义为“啤酒”。</li>
</ul>
<p>当然也有很多音义结合的精妙的假借字：</p>
<ul>
<li><p>借自英语 club 的 kurabu。表记为「倶楽部」。含义为“俱乐部”。</p></li>
<li><p>借自葡萄牙语 jorro 的 jouro。表记为「如雨露」。含义为“洒水器”。</p></li>
</ul>
<p>但是由于汉字难以书写，许多的外来语假借字在现代日语中慢慢被片假名表记替代了。</p>
<hr />
<p>下面来探讨文艺领域使用的假借字，这些假借字往往具有其特殊的表达效果。比如说著名的「五月蝿い」，其表记的是固有形容词 urusai，含义为“烦躁的”。这种假借仅仅考虑了汉字含义，侧重于表达汉字所表达的含义，然后将其读作某一个固有词的音。另外还有用「生命」表记固有词 inochi（含义为“生命”，常用汉字表记为「命」），用「光明」表记固有词 hikari（含义为“光明”，常用汉字表记为「光」），用「運命」表记固有词 sadame（含义为“确定之事”，常用汉字表记为「定め」）等假借字用法。这些假借字虽然和常用汉字表记含义类似，却常常出现在文艺作品形成特殊的表达效果。</p>
<p>比如：</p>
<div class="note info no-icon"><p>夢覚めてゆく，<strong>光明「ひかり」</strong>が目を刺す。ーー「朧月」</p>
<p>この血の<strong>運命「さだめ」</strong>。ーー「ジョジョの奇妙な冒険 OP 」</p>
</div>
<p>这种假借字实际上可以理解为广义的训读，只不过和通行的训读不一致而已。</p>
<p>另外，有时选取的汉字表记会故意和词语含义相反以表达看似如此实则不然的含义，达到特殊的表达效果：</p>
<div class="note info no-icon"><p>思いもしない<strong>軽い「おもい」</strong>言葉，何度使い古すのか？ーー「カワキヲアメク」</p>
</div>
<p>这里用「軽い」表记 omoi 这个形容词，但是其含义为“重的”，与汉字表记恰好相反。从而就表达出了，这样的话语看似轻浮但实际上蕴含深意，这样的含义。</p>
<p>但是这类假借一般都会把读音注释出来，防止读错。</p>
<h1 id="日语的数量词的发音">日语的数量词的发音</h1>
<div class="note info"><p>这一部分使用平假名而非罗马音表记日语词。</p>
</div>
<p>在最后讲解如何确定日语汉字读音之前，我们来看一个折磨无数日语学习者的知识点——日语数词和量词。</p>
<p>日语有两套数词，一套是日语固有的数词，一套是从汉语引入的数词，这两套数词的表记基本上都使用汉字“一二三四”等。而统一的汉字表记的背后，是完全不知道应该读成哪一套数词的迷茫。再加上数词和量词合用时发生的混乱的音便，以及大量的例外情况，所以说确定日语数量词的读音绝对是日语初学者面临的第一个大问题。</p>
<p>为了后续讲解的方便，我们先行把数词量词读音的确定讲解结束。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">传统数词【训读】</th>
<th style="text-align: center;">汉语数词【音读】</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">一</td>
<td style="text-align: center;">ひ（と）</td>
<td style="text-align: center;">いち</td>
</tr>
<tr class="even">
<td style="text-align: center;">二</td>
<td style="text-align: center;">ふ（た）</td>
<td style="text-align: center;">に</td>
</tr>
<tr class="odd">
<td style="text-align: center;">三</td>
<td style="text-align: center;">み</td>
<td style="text-align: center;">さん</td>
</tr>
<tr class="even">
<td style="text-align: center;">四</td>
<td style="text-align: center;">よ（ん）</td>
<td style="text-align: center;">し</td>
</tr>
<tr class="odd">
<td style="text-align: center;">五</td>
<td style="text-align: center;">い（つ）</td>
<td style="text-align: center;">ご</td>
</tr>
<tr class="even">
<td style="text-align: center;">六</td>
<td style="text-align: center;">む</td>
<td style="text-align: center;">ろく</td>
</tr>
<tr class="odd">
<td style="text-align: center;">七</td>
<td style="text-align: center;">な（な）</td>
<td style="text-align: center;">しち</td>
</tr>
<tr class="even">
<td style="text-align: center;">八</td>
<td style="text-align: center;">や</td>
<td style="text-align: center;">はち</td>
</tr>
<tr class="odd">
<td style="text-align: center;">九</td>
<td style="text-align: center;">ここの</td>
<td style="text-align: center;">く／きゅう</td>
</tr>
<tr class="even">
<td style="text-align: center;">十</td>
<td style="text-align: center;">とお</td>
<td style="text-align: center;">じゅう</td>
</tr>
<tr class="odd">
<td style="text-align: center;">百</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">ひゃく</td>
</tr>
<tr class="even">
<td style="text-align: center;">千</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">せん</td>
</tr>
<tr class="odd">
<td style="text-align: center;">万</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">まん</td>
</tr>
</tbody>
</table>
<p>首先关注应该读这两套数词之中的哪一套。原则如下：</p>
<ul>
<li><p>训读数词往往和训读的量词配合使用，音读数词往往和音读的量词配合使用</p></li>
<li><p>训读数词可能和某些名词一起构成复合名词</p></li>
<li><p>训读数词中，二十、五十、百等均有一些固定表达，但使用得并不普遍</p></li>
<li><p>注意音读数词的「四」和「七」的发音和「死」的训读类似，所以很多时候会有意用训读数词的「四」和「七」代替音读数词</p></li>
</ul>
<p>原则四带来了“半训读数词”这个概念，也就是即使是音读的数词，里面的「四」和「七」也是可以替换为训读数词的。比如理论上“十四”没有训读，仅可以音读为 jyuushi，但是其可以把「四」训读，读成 jyuuyon。甚至实际上半训读数词应用得比音读数词更广泛。</p>
<p>在了解这些原则的情况下，我们先处理一些极其不规则的领域。</p>
<p>语言学有这样的一个规律，即越是日常用的基础概念，越倾向于不规则。这一般是由于常用词语的用法早已固化，为人熟知，所以很难在后续自然演变和规范化过程中改变，从而这些词语的用法就保持着不规则。比如说英语的不规则动词几乎全都是日常使用频率极高的动词。同样的，日语数量词最不规则的地方就是最日常的两个领域，即个数和日期。</p>
<p>数个数的时候，经常使用固有量词「つ」，此时数词使用训读数词，且一般仅能表达一到十的数量。而且，即使使用训读数词，这些训读数词也会发生一些不规则的变化：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">传统数词【训读】</th>
<th style="text-align: center;">接续固有量词「つ」</th>
<th style="text-align: center;">汉字表记</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">一</td>
<td style="text-align: center;">ひ（と）</td>
<td style="text-align: center;">ひとつ</td>
<td style="text-align: center;">一つ</td>
</tr>
<tr class="even">
<td style="text-align: center;">二</td>
<td style="text-align: center;">ふ（た）</td>
<td style="text-align: center;">ふたつ</td>
<td style="text-align: center;">二つ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">三</td>
<td style="text-align: center;">み</td>
<td style="text-align: center;">みっつ</td>
<td style="text-align: center;">三つ</td>
</tr>
<tr class="even">
<td style="text-align: center;">四</td>
<td style="text-align: center;">よ（ん）</td>
<td style="text-align: center;">よっつ</td>
<td style="text-align: center;">四つ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">五</td>
<td style="text-align: center;">い（つ）</td>
<td style="text-align: center;">いつつ</td>
<td style="text-align: center;">五つ</td>
</tr>
<tr class="even">
<td style="text-align: center;">六</td>
<td style="text-align: center;">む</td>
<td style="text-align: center;">むっつ</td>
<td style="text-align: center;">六つ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">七</td>
<td style="text-align: center;">な（な）</td>
<td style="text-align: center;">ななつ</td>
<td style="text-align: center;">七つ</td>
</tr>
<tr class="even">
<td style="text-align: center;">八</td>
<td style="text-align: center;">や</td>
<td style="text-align: center;">やっつ</td>
<td style="text-align: center;">八つ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">九</td>
<td style="text-align: center;">ここの</td>
<td style="text-align: center;">ここのつ</td>
<td style="text-align: center;">九つ</td>
</tr>
<tr class="even">
<td style="text-align: center;">十</td>
<td style="text-align: center;">とお</td>
<td style="text-align: center;">とお</td>
<td style="text-align: center;">十</td>
</tr>
</tbody>
</table>
<p>多于十个则会使用音读量词「個」和音读数词，比如“十二个”就是「じゅうにこ」，汉字表记为「十二個」。另外，询问个数的时候一般使用「いくつ」这个疑问词，而不是常见的「何」接续量词作为疑问词。</p>
<p>日期则需要注意一到十号、十四号、二十号、二十四号是特殊的。除了这些日期外，其余的日期均是音读数词加上音读量词「日」，此时发音为 nichi。而二到十号、十四号、二十号、二十四号使用的日期量词的汉语表记也是「日」，但是读作 ka。而一号完全相当于熟字训，没有规律。另外注意，十七号、二十七号使用半训读的数词接续音读的「日」也可以。</p>
<p>这种混杂的情况和上面的四个原则的第三、第四原则有关，即「四」和「七」习惯被替换为训读数词避免不吉利，但是日期的「四」会把量词跟着替换，而「七」则不需要替换量词，甚至使用音读数词也是可以的。另外，日期使用了「二十」的固有表达。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">传统数词【训读】</th>
<th style="text-align: center;">汉语数词【音读】</th>
<th style="text-align: center;">接续量词「日」</th>
<th style="text-align: center;">汉字表记</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">一</td>
<td style="text-align: center;">ひ（と）</td>
<td style="text-align: center;">いち</td>
<td style="text-align: center;">ついたち</td>
<td style="text-align: center;">一日</td>
</tr>
<tr class="even">
<td style="text-align: center;">二</td>
<td style="text-align: center;">ふ（た）</td>
<td style="text-align: center;">に</td>
<td style="text-align: center;">ふつか</td>
<td style="text-align: center;">二日</td>
</tr>
<tr class="odd">
<td style="text-align: center;">三</td>
<td style="text-align: center;">み</td>
<td style="text-align: center;">さん</td>
<td style="text-align: center;">みっか</td>
<td style="text-align: center;">三日</td>
</tr>
<tr class="even">
<td style="text-align: center;">四</td>
<td style="text-align: center;">よ（ん）</td>
<td style="text-align: center;">し</td>
<td style="text-align: center;">よっか</td>
<td style="text-align: center;">四日</td>
</tr>
<tr class="odd">
<td style="text-align: center;">五</td>
<td style="text-align: center;">い（つ）</td>
<td style="text-align: center;">ご</td>
<td style="text-align: center;">いつか</td>
<td style="text-align: center;">五日</td>
</tr>
<tr class="even">
<td style="text-align: center;">六</td>
<td style="text-align: center;">む</td>
<td style="text-align: center;">ろく</td>
<td style="text-align: center;">むいか</td>
<td style="text-align: center;">六日</td>
</tr>
<tr class="odd">
<td style="text-align: center;">七</td>
<td style="text-align: center;">な（な）</td>
<td style="text-align: center;">しち</td>
<td style="text-align: center;">なのか</td>
<td style="text-align: center;">七日</td>
</tr>
<tr class="even">
<td style="text-align: center;">八</td>
<td style="text-align: center;">や</td>
<td style="text-align: center;">はち</td>
<td style="text-align: center;">ようか</td>
<td style="text-align: center;">八日</td>
</tr>
<tr class="odd">
<td style="text-align: center;">九</td>
<td style="text-align: center;">ここの</td>
<td style="text-align: center;">く／きゅう</td>
<td style="text-align: center;">ここのか</td>
<td style="text-align: center;">九日</td>
</tr>
<tr class="even">
<td style="text-align: center;">十</td>
<td style="text-align: center;">とお</td>
<td style="text-align: center;">じゅう</td>
<td style="text-align: center;">とおか</td>
<td style="text-align: center;">十日</td>
</tr>
<tr class="odd">
<td style="text-align: center;">十一</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">じゅういち</td>
<td style="text-align: center;">じゅういちにち</td>
<td style="text-align: center;">十一日</td>
</tr>
<tr class="even">
<td style="text-align: center;">十四</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">じゅうし</td>
<td style="text-align: center;">じゅうよっか</td>
<td style="text-align: center;">十四日</td>
</tr>
<tr class="odd">
<td style="text-align: center;">十七</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">じゅうしち</td>
<td style="text-align: center;">じゅうななにち／じゅうしちにち</td>
<td style="text-align: center;">十七日</td>
</tr>
<tr class="even">
<td style="text-align: center;">二十</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">にじゅう</td>
<td style="text-align: center;">はつか</td>
<td style="text-align: center;">二十日</td>
</tr>
<tr class="odd">
<td style="text-align: center;">二十四</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">にじゅうし</td>
<td style="text-align: center;">にじゅうよっか</td>
<td style="text-align: center;">二十四日</td>
</tr>
<tr class="even">
<td style="text-align: center;">二十七</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">にじゅうしち</td>
<td style="text-align: center;">にじゅうななにち／にじゅうしちにち</td>
<td style="text-align: center;">二十七日</td>
</tr>
</tbody>
</table>
<h1 id="如何确定日语汉字的发音">如何确定日语汉字的发音</h1>
<p>在文章的最后，我们终于回到了主题，也就是我们到底该如何确定日语汉字的读音。</p>
<p>为了确定汉字读音，第一件事是拆分句子。这是因为在省略送假名或者不具有送假名的时候，属于不同日语词汇的汉字可能会连接在一起，导致误读。比如说：</p>
<div class="note warning"><p>出来次第，お届けいたします。</p>
</div>
<p>这里出现的「出来次第」四个汉字，实际上是两个词，应该划分为「出来」和「次第」两个部分。这里，这里是这个动词的第一连用形。而后者就是单纯的音读词，发音为 shidai。</p>
]]></content>
      <categories>
        <category>日语</category>
      </categories>
  </entry>
  <entry>
    <title>回忆一下我的大学</title>
    <url>/2021/06/16/look-back/</url>
    <content><![CDATA[<p>在搭好这个网站之前，我也已经上了两年大学，走过了一半的本科时光。</p>
<span id="more"></span>
<p>我总是愿意将自己的身份定位为数学竞赛失败的高考生，从初三开始学习一些基本的数竞，高中数竞奋斗两年，结果是化竞考出所有竞赛中最好成绩然后高考混进了你清计算机系。估计你也看出来了，我在学什么上面一直是迷茫的，高中纠结主攻哪一门竞赛，于是数理化三面都搞。高考出分选专业，甚至是选清北也让我着实过了一个折磨的七月初。最后，还是随着大流，进了计算机系。</p>
<p>我的大一，刚开始的时候野心很大，想着好好搞成绩然后还毅然决然选上了班长。但是大学这片地方的宽阔程度完全超越了我作为一个县高学生的想象，再加上本身就有些不敢与生人交流的个性，所以大一的时候实则还是比较畏畏缩缩的。当时的话，几乎所有课程都靠着自己单打独斗，当时不知道计算机系的 <a href="https://github.com/PKUanonym/REKCARC-TSC-UHT">CRACKER</a>，不知道大学的考试很屑，所以第一学期下来成绩就很一般般。</p>
<p>大一上学期刚结束的我还是有点高考生的“追求”的，于是下定决心下学期认真卷绩点。这种除了绩点什么都不管的心态大概持续了半年，直到加入了 <a href="https://www.unidy.cn">xge</a> 的 <a href="https://github.com/UNIDY2002/THUInfo">THUInfo</a> 项目。或许就是从那个时候开始，才感觉大学不是像高中那样仅仅是为了成绩学习，而是有一些其他的路径的。</p>
<p>大一另外一个印象深刻的事情就是，学年末的甲团评比活动我们班的团支书居然缺席了，最后我不得不顶替他。当时离我们班展示还有不到半小时，而我还在边听着 91 班的展示边做 PPT。这件事之后，我对社工算是很寒心，随后决定不再干社工。</p>
<p>大二的上学期过得很平凡，也没有给我留下很深刻的印象。但是这个学期，尤其是五月份，我明显感觉到自己的心态发生了很大的转变。首先就是自己突然感觉到对前三个学期的生活有种厌恶感，不想让自己继续在 GPA 主导之下生活。其次是突然重燃了对社工的一些热情，主要的缘故是跟着 xge 在科协里面参加了一些活动，比如嘉年华以及智能体决赛，在这期间也算是认识了不少人（比如大恶人安頔）。最后就是敢于正面自己对 Sakana 的一些感情了，大概这里不会太详细展开说。</p>
<p>2021 年 5 月，这一个月完全是值得铭记的。</p>
<p>所以这一篇流水账一般的记录就差不多该结束了。我记得刚刚进入大学的时候有人和我说，适应大学生活是需要很长时间的。我现在在想，或许我现在才算是真的找到了自己想要的生活。回忆着前两年自己近乎碌碌无为的生活，还是暂且从“内卷”“竞争”这些话题之中脱身，想象一下之后的我的大学。</p>
]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
  </entry>
  <entry>
    <title>歌词记录集</title>
    <url>/2021/11/29/lyrics/</url>
    <content><![CDATA[<p>之前大一的时候打算记录各种引起共鸣的歌词，于是就时不时在 QQ 空间里面发一些。但是现在来看，一直都是零零散散的，并不方便，所以就做个总集，顺手就当回忆一些东西了。</p>
<p>这里歌词全是日语的，然后翻译都是自己翻译的，可能会有错误。</p>
<span id="more"></span>
<h1 id="年">2019 年</h1>
<p>2019 年刚刚走进大学，暂且还没有过多的忧虑，整天最大的抱怨只是微积分学不完。饱暖之后就擅长为赋新词强说愁，所以即使经常分享一些莫名其妙的歌词，实际上也只是近乎无病呻吟一般。</p>
<div class="note info no-icon"><p><strong>いつの間にか雪は雨になりました。</strong></p>
<p>不知何时，飘雪已然幻化成雨。</p>
<p>ーー「ハレハレヤ」 2019.10.10</p>
</div>
<p>《朗朗晴天》这首歌是火出圈的 V 曲，当时刚高考完纠结于志愿的时候，一个玩得比较好的同学推荐给我的。当时确实很纠结，很迷茫，这首歌还是带来了一些安慰的。</p>
<p>其特征就是描写确实很漂亮，然后遣词造句也比较朴素干净，属于是很中意的类型。</p>
<div class="note info no-icon"><p><strong>誰もみんな消えてく夢を見た，</strong></p>
<p>梦中大家悄然消逝，</p>
<p><strong>真夜中の部屋の広さと静寂が胸につっかえて，</strong></p>
<p>深夜空旷寂静的房间，胸口一阵微痛，</p>
<p><strong>上手に息ができなくなる。</strong></p>
<p>连呼吸也变得困难。</p>
<p>ーー「炉心融解」 2019.10.16</p>
</div>
<p>《炉心融解》是相当老的一首 V 曲了，也是我喜欢上镜音双子的开端。铃的高音确实很惊艳，这首歌里面也体现得很彻底。</p>
<p>所以，不要在 KTV 里尝试唱《炉心融解》，年轻人对自己嗓子好一点。</p>
<div class="note info no-icon"><p><strong>春はうすもも，夏は群青，</strong></p>
<p>春日是浅桃花，夏日是茂密的树林，</p>
<p><strong>紅色に染まる秋，真っ白の冬，美しい山。</strong></p>
<p>鲜红渲染出的是秋日，纯白的是冬日美丽的群山。</p>
<p>...</p>
<p><strong>山をこえて，どこどこへ。</strong></p>
<p>越过高山，又往何处去？</p>
<p>ーー「遠く君へ」 2019.12.19</p>
</div>
<p>《致远方的你》是略带悲情的一首歌，看这种词大致是能理解其内涵的相思之苦的。这首歌大约是高中随机到的，歌词几乎没有长句子，几乎都是各种意象的堆叠，偶尔会无端责怪两句对方为何远去。</p>
<p>原唱是那种细细的女声，很能听出来愁苦的滋味。</p>
<div class="note info no-icon"><p><strong>気づき始めた，生まれた理由を，きっと独りは寂しい。</strong></p>
<p>似乎察觉到了，你创造我的理由，一定是形单影只太寂寞了吧。</p>
<p><strong>宿るココロが溢れた。</strong></p>
<p>你赋予我的那颗“心”，已然满溢而出了啊。</p>
<p>...</p>
<p><strong>一緒に過ごせた日々をアリガトウ。</strong></p>
<p>我们一起度过的时光，无比感谢。</p>
<p>ーー「ココロ」 2019.12.25</p>
</div>
<p>《心》大约是讲述的科学家与其所创造的一个机器人相恋的故事，但是毕竟人有寿限。这类有点类似探讨人生边界的奇妙歌曲，确实很能打动当时的我。</p>
<p>不过现在也能打动我，因为镜音双子确实好听。</p>
<h1 id="年-1">2020 年</h1>
<p>大学第一学期浪过了，同时也通过各种渠道了解到大学依然还是看成绩的地方，所以渐渐开始沉闷下去了。另外就是，大一下学期面临着大量的琐事，班长也不想当了。年底的甲级团支部评比也让我心态近乎崩溃。</p>
<p>随之变化的就是听歌的风格，这个时候的我，第一次接触到了 MARETU 和熊，也开始听一些真正的意味不明的歌了。</p>
<div class="note info no-icon"><p><strong>足りないものばっかりずっと増えてくの，</strong></p>
<p>不足之物，还在不断增加</p>
<p><strong>物々しく出しゃばる物思い。</strong></p>
<p>煞有介事，多管闲事的思虑。</p>
<p>ーー「うみたがり」 2020.01.05</p>
</div>
<p>《渴望诞生》是严格来说我听的第一首 MARETU 的歌，歌词令人困惑不解，使用的词汇在日常交际中也少见。但是整体的偏低沉的曲风确实很吸引当时的我。</p>
<div class="note info no-icon"><p><strong>三日月，水玉模様，</strong></p>
<p>初三的月亮，是水晶的模样，</p>
<p><strong>破れた障子，甘い飴の味。</strong></p>
<p>破碎的窗户纸，还有糖的甜味。</p>
<p>ーー「抑圧錯乱ガール」 2020.02.01</p>
</div>
<p>这首歌是《地狱型人间动物园》专辑里的一首，整首专辑的立意就是总是有很多人和当代社会无法贴合，最终无法融合的他们只能堕落。《抑压错乱女孩》大致就是讲述的在过大的精神压力下崩溃的女孩的故事，所以莫名其妙和她共鸣了。</p>
<div class="note info no-icon"><p><strong>僕たちもかつてはいつか素晴らしい人に，</strong></p>
<p>我们也曾经和你一样，</p>
<p><strong>憧れていた，君の同じさ。</strong></p>
<p>憧憬着成为伟大的人。</p>
<p><strong>いつだって時間はそう，諦めを教えてくれる。</strong></p>
<p>但是时间一直是那样，教会我们放弃。</p>
<p>Nice people make the world boring.</p>
<p>ーー「LOVE SONG」 2020.02.04</p>
</div>
<p>《情歌》是比较冷门的一首歌，在各大平台上都没有很多播放，我也已经忘了什么时候听到的了。整首歌的 MV 也是偏意味不明和压抑的风格，但总之还是表现了正向积极的主题，确实也包含了一些我当时在尝试探求的答案吧。</p>
<div class="note info no-icon"><p><strong>澄み渡る晴天を昇りゆく白い満月を濡らす。</strong></p>
<p>水汽浸润了那在澄澈的晴空中升起的一轮满月，</p>
<p><strong>空を映る池の水面に光る蛍みたいと過れば。</strong></p>
<p>映照在池面上的月光，如同萤火一般闪烁而过。</p>
<p>...</p>
<p><strong>ふと迸る胸は霧雨でこぼこが作った水溜り。</strong></p>
<p>忽然迸发而出的雾雨，在凹凸不平的地面上积攒起水洼。</p>
<p><strong>まるで夜の虹を見るようなふわりさんざめく夜光虫。</strong></p>
<p>仿佛就像黑夜中的彩虹一般灿烂着的萤火虫们啊。</p>
<p>ーー「蛍」 2020.02.24</p>
</div>
<p>《萤火虫》也不是热门的 V 曲，这首歌是纯纯的写萤火虫的写景抒情曲子，也是当时我学习日语文学的重要歌曲。</p>
<p>这类歌曲我并不擅长翻译，因为我一直感觉保留着原汁原味的歌词才显得有韵味，一旦我翻译了这些歌词，就难免融入我自己对景物、情感的想象。</p>
<div class="note info no-icon"><p><strong>その言葉に挟まるカミシオリ。</strong></p>
<p>夹在那些话语中的纸笺。</p>
<p>ーー「カゲロウ」 2020.03.12</p>
</div>
<p>《蜉蝣》是东方曲的填词，这句词是整首歌的第一句的开头。这首歌是我大一下学期可以说最喜欢的一首歌，曲调很惊艳，演唱者也很有表现力。那种平静的氛围中，很适合让我暂且幻想一下远方和未来。</p>
<p>不过现在确实不太听了，莫名感觉听多了之后有点厌倦了这种声线。或许只是当时听太多了吧。</p>
<div class="note info no-icon"><p><strong>私って失敗作だってさって要らない子なんだって，</strong></p>
<p>我就是所谓的失败作吧，是不被人需要的孩子吧，</p>
<p><strong>何やったって頑張ったって駄目らしいや。</strong></p>
<p>无论做什么，无论多么努力，也不过虚幻一场吧。</p>
<p>ーー「失敗作少女」 2020.04.07</p>
</div>
<p>《失败作少女》是我听的第一首熊，这首歌其实我更喜欢 MARETU 的 remix。为什么说喜欢这首歌呢，因为这首歌节奏把握得很好，有情绪爆发的副歌，也有沉寂的过渡段，尤其是那一段雨声，能让人想见在雨中漫无目的走着的，失魂落魄的少女。而在雨声过后，也有向神明祈求的最后一段情感爆发，歌曲最后的结局是开放的，也确实留下了很大的想象空间。</p>
<p>这段词精妙之处就是大量的促音，有一种难以表达的跳跃感，总之就是唱起来特别带感。</p>
<p>现在的熊，有点歌词莫名其妙，曲风固化，节奏也单调，确实没有一开始那么让人喜欢了。</p>
<div class="note info no-icon"><p><strong>調子はどうですか？空は自由に飛べましたか？すごい魔法が出せましたか？</strong></p>
<p>近况如何？能自由地在天空中飞行了么？能使出厉害的魔法了么？</p>
<p><strong>全部夢の中限定品さ。</strong></p>
<p>这些不过是梦境中的限定品啊。</p>
<p>...</p>
<p><strong>それはあなたの望む世界じゃないから，</strong></p>
<p>这并非是你希望的世界啊，</p>
<p><strong>こんな続きを愛してほしい。</strong></p>
<p>但也不妨爱上这并不完美的梦的后续吧。</p>
<p>ーー「ドリームレスドリームス」 2020.04.19</p>
</div>
<p>《无梦之梦》，绝对称得上现在我最喜欢的 V 曲。一样的，歌曲对抒情节奏有着绝对的把握，梦碎的那一瞬间的副歌段相当震撼，随后是 miku 声线无缝切入，安慰着主角的情绪，劝导主角接受梦想和现实的落差。</p>
<p>可以看得出这段时间我的歌单几乎全都是梦想和现实的矛盾这样的主题，显得很颓丧和没有生机，也确实贴合那段时间的心情。</p>
<div class="note info no-icon"><p><strong>神様もしも生まれ変わることができたら，</strong></p>
<p>神啊，如果我还能重生的话，</p>
<p><strong>愛される子になれますように。</strong></p>
<p>我也想成为被人怜爱的孩子啊。</p>
<p>ーー「失敗作少女」 2020.04.25</p>
</div>
<p>这就是之前说的，《失败作少女》最后的一段抒情段，那种对现有生活的悲观和失望，那种渴求他人善意的感觉。</p>
<p>四月份，当时正准备结束一年的社工生涯，由于团支书当时几乎不做任何事情，整个班级的事务就全在我的肩上。再加上自己还在摸索如何过好大学生活，而且还没有正视自己的一些过往，确实是没有任何人可以倾诉，只能自己默默消化这种逆境。</p>
<div class="note info no-icon"><p><strong>死に方教えてよ。</strong></p>
<p>教会我如何去死吧。</p>
<p>ーー「ヒトサマアレルギー」 2020.05.09</p>
</div>
<p>《旁人过敏症》也是熊曲，不是那么喜欢。这句词只是因为当时确实相当压抑。</p>
<div class="note info no-icon"><p><strong>正しさだけで殴り合うならば，勝ち目はないんだよ。</strong></p>
<p>如果仅仅是因为追求正当就相互殴打，那几乎就没有胜利的可能。</p>
<p>ーー「ネガティヴ進化論」 2020.06.03</p>
</div>
<p>《消极进化论》似乎是基于一个现有的故事还是小说，所以是具有背景的，然而我至今都没有去了解，所以歌词的含义也是似懂非懂。我听这首歌，只是因为旋律确实好听。</p>
<div class="note info no-icon"><p><strong>希望の花，繋いだ絆を。</strong></p>
<p>希望的花，连接起的羁绊。</p>
<p>ーー「フレジア」 2020.07.26</p>
</div>
<p>单纯的梗曲，不过抛开梗来看，这首歌也还不错。</p>
<div class="note info no-icon"><p><strong>花で一つ，鳥で二つ，</strong></p>
<p>第一是花，第二是鸟，</p>
<p><strong>手打ち鳴らす，</strong></p>
<p>拍着手轻声唱，</p>
<p><strong>風で三つ，嗚呼，月出て四つ，</strong></p>
<p>第三是风，啊，第四是升起的月亮，</p>
<p><strong>鳴らす鳴らす。</strong></p>
<p>轻声唱着。</p>
<p>ーー「回レ！雪月花！」 2020.08.28</p>
</div>
<p>《雪月花》也是经典歌曲了，歌词的特色就是大量的四字成语。这一段是中间的过渡段，没有什么很深刻的含义，只是当时觉得很有意思就放上来了。</p>
<div class="note info no-icon"><p><strong>誰もいなくなったら意味はないんですか？</strong></p>
<p>难道万物消逝之后一切都没有意义了吗？</p>
<p>ーー「ドリームレスドリームス」 2020.11.03</p>
</div>
<p>《无梦之梦》最喜欢的一句词，虽然目前都没有领悟之中的含义，不过这句歌词确实是引入副歌的歌词，也是将全曲拉上最高潮的一句词。这种声嘶力竭的反问，确实能让人感到相当震撼。</p>
<div class="note info no-icon"><p><strong>まっさらなら，声上げて。</strong></p>
<p>一尘不染的话，引吭高歌吧。</p>
<p>ーー「百鬼祭」 2020.11.03</p>
</div>
<p>Kanaria 的初投稿，整首歌歌词不是很喜欢，因为完全不明白他想表达的含义。不过 Kanaria 的旋律做得很好，到现在我也一直在听。</p>
<div class="note info no-icon"><p><strong>「まあまあ」なんて要らない，欲しがります死ぬまでは。</strong></p>
<p>得过且过绝对不需要，我要贪得无厌，至死方休。</p>
<p>...</p>
<p><strong>わかるか，私の美学。</strong></p>
<p>你明白吗？我的美学。</p>
<p><strong>この馬鹿正直な拳一つが切り札。</strong></p>
<p>这愚蠢正直的一发拳头，就是我最后的王牌。</p>
<p>ーー「劣等上等」 2020.12.23</p>
</div>
<p>《劣等上等》是 Giga 的代表作，歌很吵，但是词比较有意思。当时的我，在大二上学期取得了很多可以说很好的成就，也在大学中找到了自己的节奏，所以听歌的风格也开始激昂起来了。</p>
<p>有趣的是，我在大一下学期比较沉闷的时候就已经听过《劣等上等》，但当时觉得很不好听，半年后就觉得这首歌绝对好听。看来听歌口味和境遇确实有很大的关联。</p>
<h1 id="年-2">2021 年</h1>
<div class="note info no-icon"><p><strong>お願い死なないで，そんなこと言わないで，</strong></p>
<p>不要去寻死，这样的话语也不要再说，</p>
<p><strong>少し胸の奥が締め付けられる。</strong></p>
<p>心口稍稍有点疼痛。</p>
<p>...</p>
<p><strong>今日からの君も昨日までの君も，</strong></p>
<p>无论是今天以后的你，还是昨天以前的你，</p>
<p><strong>大切に愛しくて嬉しくて好きで。</strong></p>
<p>我都珍重地喜欢着可爱又令我愉悦的你啊。</p>
<p>...</p>
<p><strong>光の群れが羽ばたく景色が，</strong></p>
<p>那绽放着光芒的景色，</p>
<p><strong>どこまでも広がればいいと思えるの。</strong></p>
<p>或许可以充满整个世界。</p>
<p>ーー「蝶々世界」 2021.04.05</p>
</div>
<p>这也是一个较为冷门的 V 曲，分享出来的契机是你清又有人轻生。刚刚步入大二下学期，当时暂且还是处于延续上一学期意气风发的状态。</p>
<div class="note info no-icon"><p><strong>暗闇の自由より鎖に繋がれた光でいいんだ。</strong></p>
<p>与其接受自由的黑暗，我宁愿带着锁链沐浴在光芒之下。</p>
<p>ーー「琥珀の身体」 2021.04.17</p>
</div>
<p>《琥珀的身体》是个好歌，旋律很震撼，然后这一句词绝对是我很喜欢的，也是我第一遍听就确定一定要分享出来的歌词。</p>
<div class="note info no-icon"><p><strong>太陽になれなかった腐った炎，</strong></p>
<p>没能成为太阳的腐烂的火焰，</p>
<p><strong>意味もなく酸素を費やす。</strong></p>
<p>只是毫无意义地耗费着氧气。</p>
<p>ーー「映えない」 2021.04.18</p>
</div>
<p>《不太上镜》是那段时间我几乎算是最喜欢的歌，这首歌就在探讨那些并没有实质的人，为何需要在人前假装出一副胸有成竹的样子。当时我渐渐发觉自己对学业力不从心，确乎有了一些自卑的心理，于是这首歌也确实让我感受到了一点点的震撼。</p>
<div class="note info no-icon"><p><strong>美学とかプライドとか語る前に，</strong></p>
<p>在谈论美学和自尊之前，</p>
<p><strong>やれることをやっていけ。</strong></p>
<p>先去做好能做的事。</p>
<p>ーー「限りなく灰色へ」 2021.05.04</p>
</div>
<p>当时刚刚从上海见 Sakana 回来，心态确实有所好转。在回来的火车上，默默下了一定要好好活下去的决心，于是把《向着无尽之灰》的这句歌词分享出来了。</p>
<div class="note info no-icon"><p><strong>「自分らしく生きて」なんて言わないで，</strong></p>
<p>不要说那些“活出自我”，</p>
<p><strong>らしさなんて最初からないから。</strong></p>
<p>因为根本就没有什么自我。</p>
<p>ーー「映えない」 2021.05.06</p>
</div>
<p>已经忘记了为什么突然要分享这句词了，不过可以知道的是，这段时间往后的一个月，甚至两三个月，我都沉浸在自我否定之中。那段时间我尝试着揭开了很多往事，结果就是相当长时间内都没有缓过来，一直在尝试着建立起自己努力下去的理由。</p>
<div class="note info no-icon"><p><strong>ここ調子が悪いんだ，いや本気はまだまだ，</strong></p>
<p>现在状况有些不太好，不对，只是没拿出真本事而已。</p>
<p><strong>そう言ったのはこれは何度目の台詞だろう？</strong></p>
<p>这个借口已经用了多少次了？</p>
<p>ーー「いや〜いや〜」 2021.05.09</p>
</div>
<p>这首歌高中就听了，但是真正感到理解了一些还是在大二。那段时间开始注意到自己对感情问题的拖延和视而不见已经结出了恶果，也注意到过度的自我封闭让自己完全无法接受现况，于是只能用这段歌词聊以自慰。</p>
<div class="note info no-icon"><p><strong>芝居し合い化かし合い，みんな灰色なんだ，</strong></p>
<p>一起表演，一起幻化，大家不过是一团灰色，</p>
<p><strong>地球は茶番さ，人類みな劇団さ，</strong></p>
<p>地球不过是笑谈，人类也不过是剧团，</p>
<p><strong>存在しない神や愛，芝居で表してきた。</strong></p>
<p>那些本来就不存在的神和爱情，都通过表演展现出来了啊。</p>
<p>ーー「Hyper Reality Show」 2021.05.25</p>
</div>
<p>当时莫名其妙想分享的一句歌词，其实目的只是想让 Sakana 和自己聊聊而已，没有什么特别的含义。</p>
<div class="note info no-icon"><p><strong>取り出し給え，刃！刃！</strong></p>
<p>取出来吧！你的利刃！</p>
<p>ーー「ナミダ」 2021.06.03</p>
</div>
<p>这句词是在第二次去上海的路上分享的，当时自己尝试着通过这种情感特别激烈的歌来调动自己的情绪，以尝试掩盖心中的不安。</p>
<div class="note info no-icon"><p><strong>さよならを言わないのは，あなたに見抜かれてしまわないように。</strong></p>
<p>不和你道别，只是还不想被你看透啊。</p>
<p>ーー「第三の心臓」 2021.06.15</p>
</div>
<p>春卷饭现在的风格是越来越走向温柔向了。《第三心脏》讲述的是朋友之间偶然的矛盾和不快，确实也贴合当时和 Sakana 之间的矛盾。歌曲的最后，两人最终和好，并肩前行，也算是寄托了一些自己的想法吧。</p>
<div class="note info no-icon"><p><strong>ケーキも大好き，君も大好き。</strong></p>
<p>喜欢蛋糕，也喜欢你。</p>
<p>ーー「とある一家の御茶会議」 2021.06.19</p>
</div>
<p>这首歌相当老，是滚苹果 P 的隐退曲，这种欢快的曲调下掩藏的是无可奈何的悲伤。说不出来当时被触动到的心情了，但总之大约是感受到了自己逐渐走向正轨的一些安心，和这些安心之下依然被埋藏着的不安。</p>
<div class="note info no-icon"><p><strong>くたびれた私が駄目だったんだね，</strong></p>
<p>颓废的我已然不堪大用。</p>
<p><strong>まだ役に立つつもりだったけれど。</strong></p>
<p>本还想着发挥最后的余热的。</p>
<p>ーー「ハルノ寂寞」 2021.06.24</p>
</div>
<p>《春日寂寞》是稻叶昙作品中我最喜欢的，无论是技术上调教相当完美，还是歌词旋律相当优秀。那种空灵的旋律，传达出一种无法和你继续下去的痛苦和无奈。</p>
<div class="note info no-icon"><p><strong>ゴミ溜めで埋もれたまま，星空を眺めてるよ。</strong></p>
<p>即使掩埋于垃圾堆之下，也要向上仰望星空。</p>
<p>ーー「ぼくらみんな意味不明」 2021.07.02</p>
</div>
<p>匹老板的代表作之一，旋律不算好听，但是这段歌词确实不错。虽然现在看也并没有讲什么大道理，但确实让我感受到了一点动力。</p>
<div class="note info no-icon"><p><strong>凍てつく雪の中で，確かな熱を帯びた，</strong></p>
<p>冻结着的积雪之下，确实还留存着些许温热，</p>
<p><strong>呼吸をして，声を焼いて，燃えた燃えた禊の火。</strong></p>
<p>喘着气，声音灼热着，映照着燃烧着的业火。</p>
<p>ーー「ハレハレヤ」 2021.07.20</p>
</div>
<p>《朗朗晴天》的副歌段，音调极其之高，但也因此表达出了相当强烈的情感。当时分享的动机就是单纯的好听。</p>
<div class="note info no-icon"><p><strong>全知全能の言葉をほら聞かせてよ。</strong></p>
<p>来，让我听听那些全知全能的话语吧。</p>
<p>ーー「東京テディベア」 2021.08.25</p>
</div>
<p>《东京泰迪熊》也是相当经典的歌曲，依然是镜音的绝妙演出。这一段没有什么特殊含义，只是因为好听。这句词每一个重音都会突然拉高音调，有那种直击人心的表现力。</p>
<div class="note info no-icon"><p><strong>僕は大人にやってなったよママ。</strong></p>
<p>我终于长成大人了啊妈妈。</p>
<p>ーー「ビターチョコデコレーション」 2021.09.22</p>
</div>
<p>《苦巧克力装饰》是我听的第一个 syudou 的歌，这种带一点压抑，带一点深度的歌词很让我着迷。这首歌主要探讨的是放弃童真成长为大人的故事，苦巧克力的含义大致和苦咖啡类似，是成长为社会人的标志，也是小孩子们常常用来假装自己已经长大的一个逞能的用具。</p>
<p>总体而言，当时我坐在西大操场旁边的长椅上等待 Sakana 的电话，偶然循环到了这一句。</p>
<div class="note info no-icon"><p><strong>失うことに慣れてく中で，</strong></p>
<p>已经习惯失去的我，</p>
<p><strong>失くさずにいた大事な思いを抱き締めたら，不意に涙が落ちたのは，</strong></p>
<p>偶然将还未丢失的回忆拥入怀中之时，泪水在不意间悄然落下，</p>
<p><strong>この街でまだ生きていたいと思うから。</strong></p>
<p>是因为我还想在这城市中生存下去啊。</p>
<p>ーー「幽霊東京」 2021.10.09</p>
</div>
<p>《幽灵东京》大约是在探讨着在大城市中生存的艰难，那种为了生活打拼之后，在一天的疲惫之后突然回想起曾经的美好的悲伤感。现在自己这个乡下出身的人，来到北京上大学，确实是需要一段时间接受的。那段时间和同一个高中的学弟交流也很多，所以也时不时会想起自己在高中的那些无忧无虑的时光。</p>
<p>虽然不像歌词写的那么夸张，但还是有点共鸣。</p>
<div class="note info no-icon"><p><strong>どうかどうか与えて，生活を与えて。</strong></p>
<p>无论如何给予她吧，把梦想中的生活给予她吧。</p>
<p>...</p>
<p><strong>あなたがいたあの部屋，未来を繋ぐギャラリアだったはず，</strong></p>
<p>你所在的那个房间，本应该是连接未来的画廊啊，</p>
<p><strong>だったはず。</strong></p>
<p>本应该啊。</p>
<p>ーー「ギャラリア」 2021.10.11</p>
</div>
<p>比较喜欢的一个作品，讲述的是家暴类似话题。不过我倒不是因为歌词喜欢上这首歌的，纯属因为调教比较好，旋律也不错。</p>
<div class="note info no-icon"><p><strong>僕にしかできないことはなんだか？</strong></p>
<p>只有我能做到的事是什么啊？</p>
<p>ーー「群青」 2021.10.25</p>
</div>
<p>《群青》是相当优秀的一个曲子，当时分享这句歌词，也是出于一些不安，觉得自己是可替代的一个人，并不是所谓的独一无二的人。不过其实到现在，我都没有说服自己自己是独一无二的。</p>
<div class="note info no-icon"><p><strong>なるべく永く一緒にいたいんだよ。</strong></p>
<p>那就多让我在你身边吧。</p>
<p>...</p>
<p><strong>少しだけ名残惜しそうにさようなら。</strong></p>
<p>那就依依不舍地道别吧。</p>
<p>ーー「ハルノ寂寞」 2021.10.30</p>
</div>
<p>《春日寂寞》中相互呼应的两句歌词，结合之前说的那种不得不离去的无奈感，确实很感人吧。</p>
<div class="note info no-icon"><p><strong>他人の不幸は蜜の味。</strong></p>
<p>他人的不幸就像是蜜糖的味道。</p>
<p>...</p>
<p><strong>助けを乞う姿を見せておくれ。</strong></p>
<p>让我看看你乞求我救助的可怜模样。</p>
<p>ーー「シャーデンフロイデ」 2021.11.11</p>
</div>
<p>这是《雨路女孩》的续作，大致讲述了一个趁人之危的人作恶的故事，似乎也是影射了一些社会事件，但我这个听歌的，就没有管多少了。这首歌论旋律论节奏都算是不错，不至于很惊艳，但也是相当不错的水平。</p>
<div class="note info no-icon"><p><strong>僕の一等賞を奪いにきて。</strong></p>
<p>来夺取我的一等奖吧。</p>
<p>ーー「ホワイトハッピー」 2021.11.12</p>
</div>
<p>《白色幸福》也是 MARETU 的作品，这句词常常用于影射性相关话题。那具体影射的是什么呢，其实都说是“一等奖”和“夺取”了，应该不难猜出来。</p>
<div class="note info no-icon"><p><strong>簡単な感情ばっか数えいたら，</strong></p>
<p>如果只是清点着简单的感情，</p>
<p><strong>あなたがくれた体温まで忘れてしまった。</strong></p>
<p>就连你传递给我的体温都会忘却。</p>
<p>ーー「DONUT HOLE」 2021.11.29</p>
</div>
<p>《甜甜圈洞》是八爷相当著名的作品，用欢快的语调歌唱感情的绝望。即使 V 家发展了这么多年，八爷这首歌论硬实力依然是相当上乘的，不愧是顶尖音乐人。</p>
<h1 id="年-3">2022 年</h1>
<div class="note info no-icon"><p><strong>なあ今年もさ，桜が散ってしまうんだ。</strong></p>
<p>今年，樱花也如同往常一样凋谢。</p>
<p><strong>夢みたいに踊る桃色に騙されてしまいそうだ。</strong></p>
<p>那如梦境一般漫天飞舞的粉红，几乎将我欺骗。</p>
<p>ーー「地獄に落ちる」 2022.03.16</p>
</div>
<p>《坠入地狱》大约是我目前可以称得上最喜欢的曲子之一，赶上北京短暂的春天，这首歌就显得尤为切合时宜。</p>
<p>这首歌歌词充满力量，而且 KAFU 调得确实相当扎实。副歌段的抒情很强烈，这段简单的写景又是柔和，只能说黑柿子确实把一个失魂落魄而又在漫天飞舞的樱花中重拾理想的人描写出来了。</p>
]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
  </entry>
  <entry>
    <title>小学期深夜的废话</title>
    <url>/2021/08/17/nonsense-at-night/</url>
    <content><![CDATA[<p>突然有点想随便写点东西说点感受而已，写完就该睡大觉了。</p>
<span id="more"></span>
<p>现在是 2021 年 8 月 17 日的深夜 03:44，这个叫 Holder 的大二学生还没有睡。</p>
<p>小学期选了整整 8 学分的课，从第二周开始每周周一到周五都是全天满课。汇编每周有作业，还有一个大作业和考试。Java 每堂课有一个小作业，还有一个看起来不是很小的大作业。量子计算作为一门新课，上来就是全英文 PPT，讲着虚张声势的线性代数，倒也真的把 Holder 愉悦送走了。</p>
<p>但值得庆幸的是，只要不去听老师上课，自己在空调房里和 Sakana 连着麦看 PPT / CSAPP / 各路文档自学，累了就开瓶快乐水刷两眼手机或者打一小会 Project Sekai，然后慢慢写自己学习的时候的笔记和一时的感悟，这种体验简直不要太好。就是那种感觉，那种感受到了学习愉悦之处的感觉。</p>
<p>我也不知道什么时候我变成了厌恶上课的一个人，烦躁于古板沉闷的 PPT reader 式的课堂。我宁愿自己一个人琢磨，不懂的时候就去各种翻资料或者问问同学，然后在个人网站上写下万字之多的笔记。特别是一时间想通一个很困难的问题的时候，我习惯把当时所有的思路都复盘下来写下来。</p>
<p>这个小学期，我突然觉得自己找到了一种玄妙的乐趣，那种像想要抓住什么的一样的冲动。虽然每天都累得不成样子，到处抱怨，但是内心是充实的。</p>
<p>虽然不知道学的东西会不会派上用场，但是就是享受到了学习这一过程之中的乐趣。</p>
<hr />
<p>也不知道这种斗志昂扬的状态会持续到什么时候，也不知道 Holder 未来会不会又一次陷入像今年 5 月那样沉闷的时光，但无论如何，现在的 Holder 是快乐的。</p>
<p>Holder 或许得睡大觉了，虽然现在才睡，翘汇编是不可避免的了。</p>
]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
  </entry>
  <entry>
    <title>课内学习笔记导航</title>
    <url>/2021/09/17/note-navigation/</url>
    <content><![CDATA[<p>似乎这个站点里面的学习笔记是越来越多了，其他的一些东西几乎都被隐埋了。所以我手动将所有的课内学习笔记的发表时间减去了一千年，让它们位于时间轴末尾，并使用这个置顶的导航贴方便大家查看。这里面应该还会写一些简单的课程测评。</p>
<span id="more"></span>
<h2 id="大二春季学期">大二春季学期</h2>
<ul>
<li><a href="/1021/06/16/note-of-iai">人工智能导论</a>。课程主要内容是传统 AI 相关，深度学习和神经网络几乎浅尝辄止，想要炼丹看起来还是去学习深度学习概论、人工神经网络这些课程。</li>
</ul>
<h2 id="大二夏季学期">大二夏季学期</h2>
<ul>
<li><a href="/1021/08/09/note-of-asm">汇编语言程序设计</a>。学得还算明白的课程，但是我是靠 CSAPP 和网上文档自学的，张老师讲课水平我还真没体验，毕竟只去了第一堂课。</li>
</ul>
<h2 id="大三秋季学期">大三秋季学期</h2>
<p>四大原理还是比较难受。</p>
<ul>
<li><p><a href="/1021/09/13/note-of-net">计算机网络原理</a>。上课坐牢的课，是我大学到现在第一个第一节课都没听完就绷不住回去睡大觉的课。</p></li>
<li><p><a href="/1021/09/14/note-of-dsp">信号处理原理</a>。纯数学课，偶尔写写 Python 小实验。</p></li>
</ul>
<p>《计算机组成原理》和《编译原理》没有在这里留笔记，前者是因为半开卷考试，所以笔记全都手写了，后者则是因为不是很想记笔记。其实网原我也不想写的，但是背书课还是给点面子好好写写笔记。</p>
<p>还有两门专业限选课，似乎全是网络相关，但都不是什么重要的课，就不写笔记了。</p>
<h2 id="大三春季学期">大三春季学期</h2>
<p>有好多好多的限选课，但是考试的没多少。</p>
<ul>
<li><p><a href="/2022/02/28/os-exp">操作系统</a>。不太打算考试，所以这个是大实验摸索记录。主要是 rCore 源码阅读笔记和后续自己实验的一些体会。</p></li>
<li><p><a href="/1022/03/09/note-of-csys">计算机系统结构</a>。考试课，不得不记笔记好好学。</p></li>
<li><p><a href="/2021/10/16/note-of-games101">计算机图形学基础</a>。这门课基本就是照着 GAMES101 一把梭子下来的，所以就 link 到 GAMES101 笔记算了。</p></li>
<li><p><a href="/1022/03/09/note-of-cyp">现代密码学</a>。中规中矩的限选课吧，因为要考试所以还是写写笔记。</p></li>
</ul>
<p>还有《数学实验》《搜索引擎技术基础》《存储技术基础》《数据挖掘》《数据库专题训练》这几门不考试，作业也不打算特别认真写的课，就不写笔记了。</p>
]]></content>
      <categories>
        <category>导航</category>
      </categories>
  </entry>
  <entry>
    <title>《计算机系统结构》学习笔记</title>
    <url>/1022/03/09/note-of-csys/</url>
    <content><![CDATA[<p>这门课似乎一直风评不是很好，但还是不得不学。按照学长的说法，这门课就是把四大原理糅合一下，混一点操作系统相关进去，就算完事了。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
  </entry>
  <entry>
    <title>《现代密码学》学习笔记</title>
    <url>/1022/03/09/note-of-cyp/</url>
    <content><![CDATA[<p>一门中规中矩的要考试的限选课，可能会好好学学吧。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
  </entry>
  <entry>
    <title>《汇编语言程序设计》学习笔记</title>
    <url>/1021/08/09/note-of-asm/</url>
    <content><![CDATA[<p>这门课是 2021 年暑期学期开设的计算机系专业课，应该也算是为下学期的《计算机组成原理》课程做预备，所以还打算好好学一下。</p>
<span id="more"></span>
<h1 id="课程基本介绍">课程基本介绍</h1>
<h2 id="汇编语言介绍">汇编语言介绍</h2>
<p>汇编语言可以认为是机器指令的一种表记方式，其表述了计算机硬件系统对外开放的主要接口和规格，是计算机系统之中的软硬件的分界。所以说要了解汇编语言，就首先需要了解机器指令。</p>
<p>机器指令系统一般分为两类：</p>
<ul>
<li><p>CLSC，即<strong>复杂指令系统</strong>。一般而言具有多种指令，寻址方式复杂，单条指令的功能较为复杂。较为经典的代表是 X86。</p></li>
<li><p>RISC，即<strong>精简指令系统</strong>。考虑到实际使用的指令大多都是简要指令，故该系统只具有常用的精简指令。在这样的条件下，该指令系统依赖于编译器产生高效的代码（依赖编译器优化）。较为经典的代表为 MIPS。</p></li>
</ul>
<p>目前，CLSC 和 RISC 之间的差别渐渐缩小。但是还是具有明显的区分方式的，即：</p>
<div class="note info no-icon"><p>It loads / stores [with / without] other operations.</p>
</div>
<p>借助于连接软硬件的机器指令集，计算机系统实现了软硬件解耦合。这样软硬件可以独立编写，从而促进了计算机的发展。</p>
<p><strong>注解：</strong>软硬件的分离的一个重要基石是<strong>图灵完备性</strong>。也就是说软件使用的高级语言是图灵完备的，硬件的指令序列也是图灵完备的，这两者完全等价。这样才保证了分离的可行性。</p>
<h2 id="x86-指令集介绍">X86 指令集介绍</h2>
<p>X86 指令集具有以下的基本特征：</p>
<ul>
<li><p>向下兼容、变长指令、多种寻址方式</p></li>
<li><p>通用寄存器个数有限（X86-32 具有 8 个通用寄存器，X86-64 具有 16 个通用寄存器）</p></li>
<li><p>至多允许一个操作数在内存中，另外一个操作数需要在寄存器中或者是立即数</p></li>
</ul>
<div class="note info no-icon"><p>这里提到了寄存器。X86 之中的寄存器命名为：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">寄存器名称【 X86-64 名称】</th>
<th style="text-align: center;">X86-32 名称</th>
<th style="text-align: center;">寄存器名称【 X86-64 名称】</th>
<th style="text-align: center;">X86-32 名称</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>%rax</code></td>
<td style="text-align: center;"><code>%eax</code></td>
<td style="text-align: center;"><code>%r8</code></td>
<td style="text-align: center;"><code>%r8d</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>%rdx</code></td>
<td style="text-align: center;"><code>%edx</code></td>
<td style="text-align: center;"><code>%r9</code></td>
<td style="text-align: center;"><code>%r9d</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>%rcx</code></td>
<td style="text-align: center;"><code>%ecx</code></td>
<td style="text-align: center;"><code>%r10</code></td>
<td style="text-align: center;"><code>%r10d</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>%rbx</code></td>
<td style="text-align: center;"><code>%ebx</code></td>
<td style="text-align: center;"><code>%r11</code></td>
<td style="text-align: center;"><code>%r11d</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>%rsi</code></td>
<td style="text-align: center;"><code>%esi</code></td>
<td style="text-align: center;"><code>%r12</code></td>
<td style="text-align: center;"><code>%r12d</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>%rdi</code></td>
<td style="text-align: center;"><code>%edi</code></td>
<td style="text-align: center;"><code>%r13</code></td>
<td style="text-align: center;"><code>%r13d</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>%rsp</code></td>
<td style="text-align: center;"><code>%esp</code></td>
<td style="text-align: center;"><code>%r14</code></td>
<td style="text-align: center;"><code>%r14d</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>%rbp</code></td>
<td style="text-align: center;"><code>%ebp</code></td>
<td style="text-align: center;"><code>%r15</code></td>
<td style="text-align: center;"><code>%r15d</code></td>
</tr>
</tbody>
</table>
</div>
<p>由于 X86 重视向下兼容，所以其指令集越来越趋向于庞杂，所以其一个缺点就是资源利用率低。</p>
<h2 id="mips-指令集介绍">MIPS 指令集介绍</h2>
<p>MIPS 的设计思想是充分利用处理器的流水线结构，目标是让流水线各段负载均匀，这样可以让处理器频率得到提高。其特征包括：</p>
<ul>
<li><p>以寄存器为中心，只有 Load 以及 Store 命令可以访问内存</p></li>
<li><p>所有计算操作均是从寄存器堆之中读取数据并将结果保存到寄存器堆，一共具有 32 个通用寄存器</p></li>
<li><p>指令格式规整、定长，且操作码位置固定，指令类型少（MIPS32 的指令只有 register / immediate / jump 三类）</p></li>
<li><p>寻址方式简单，每一条指令的操作过程简单</p></li>
</ul>
<p>当然，MIPS 也具有一些被扩展过的扩展指令集，如 MIPS16e 等等。</p>
<p>此外，RISC-V 也是一种常用指令集。但其几乎和 MIPS 同源，故这里不作详细介绍。</p>
<h1 id="整数的表示与计算">整数的表示与计算</h1>
<p>首先我们介绍一些简要表记，即 K / M / G / T / P / E。符号 K 表示 <span class="math inline">\(2^{10}\)</span>，之后有 <span class="math inline">\({\rm M} = 2^{10} \cdot {\rm K}\)</span> 以及 <span class="math inline">\({\rm G} = 2^{10} \cdot {\rm M}\)</span>，依此类推。</p>
<p>同时我们将一个二进制位称为<strong>比特（bit）</strong>，将八个比特称为<strong>字节（byte）</strong>。在 X86 架构下，两个字节称为一个<strong>字（word）</strong>，而在 MIPS 架构下则是四个字节。</p>
<p>对于数的进制、二进制数的逻辑运算，这里不进行介绍。</p>
<h2 id="机器字和字节序">机器字和字节序</h2>
<p>首先引入<strong>机器字</strong>的概念，机器字指的是计算机进行一次整数运算所能处理的二进制数据组，也可以是一个数据地址。相应的，<strong>机器字长</strong>指的就是一个机器字的位数。对于 32 位字长的计算机，其地址能够表示的空间大小为 4GB 左右。机器字长越大的计算机，其地址的表示空间就越大。</p>
<p>机器字的定位为这个机器字第一个字节的地址，所以说相邻机器字的地址之差在 32 位系统之中为 4，而在 64 位系统之中为 8。</p>
<p><strong>字节序</strong>指的就是一个机器字所包含的字节在机器字之中的排列的顺序，分为<strong>大端序（Big endian）</strong>以及<strong>小端序（Little endian）</strong>。大端序指的是低位字节占据高地址，小端序则相反。</p>
<p>比如说十六进制数据 <code>0x01234567</code>，如果这个机器字地址为 <code>0x100</code>。那么在大端序之下，<code>0x100, 0x101, 0x102, 0x103</code> 的字节内容分别为 <code>01, 23, 45, 67</code>。而在小端序下则是 <code>67, 45, 23, 01</code>。</p>
<h2 id="整数的二进制编码">整数的二进制编码</h2>
<p>我们首先复习一下 C 语言之中各个数据类型的大小，这里以字节作为单位：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">数据类型</th>
<th style="text-align: center;">经典 32 位系统</th>
<th style="text-align: center;">X86-32</th>
<th style="text-align: center;">X86-64</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>char</code></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>short</code></td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>int</code></td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>long</code></td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">8</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>long long</code></td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">8</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>float</code></td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>double</code></td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">8</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>long double</code></td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">10 / 12</td>
<td style="text-align: center;">10 / 16</td>
</tr>
<tr class="odd">
<td style="text-align: center;">指针</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">8</td>
</tr>
</tbody>
</table>
<p>这里我们为了简便，使用 16 位系统来演示整数的编码方式，也就是说机器字长为 16 位，一个整数使用 2 个字节表示。</p>
<h3 id="有符号数的编码">有符号数的编码</h3>
<p>对于非负的整数，显然可以直接使用其二进制表示作为其编码。比如说十进制数 <code>12345</code>，其二进制表示为 <code>00110000 00111001</code>，那么其编码就是 <code>00110000 00111001</code>。</p>
<p>对于负数，一种解决方式是使用最高位表记符号，最高位为 <code>1</code> 的数为负数，为 <code>0</code> 的数为非负数。然而这样会导致加法器在运算的时候需要首先验证符号位，计算出结果后还需要计算符号为，比较繁杂。所以说这里引入了<strong>补码（two's complement）</strong>，用补码表示的整数可以简化有符号整数的计算。</p>
<p>非负数的补码就是其二进制表示，负数的补码是其绝对值的二进制表示按位取反之后加一。</p>
<p>比如说十进制数 <code>-12345</code>，由于 <code>12345</code> 的二进制表示为 <code>00110000 00111001</code>，首先按位取反得到 <code>11001111 11000110</code>，最后加一得到其补码为 <code>11001111 11000111</code>。</p>
<p>这个时候符号位依然存在，也就是说补码表示下负数最高位为 <code>1</code>，非负数最高位为 <code>0</code>。</p>
<div class="note info no-icon"><p>补码的优越性在于简化了有符号整数的加法计算。如果我们使用 <span class="math inline">\({\rm TC}_w(x)\)</span> 表示字长为 <span class="math inline">\(w\)</span> 的系统下整数 <span class="math inline">\(x\)</span> 的补码（比如 <code>-12345</code> 的补码为 <code>11001111 11000111</code>，后者直接转换为十进制表示的是 <code>53191</code>，那么定义 <span class="math inline">\({\rm TC}_w(-12345) = 53191\)</span>）。实际上可以发现对于非负数 <span class="math inline">\({\rm TC}_w(x)=x\)</span>，而对于负数：</p>
<p><span class="math display">\[
{\rm TC}_w(x) = 1 + \mathop{\sim}(-x)
\]</span></p>
<p>而对于字长为 <span class="math inline">\(w\)</span> 的系统，<span class="math inline">\(x + (\mathop{\sim}x) = 2^w - 1\)</span>，所以说对于负数 <span class="math inline">\(x\)</span> 有：</p>
<p><span class="math display">\[
{\rm TC}_w(x) = 1 + 2^w - 1 - (-x) = 2^w + x
\]</span></p>
<p>所以无论如何我们都可以断定：</p>
<p><span class="math display">\[
{\rm TC}_w(x) \equiv x\ ({\rm mod}\ 2^w)
\]</span></p>
<p>在这样的条件下做加法是简单的，因为一个整数和其补码在模 <span class="math inline">\(2^w\)</span> 意义下等价。后面讨论补码条件下的加法的时候，即使出现截断，由于所截断的 <code>1</code> 必然位于不低于 <span class="math inline">\(2^w\)</span> 的位上，所以截断还是不会影响模的结果。</p>
</div>
<p>对于字长为 <span class="math inline">\(w\)</span> 的系统，按照补码表示的有符号数系统之中，最大的数为 <span class="math inline">\(2^{w - 1} - 1\)</span>，而最小的数为 <span class="math inline">\(-2^{w - 1}\)</span>。</p>
<h3 id="无符号数的编码">无符号数的编码</h3>
<p>无符号数的编码是简单的，因为其只需要考虑非负数，所以直接使用二进制表示作为编码就可以了。</p>
<p>这种系统之下，最大的数为 <span class="math inline">\(2^w - 1\)</span>，而最小的数为 <span class="math inline">\(0\)</span>。</p>
<h3 id="有符号数和无符号数的关系和转换">有符号数和无符号数的关系和转换</h3>
<p>现在我们已经给出了有符号和无符号整数的表示方式了。现在考虑将一个有符号整数强制类型转换为无符号整数，比如说在机器字长为 4 的时候，<code>-4</code> 的补码为 <code>1010</code>，而强转为无符号整数的时候，<code>1010</code> 则表示 <code>12</code>。其实不难证明对于字长为 <span class="math inline">\(w\)</span> 的系统，有这样的关系：</p>
<p><span class="math display">\[
(\text{unsigned})x = \begin{cases}
x &amp; x \geq 0 \\
x + 2^w &amp; x &lt; 0
\end{cases}
\]</span></p>
<p>这里提一下，在 C 语言的比较运算之中如果同时出现有符号数和无符号数，则会将有符号数强制转换为无符号数。当然，如果两边都是有符号数，则按照有符号数的比较规则进行。</p>
<p>事实上，由于这样的隐式转换，如果我们给声明为无符号整数的变量赋予一个负数值，就有可能被强制转换为一个大整数，从而导致违反直觉的结果，甚至导致错误。所以说我们应当谨慎使用无符号整数，一般而言，只有涉及到<strong>模运算</strong>或者单纯使用<strong>位运算</strong>的时候无符号整数比较适合。</p>
<h2 id="整数的计算">整数的计算</h2>
<h3 id="无符号整数的加法">无符号整数的加法</h3>
<p>对于字长为 <span class="math inline">\(w\)</span> 的系统，两个整数的加法可能会需要 <span class="math inline">\(w + 1\)</span> 位才能表示，这个时候就会发生<strong>溢出</strong>。计算机的一般处理方式是舍去最高位，强制仅用 <span class="math inline">\(w\)</span> 位表达计算结果，其实相当于对 <span class="math inline">\(2^w\)</span> 取了模。也就是说，字长为 <span class="math inline">\(w\)</span> 的、带有截断的无符号整数加法为（这里，符号 <span class="math inline">\(+^{\text u}_w\)</span> 表示的是字长为 <span class="math inline">\(w\)</span> 的系统下无符号整数的加法）：</p>
<p><span class="math display">\[
x +^{\text{u}}_w y =\begin{cases}
x + y &amp; x + y &lt; 2^w \\
x + y - 2^w &amp; x + y \geq 2^w
\end{cases}
\]</span></p>
<h3 id="有符号整数的加法">有符号整数的加法</h3>
<p>在字长为 <span class="math inline">\(w\)</span> 的、使用补码的系统下，对于有符号整数 <span class="math inline">\(x, y\)</span>，其加法是有可能溢出的。</p>
<p>一种是两个大正数相加，超越了补码能表示的最大整数。此时补码的符号位承接了较低位溢出的 <code>1</code>，也就是说补码之和实际上代表一个负数。由于负数 <span class="math inline">\(u\)</span> 的补码 <span class="math inline">\({\rm TC}_w(u) = u + 2^w\)</span>，这个负数实际上就是 <span class="math inline">\(x + y - 2^w\)</span>。这种情况被称为<strong>正溢出</strong>。</p>
<p>另外一种是两个绝对值很大的负数相加，超越了补码能表示的最小整数。此时补码符号位两个 <code>1</code> 相加得到 <code>10</code>，溢出为 <span class="math inline">\(w + 1\)</span> 位数，但是最高位的 <code>1</code> 被截断。另外，较低的 <span class="math inline">\(w - 1\)</span> 位不会向上进位（绝对值很大的负数的补码较低位所表示的数实际上会很小）。此时结果的补码符号位为 <code>0</code>，代表一个正数。由于负数 <span class="math inline">\(u\)</span> 的补码 <span class="math inline">\({\rm TC}_w(u) = u + 2^w\)</span>，考虑到截断了一个 <code>1</code>，所以该正数为：</p>
<p><span class="math display">\[
(x + 2^w) + (y + 2^w) - 2^w = x + y + 2^w
\]</span></p>
<p>这种情况被称为<strong>负溢出</strong>。</p>
<p>对于求和结果在表示范围内的，补码的和（截断为 <span class="math inline">\(w\)</span> 位后）就是和的补码。这是因为 <span class="math inline">\(x, y\)</span> 的补码相加后截断，所代表的数与 <span class="math inline">\(x + y\)</span> 模 <span class="math inline">\(2^w\)</span> 同余，而 <span class="math inline">\(x + y\)</span> 位于补码能表示的范围内，所以 <span class="math inline">\(x, y\)</span> 的补码相加后截断得到的就是 <span class="math inline">\(x + y\)</span> 的补码。</p>
<p>总而言之，字长为 <span class="math inline">\(w\)</span> 的、带有截断的有符号整数加法为（这里，符号 <span class="math inline">\(+^{\text t}_w\)</span> 表示的是字长为 <span class="math inline">\(w\)</span> 的系统下无符号整数的加法）：</p>
<p><span class="math display">\[
x +^{\text{t}}_w y = \begin{cases}
x + y - 2^w &amp; x + y \geq 2^{w - 1} \\
x + y &amp; -2^{w - 1} \leq x + y &lt; 2^{w - 1} \\
x + y + 2^w &amp; x + y &lt; -2^{w - 1}
\end{cases}
\]</span></p>
<h3 id="无符号整数除以-2-的幂">无符号整数除以 2 的幂</h3>
<p>一般而言在计算机中，除法计算消耗的时间是相当长的。但是对于除数是 2 的幂的情况，我们可以使用移位的方式简化计算。</p>
<p>左移是很好理解的，溢出的部分会被截断，低位会用 <code>0</code> 补齐。但是右移的时候，低位截断是自然的，但是高位如何补齐则有两种方式。如果高位用 <code>0</code> 补齐，这种移位称为<strong>逻辑右移</strong>。如果用原数的最高位补齐（这里的最高位可以是 <code>0</code>，比如 16 位系统之中的 <code>00000000 00000001</code> 的最高位为 <code>0</code>），这种移位称为<strong>算术右移</strong>。</p>
<p>在字长为 <span class="math inline">\(w\)</span> 的系统下，我们将无符号的逻辑右移标记为 <span class="math inline">\(&gt;^{\text{ul}}_w\)</span>，无符号的算术右移则标记为 <span class="math inline">\(&gt;^{\text{um}}_w\)</span>。</p>
<p><strong>注解：</strong>有符号的右移则将上标的 <span class="math inline">\(\text{u}\)</span> 替换为 <span class="math inline">\(\text{t}\)</span>。</p>
<p>其实对于无符号整数 <span class="math inline">\(x\)</span> 不难得到：</p>
<p><span class="math display">\[
x &gt;^{\text{ul}}_w k = \left\lfloor \frac{x}{2^k} \right\rfloor
\]</span></p>
<h3 id="有符号整数除以-2-的幂">有符号整数除以 2 的幂</h3>
<p>首先说明，我们希望除法的结果<strong>向 0 舍入</strong>，也就是说 <code>23.6</code> 舍为 <code>23</code>，<code>-24.6</code> 舍为 <code>-24</code>。</p>
<p>这里我们依然使用右移来简化除法计算。但是我们注意到负数除以 2 的幂之后必然还是负数，所以不能使用逻辑右移，只能使用算数右移。这个时候，对于有符号整数 <span class="math inline">\(x\)</span> 我们可以简单地使用 <span class="math inline">\(x &gt;^{\text{tm}}_w k\)</span> 来计算 <span class="math inline">\(x / 2^k\)</span>。</p>
<p>对于正数，这样的计算显然是正确的。但是对于负数，比如说 <code>-15213</code>，其补码为 <code>11000100 10010011</code>。我们计算其除以 <code>256</code> 的商，按照上面的计算方式即将其补码算术右移 <code>8</code> 位，得到 <code>11111111 11000100</code>，结果为 <code>-60</code>。然而我们知道实际的结果应当为 <code>-59.43</code>，按照舍入应当保留为 <code>-59</code>。</p>
<div class="note info no-icon"><p>事实上我们可以说明：</p>
<p><span class="math display">\[
x &gt;^{\text{tm}}_w k = \left\lfloor \frac{x}{2^k} \right\rfloor
\]</span></p>
<p>也就是说<strong>使用算术右移计算有符号整数的时候永远得到向下舍入的结果</strong>。我们只要说明负数的情况即可，对于负数 <span class="math inline">\(x\)</span> 的补码 <span class="math inline">\(x_{w - 1}x_{w - 2} \cdots x_0\)</span>，我们设二进制数 <span class="math inline">\(x_{w - 1}x_{w - 2} \cdots x_k\)</span> 表示数 <span class="math inline">\(x&#39;\)</span>，二进制数 <span class="math inline">\(x_{k - 1}x_{k - 2} \cdots x_0\)</span> 表示数 <span class="math inline">\(x&#39;&#39; &lt; 2^k\)</span>。显然：</p>
<p><span class="math display">\[
2^k x&#39; + x&#39;&#39; = {\rm TC}_w(x) = 2^w + x
\]</span></p>
<p>而 <span class="math inline">\(x &gt;^{\text{tm}}_w k\)</span> 得到的是 <span class="math inline">\(x_{w - 1}x_{w - 1} \cdots x_{w - 1}x_{w - 2} \cdots x_k\)</span>，其表示数：</p>
<p><span class="math display">\[
x&#39; + \sum_{i = w - k}^{w - 1} 2^i = x&#39; + 2^{w - k}(2^k - 1)
\]</span></p>
<p>按照补码去解读这个二进制串的话，其结果为 <span class="math inline">\(x&#39; + 2^{w - k}(2^k - 1) - 2^w = x&#39; - 2^{w - k}\)</span>。也就能够计算得到：</p>
<p><span class="math display">\[
\left\lfloor \frac{x}{2^k} \right\rfloor = \left\lfloor \frac{2^k x&#39; + x&#39;&#39; - 2^w}{2^k} \right\rfloor = \left\lfloor x&#39; - 2^{w - k} + \frac{x&#39;&#39;}{2^k} \right\rfloor = x&#39; - 2^{w - k} = x &gt;^{\text{tm}}_w k
\]</span></p>
</div>
<p>为了修正这个舍入问题，我们可以尝试使用这样的一个性质：</p>
<p><span class="math display">\[
\left\lceil \frac{x}{y} \right\rceil = \left\lfloor \frac{x + y - 1}{y} \right\rfloor\ (y &gt; 0)
\]</span></p>
<p>也就是说我们只要在计算负数 <span class="math inline">\(x\)</span> 的时候改变为：</p>
<p><span class="math display">\[
\left\lfloor \frac{x + 2^k - 1}{2^k} \right\rfloor = [x +^{\text{t}}_w (2^k - 1)] &gt;^{\text{tm}}_w k
\]</span></p>
<p>即可。</p>
<h1 id="小数的表示">小数的表示</h1>
<h2 id="ieee-浮点数标准">IEEE 浮点数标准</h2>
<p>对于一个有小数部分的数 <span class="math inline">\(B\)</span>，我们总是能找到唯一的 <span class="math inline">\(s \in \{0, 1\}\)</span> 以及实数 <span class="math inline">\(M \in [1, 2)\)</span> 和整数 <span class="math inline">\(E\)</span> 满足：</p>
<p><span class="math display">\[
B = (-1)^s M \cdot 2^E
\]</span></p>
<p>这里 <span class="math inline">\(s, E, M\)</span> 分别称为<strong>符号</strong>、<strong>阶码</strong>和<strong>尾数</strong>。</p>
<p>基于这样的性质，我们可以给出小数的表示方式。将一片数据区域的最高位用于放置符号位 <span class="math inline">\(s\)</span>，然后后面分割为两部分，即 <strong>exp 域</strong>和 <strong>frac 域</strong>，分别放置 <span class="math inline">\(E\)</span> 以及 <span class="math inline">\(M\)</span>。exp 域和 frac 域的具体大小有两种常见的制式（即<strong>单精度浮点</strong>和<strong>双精度浮点</strong>）。当然还有一些不太常用的分区方式，具体见表：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">标准</th>
<th style="text-align: center;">exp 域长度</th>
<th style="text-align: center;">frac 域长度</th>
<th style="text-align: center;">浮点总长</th>
<th style="text-align: center;">备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">单精度浮点</td>
<td style="text-align: center;">8 bits</td>
<td style="text-align: center;">23 bits</td>
<td style="text-align: center;">4 字节</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">双精度浮点</td>
<td style="text-align: center;">11 bits</td>
<td style="text-align: center;">52 bits</td>
<td style="text-align: center;">8 字节</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">扩展精度浮点</td>
<td style="text-align: center;">15 bits</td>
<td style="text-align: center;">63 bits</td>
<td style="text-align: center;">10 字节</td>
<td style="text-align: center;">空置 1 bit</td>
</tr>
<tr class="even">
<td style="text-align: center;">半精度浮点</td>
<td style="text-align: center;">5 bits</td>
<td style="text-align: center;">10 bits</td>
<td style="text-align: center;">2 字节</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>在具体存储的时候，尾数由于整数部分必然为 <code>1</code>，所以只需要将小数部分按顺序存储即可，而阶码使用无符号整数方法存储。</p>
<p>这里注意，阶码理应是有可能为负数的，但一般存储的时候会将阶码加上一个固定的偏置变成正数之后存储。如果阶码长度为 <span class="math inline">\(e\)</span>，那么这个偏置就是 <span class="math inline">\(b = 2^{e - 1} - 1\)</span>。</p>
<p>比如说按照单精度浮点的方式存储数 <code>15213.0</code>，其二进制表示为 <span class="math inline">\(1.1101101101101 \times 2^{13}\)</span>。所以符号位为 <code>0</code>，尾数取小数部分前 23 位，即 <code>1101101 10110100 00000000</code>。阶码为 <code>13</code>，加上偏置 <span class="math inline">\(2^{7} - 1 = 127\)</span> 得到 <code>140</code>，即 <code>10001100</code>。所以最后的存储方式为：</p>
<figure class="highlight plaintext"><figcaption><span>Bits</span></figcaption><table><tr><td class="code"><pre><span class="line">01000110 01101101 10110100 00000000</span><br></pre></td></tr></table></figure>
<h2 id="浮点数的非规格化">浮点数的非规格化</h2>
<p>事实上，浮点数标准保留一部分阶码用于表示特殊的数字。一般而言，阶码全 <code>1</code> 和全 <code>0</code> 是被保留的。具体而言，阶码全 <code>1</code> 和全 <code>0</code> 的、表述特殊数字的浮点数被称为<strong>非规格化浮点数（denormalized float point）</strong>，其余的被称为<strong>规格化浮点数（normalized float point）</strong>。</p>
<p>全 <code>0</code> 的阶码如果按照上述的标准解读的话，表示的是相当接近于零的小数。但是由于默认了尾数的整数部分为 <code>1</code>，所以说还按照原有解读方式的话，浮点数无法表示 <code>0</code>。这个时候作出规定，就是<strong>阶码全 <code>0</code> 的时候，尾数的整数部分变为 <code>0</code></strong>。相应的，为了配合尾数解读方式的调整，<strong>阶码的偏置减去一</strong>。</p>
<p>假设某浮点数标准之中阶码长为 <span class="math inline">\(e\)</span>，尾数长为 <span class="math inline">\(m\)</span>。那么规格化的条件下最小的正浮点数应当是阶码为 <code>00...01</code>，尾数全 <code>0</code>。此时表示的数为 <span class="math inline">\(2^{1 - (2^{e - 1} - 1)} = 2^{2 - 2^{e - 1}}\)</span>。在非规格化条件下，如果将尾数按照无符号整数解析得到的非负整数标记为 <span class="math inline">\(n\)</span>，那么该浮点数应该为 <span class="math inline">\(2^{2 - 2^{e - 1}} \cdot 2^{-m}n\)</span>。这里非负整数 <span class="math inline">\(n\)</span> 取值范围为 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(2^m - 1\)</span>。</p>
<p>所以说非规格化的浮点数所能表述的非负数序列为：</p>
<p><span class="math display">\[
0, \ 2^{2 - 2^{e - 1}} \cdot 2^{-m} \cdot 1, \ \cdots, \ 2^{2 - 2^{e - 1}} \cdot 2^{-m}(2^m - 1)
\]</span></p>
<p>这是一个公差为 <span class="math inline">\(2^{2 - 2^{e - 1}} \cdot 2^{-m}\)</span> 的等差数列，而且最后正好可以和规格化浮点数所表述的最小正数 <span class="math inline">\(2^{2 - 2^{e - 1}}\)</span> “无缝衔接”。所以说非规格化浮点数是一个合理的拓展。</p>
<p>但是，注意非规格化浮点数之中有 <code>+0</code> 和 <code>-0</code> 的区别。</p>
<p>全 <code>1</code> 的阶码用于表示很大的浮点数。一般而言尾数全 <code>0</code> 的时候该浮点数被保留用于表示无穷。而尾数有非 <code>0</code> 位的时候，该浮点数被保留用于表示 <code>NaN</code>。</p>
<hr />
<p>现在补全了非规格化浮点数之后，可以发现浮点数的大小比较实际上几乎可以按照无符号整数从高位直接比较到低位的逻辑进行。因为阶码大的数一定大，阶码一样的时候尾数大的数一定大，包括无穷大也可以纳入进来。但是要考虑这样的例外：</p>
<ul>
<li><p>考虑符号位</p></li>
<li><p>考虑 <code>+0</code> 和 <code>-0</code> 的特例</p></li>
<li><p>考虑 <code>NaN</code> 的问题</p></li>
</ul>
<h2 id="浮点数的舍入问题">浮点数的舍入问题</h2>
<p>由于部分数不能表述为有限的二进制小数，所以在转化为浮点数表示的时候需要舍入。一般而言向上舍入、向下舍入、向零舍入都会带来统计误差，而计算机之中常常使用<strong>向偶数舍入</strong>。其舍入的规则是向最接近的数舍入。如果向两边舍入的距离一致，那么优先舍入到偶数。比如说下列数之中，向百分位的舍入为：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; 12.324999 \Rightarrow 12.32 \\
&amp; 12.325001 \Rightarrow 12.33 \\
&amp; 12.325000 \Rightarrow 12.32 \\
&amp; 12.335000 \Rightarrow 12.34 \\
\end{aligned}
\]</span></p>
<p>回到二进制上的话，由于十进制的 <code>0.5</code> 相当于二进制的 <code>0.1</code>。也就是说如果二进制小数之中后面需要舍去的部分大于 <code>100...</code> 则向上舍入，小于 <code>100...</code> 则向下舍入，恰好是 <code>100...</code> 则向偶数舍入（舍入完毕后尾数为 <code>0</code>）。</p>
<p>这里要注意一点，舍入是有可能导致溢出。</p>
<hr />
<p>至此，小数的计算机编码方式基本就介绍完毕了。其具体过程为：</p>
<ul>
<li><p>根据使用的浮点数标准，判定使用规格化的浮点数还是非规格化的浮点数</p></li>
<li><p>据此判定符号位、阶码和尾数</p></li>
<li><p>对尾数进行舍入后转化为二进制表示</p></li>
</ul>
<h2 id="c-语言的浮点数">C 语言的浮点数</h2>
<p>C 语言之中，<code>int</code> 类型以及 <code>float</code> 类型是 4 字节的，<code>double</code> 则是 8 字节。它们之间的互相转换满足这样的规则：</p>
<ul>
<li><p><code>int</code> 可以精确转换为 <code>double</code> 类型</p></li>
<li><p><code>int</code> 转换为 <code>float</code> 类型不会溢出，但有可能被舍入</p></li>
<li><p><code>float</code> 以及 <code>double</code> 转换为 <code>int</code> 时尾数截断，如果发生溢出则产生 UB</p></li>
</ul>
<h1 id="汇编语言基本知识">汇编语言基本知识</h1>
<p>在这一部分，我们使用<strong>指令集架构（Instruction Set Architecture, ISA）</strong>来定义机器级程序的行为。在这个架构之中，CPU 内有一个记录下一条指令在主存储器之中位置的<strong>指令寄存器（Program Counter, PC）</strong>，这个寄存器在 X86 体系中被命名为 <code>%rip</code>。CPU 之中同时还具有若干个<strong>寄存器</strong>，以及一个用于存储最近执行指令的结果状态信息的<strong>条件码寄存器</strong>。除去 CPU 外，这个架构之中还有<strong>主存储器</strong>，其可以认为是以字节为单元的一片连续的地址空间。</p>
<h2 id="汇编语言的数据类型">汇编语言的数据类型</h2>
<p>和 C 语言不同，汇编语言不区分具体的数据类别，其不关心某一组二进制数据具体代表什么类型的数据。其不区分有符号和无符号的整数，甚至不区分指针和整数。其一般只区分数据的长度为字节、字、双字、四字。在处理这四种长度的数据的时候，指令的后缀分别为 <code>b, w, l, q</code>。比如说传送数据的命令为 <code>mov</code>，在传送字节的时候该命令写为 <code>movb</code>，在传送单字的时候该命令写为 <code>movw</code> 等等。</p>
<h2 id="汇编语言的数据操作">汇编语言的数据操作</h2>
<p>汇编语言的基本操作只包括对寄存器或主存数据进行运算、在寄存器和主存内部或者之间传递数据、转移程序执行位置这三种。</p>
<div class="note info no-icon"><p>在 X86-64 系统之下，寄存器是四字长的、通过名称访问的一片空间。但实际上有的时候指令可以不用访问整个四字长的寄存器空间，其可以通过 32 位操作访问四个字之中较低位的两个字，通过 16 位操作访问四个字中最低位的字，也可以通过字节操作访问最低位的字节。相应的，指代这一片寄存器空间的名称有所改变：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">64 位操作</th>
<th style="text-align: center;">32 位操作</th>
<th style="text-align: center;">16 位操作</th>
<th style="text-align: center;">字节操作</th>
<th style="text-align: center;">64 位操作</th>
<th style="text-align: center;">32 位操作</th>
<th style="text-align: center;">16 位操作</th>
<th style="text-align: center;">字节操作</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>%rax</code></td>
<td style="text-align: center;"><code>%eax</code></td>
<td style="text-align: center;"><code>%ax</code></td>
<td style="text-align: center;"><code>%al</code></td>
<td style="text-align: center;"><code>%r8</code></td>
<td style="text-align: center;"><code>%r8d</code></td>
<td style="text-align: center;"><code>%r8w</code></td>
<td style="text-align: center;"><code>%r8b</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>%rdx</code></td>
<td style="text-align: center;"><code>%edx</code></td>
<td style="text-align: center;"><code>%dx</code></td>
<td style="text-align: center;"><code>%dl</code></td>
<td style="text-align: center;"><code>%r9</code></td>
<td style="text-align: center;"><code>%r9d</code></td>
<td style="text-align: center;"><code>%r9w</code></td>
<td style="text-align: center;"><code>%r9b</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>%rcx</code></td>
<td style="text-align: center;"><code>%ecx</code></td>
<td style="text-align: center;"><code>%cx</code></td>
<td style="text-align: center;"><code>%cl</code></td>
<td style="text-align: center;"><code>%r10</code></td>
<td style="text-align: center;"><code>%r10d</code></td>
<td style="text-align: center;"><code>%r10w</code></td>
<td style="text-align: center;"><code>%r10b</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>%rbx</code></td>
<td style="text-align: center;"><code>%ebx</code></td>
<td style="text-align: center;"><code>%bx</code></td>
<td style="text-align: center;"><code>%bl</code></td>
<td style="text-align: center;"><code>%r11</code></td>
<td style="text-align: center;"><code>%r11d</code></td>
<td style="text-align: center;"><code>%r11w</code></td>
<td style="text-align: center;"><code>%r11b</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>%rsi</code></td>
<td style="text-align: center;"><code>%esi</code></td>
<td style="text-align: center;"><code>%si</code></td>
<td style="text-align: center;"><code>%sil</code></td>
<td style="text-align: center;"><code>%r12</code></td>
<td style="text-align: center;"><code>%r12d</code></td>
<td style="text-align: center;"><code>%r12w</code></td>
<td style="text-align: center;"><code>%r12b</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>%rdi</code></td>
<td style="text-align: center;"><code>%edi</code></td>
<td style="text-align: center;"><code>%di</code></td>
<td style="text-align: center;"><code>%dil</code></td>
<td style="text-align: center;"><code>%r13</code></td>
<td style="text-align: center;"><code>%r13d</code></td>
<td style="text-align: center;"><code>%r13w</code></td>
<td style="text-align: center;"><code>%r13b</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>%rsp</code></td>
<td style="text-align: center;"><code>%esp</code></td>
<td style="text-align: center;"><code>%sp</code></td>
<td style="text-align: center;"><code>%spl</code></td>
<td style="text-align: center;"><code>%r14</code></td>
<td style="text-align: center;"><code>%r14d</code></td>
<td style="text-align: center;"><code>%r14w</code></td>
<td style="text-align: center;"><code>%r14b</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>%rbp</code></td>
<td style="text-align: center;"><code>%ebp</code></td>
<td style="text-align: center;"><code>%bp</code></td>
<td style="text-align: center;"><code>%bpl</code></td>
<td style="text-align: center;"><code>%r15</code></td>
<td style="text-align: center;"><code>%r15d</code></td>
<td style="text-align: center;"><code>%r15w</code></td>
<td style="text-align: center;"><code>%r15b</code></td>
</tr>
</tbody>
</table>
<p>实际上，有的时候我们还可以用字节操作访问 <code>%rax, %rbx, %rcx, %rdx</code> 这四个寄存器的倒数第二低位的字节，指代这一部分空间的名称则为 <code>%ah, %bh, %ch, %dh</code>。</p>
</div>
<p>在具体进行操作的时候，一个机器指令往往需要跟随若干的操作数具体规定操作方法（如传送数据的时候，需要通过操作数指定传送的起始位置和终止位置）。操作数有三种表述方式：</p>
<ul>
<li><p><strong>立即数</strong>。其是一个整型的常数，写法为 <code>$</code> 后接上一个 C 风格的数字表示这个立即数的值。比如说 <code>$-521</code> 以及 <code>$0x4FD</code>。</p></li>
<li><p><strong>寄存器数值</strong>。直接使用寄存器的名称访问，如 <code>%rbp</code> 就代表这个寄存器之中的数据。但是注意，寄存器 <code>%rsp</code> 一般而言是被保留的。</p></li>
<li><p><strong>主存数值</strong>。使用地址访问，其地址由某一个寄存器之中的数据指定，写法为寄存器名称加括号。比如说要访问某一个主存数值，其地址存储在寄存器 <code>%rax</code> 之中，那么其写法为 <code>(%rax)</code>。</p></li>
</ul>
<h2 id="汇编语言的寻址方式">汇编语言的寻址方式</h2>
<h3 id="x86-系统的变址寻址方式">X86 系统的变址寻址方式</h3>
<p>但实际上，在 X86 系统中访问主存数值的方式（这也被称为<strong>寻址方式</strong>）并不是单一的。除去直接使用寄存器之中的数据作为地址去访问，X86 系统提供了包含变址、立即数偏移的寻址模式，其表记一般为 <code>IMM(a, b, s)</code>。这里 <code>IMM</code> 为一个立即数，称为<strong>立即数偏移</strong>，<code>a, b</code> 为两个寄存器名，分别称为<strong>定址寄存器</strong>和<strong>变址寄存器</strong>，<code>s</code> 为 <code>1, 2, 4, 8</code> 之中的一个数，称为<strong>比例因子</strong>。这个记号所代表的地址为：</p>
<p><span class="math display">\[
{\rm IMM} + {\rm R}(a) + {\rm R}(b) \cdot s 
\]</span></p>
<p>这里符号 <span class="math inline">\({\rm R}(a)\)</span> 表示寄存器 <code>a</code> 之中的数据。</p>
<p>这个表记存在一系列简写：</p>
<ul>
<li><p>当不存在定址和变址寄存器的时候，简写为 <code>IMM</code>。这个时候相当于不经过寄存器直接指定主存中的某一个地址，称为<strong>绝对寻址</strong>。</p></li>
<li><p>当 <code>IMM</code> 为 <code>0</code>，不存在变址寄存器的时候，简写为 <code>(a)</code>。这也就是最简单的寻址方式，即直接将寄存器数值作为地址解读，称为<strong>间接寻址</strong>。</p></li>
<li><p>当存在变址寄存器但 <code>s</code> 为 <code>1</code> 的时候，简写为 <code>IMM(a, b)</code>。</p></li>
</ul>
<hr />
<p>现在我们就可以尝试解读一些汇编代码了，比如：</p>
<figure class="highlight plaintext"><figcaption><span>X86-64 Assembly</span></figcaption><table><tr><td class="code"><pre><span class="line">movq $-147, (%rax)</span><br></pre></td></tr></table></figure>
<p>这个指令的意思是按照四字数据转移的方式，将立即数 <code>-147</code> 写入主存，写入地址为寄存器 <code>%rax</code> 的数值。</p>
<h3 id="利用寻址进行整数计算">利用寻址进行整数计算</h3>
<p>地址实际上也可以被解读为整数，而机器进行寻址的时候实际上就在完成整数计算。根据上面给出的变址寻址方式，我们可以利用寻址命令来计算类似 <span class="math inline">\(x + ky\)</span> 的整数算式。</p>
<p>首先需要知道指令：</p>
<figure class="highlight plaintext"><figcaption><span>X86-64 Assembly</span></figcaption><table><tr><td class="code"><pre><span class="line">leaq [SRC], [DEST]</span><br></pre></td></tr></table></figure>
<p>这里 <code>[SRC]</code> 是一个寻址表达式，其计算出来的结果将赋给 <code>[DEST]</code>。比如 <code>leaq (%rdi, %rdi, 2), %rax</code> 会将前面寻址计算出来的地址赋予寄存器 <code>%rax</code>。</p>
<p>实际上在编译器优化之中，部分整数运算都会被优化为地址计算。比如说 <code>x * 12</code> 这个代码有可能会被转化为如下的汇编代码：</p>
<figure class="highlight plaintext"><figcaption><span>X86-64 Assembly</span></figcaption><table><tr><td class="code"><pre><span class="line">leaq (%rdi, %rdi, 2), %rax</span><br><span class="line">salq $2, %rax</span><br></pre></td></tr></table></figure>
<p>第一步使用地址计算实际上计算了 <code>x + x * 2</code>，即三倍的 <code>x</code>。第二步命令为左移，左移两位即再次乘以 <code>4</code> 得到最后结果。</p>
<h2 id="汇编语言常用的整数计算命令">汇编语言常用的整数计算命令</h2>
<p>汇编语言计算整数运算的时候，会有如下表所列出的常用命令。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">命令格式</th>
<th style="text-align: center;">等价的 C 代码</th>
<th style="text-align: center;">备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>addq [SRC], [DEST]</code></td>
<td style="text-align: center;"><code>DEST = DEST + SRC</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>subq [SRC], [DEST]</code></td>
<td style="text-align: center;"><code>DEST = DEST - SRC</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>imulq [SRC], [DEST]</code></td>
<td style="text-align: center;"><code>DEST = DEST * SRC</code></td>
<td style="text-align: center;">结果取较低的 64 位截断</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>salq [SRC], [DEST]</code></td>
<td style="text-align: center;"><code>DEST = DEST &lt;&lt; SRC</code></td>
<td style="text-align: center;">与逻辑左移 <code>shll</code> 等价</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>sarq [SRC], [DEST]</code></td>
<td style="text-align: center;"><code>DEST = DEST &gt;&gt; SRC</code></td>
<td style="text-align: center;">算术右移</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>shrq [SRC], [DEST]</code></td>
<td style="text-align: center;"><code>DEST = DEST &gt;&gt; SRC</code></td>
<td style="text-align: center;">逻辑右移</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>xorq [SRC], [DEST]</code></td>
<td style="text-align: center;"><code>DEST = DEST ^ SRC</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>andq [SRC], [DEST]</code></td>
<td style="text-align: center;"><code>DEST = DEST &amp; SRC</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>orq [SRC], [DEST]</code></td>
<td style="text-align: center;"><code>DEST = DEST | SRC</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>incq [DEST]</code></td>
<td style="text-align: center;"><code>DEST = DEST + 1</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>decq [DEST]</code></td>
<td style="text-align: center;"><code>DEST = DEST - 1</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>negq [DEST]</code></td>
<td style="text-align: center;"><code>DEST = -DEST</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>notq [DEST]</code></td>
<td style="text-align: center;"><code>DEST = ~DEST</code></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h1 id="条件码与其应用">条件码与其应用</h1>
<p>当程序运行的时候，部分和当前程序运行状态相关的数据将会被 CPU 保存。我们已经介绍过指向下一条指令的程序计数器 <code>%rip</code>，存储临时数据的寄存器堆。另外我们要提到的是被保留的寄存器 <code>%rsp</code> 其用于存储<strong>栈顶地址</strong>。另外提一下条件码，条件码一般分为四个：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">条件码标记</th>
<th style="text-align: center;">名称</th>
<th style="text-align: center;">备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>CF</code></td>
<td style="text-align: center;">Carry Flag</td>
<td style="text-align: center;">进位标记</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>ZF</code></td>
<td style="text-align: center;">Zero Flag</td>
<td style="text-align: center;">运算数为零标记</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>SF</code></td>
<td style="text-align: center;">Sign Flag</td>
<td style="text-align: center;">运算数符号标记</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>OF</code></td>
<td style="text-align: center;">Overflow Flag</td>
<td style="text-align: center;">补码运算溢出标记</td>
</tr>
</tbody>
</table>
<p>条件码一般是由算术指令运算过程中隐含地设定的，具体如何设定条件码需要查看具体的命令运行方式。这里额外指出，<strong><code>leaq</code> 指令计算的时候不设置条件码</strong>。</p>
<h2 id="推知操作数关系">推知操作数关系</h2>
<p>若干以 <code>set</code> 为前缀的命令可以读取条件码的内容并存入某寄存器的最低位字节（使用字节操作）。比如说 <code>setle</code> 命令实际上会读取 <code>SF, OF, ZF</code> 三个条件码，将 <code>(SF ^ OF) | ZF</code> 的计算结果存入指定字节。</p>
<p>这个计算结果其实就代表了两个操作数之间的一个关系。比如说 <code>cmpq [SRC], [DEST]</code> 指令在 <code>SRC == DEST</code> 的时候会将 <code>ZF</code> 置真，在 <code>DEST - SRC &lt; 0</code> 的时候将 <code>SF</code> 置真，在运算溢出的时候将 <code>OF</code> 置真。那么 <code>setle</code> 所计算的结果为真实际上就代表 <code>DEST &lt;= SRC</code>。</p>
<p>这里给出具体示例，比如以下 C 语言代码：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gt</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt; y; &#125;</span><br></pre></td></tr></table></figure>
<p>会被汇编为：</p>
<figure class="highlight plaintext"><figcaption><span>X86-64 Assembly</span></figcaption><table><tr><td class="code"><pre><span class="line">cmpq   %rsi, %rdi</span><br><span class="line">setg   %al</span><br><span class="line">movzbl %al, %eax</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>其含义为首先使用 <code>cmpq</code> 命令更新条件码，然后使用 <code>setg</code> 命令读取条件码，最后使用 <code>movzbl</code> 将计算结果移动到表示函数返回值的寄存器。</p>
<h2 id="实现程序跳转">实现程序跳转</h2>
<p>对于 C 语言之中的 <code>if, goto</code> 等涉及到程序跳转的语句，汇编之中也应当有相应的可以跳转执行的命令，而条件码及其相关运算结果会控制程序是否跳转。与 <code>set</code> 系列命令一致，汇编之中还有 <code>j</code> 系列命令，如 <code>je</code>。其会读取条件码并计算，结果为真则会触发程序跳转。</p>
<p>比如这样的 C 代码：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">absdiff</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) result = x - y;</span><br><span class="line">    <span class="keyword">else</span> result = y - x;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>会被汇编为：</p>
<figure class="highlight plaintext"><figcaption><span>X86-64 Assembly</span></figcaption><table><tr><td class="code"><pre><span class="line">absdiff:</span><br><span class="line">    cmpq %rsi, %rdi</span><br><span class="line">    jle  .L4</span><br><span class="line">    movq %rdi, %rax</span><br><span class="line">    subq %rsi, %rax</span><br><span class="line">    ret</span><br><span class="line">.L4:</span><br><span class="line">    movq %rsi, %rax</span><br><span class="line">    subq %rdi, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>这里第三行就会读取 <code>cmpq</code> 命令设置的条件码，如果满足了跳转条件，就会跳转到 <code>.L4</code> 标记处继续执行，否则向下继续执行。</p>
<p>实际上，汇编代码的跳转基本和 C 语言之中的 <code>goto</code> 类似，所以我们可以将 <code>if</code> 转为等价的 <code>goto</code> 表达式，这样的话就可以得到和汇编代码形式类似的 C 代码。对于以下的 C 代码：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (CASE) &#123; <span class="comment">/* IF BLOCK */</span> &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">/* ELSE BLOCK */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>实际上等价于以下 C 代码：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!CASE) <span class="keyword">goto</span> Else;</span><br><span class="line">    <span class="comment">/* IF BLOCK */</span></span><br><span class="line">    <span class="keyword">goto</span> Done;</span><br><span class="line">Else:</span><br><span class="line">    <span class="comment">/* ELSE BLOCK*/</span></span><br><span class="line">Done:</span><br></pre></td></tr></table></figure>
<div class="note info no-icon"><p>使用条件码实现程序跳转的方式称为<strong>条件跳转</strong>。但实际上，条件跳转一般会拖慢整个系统的速度。这是因为现代的流水线式处理器一般要求系统能够基本精确得知接下来应当运行的指令是什么，这样才能保证并发执行，获得高效率。</p>
<p>为了解决这个问题，一种方法是提高处理器对下面具体运行哪一个分支的预测准确率，一种方法是使用<strong>条件转移</strong>。</p>
<p>条件转移指的是将两个分支的结果都计算出来，最后再根据条件码决定取用哪一个。比如说上面的 <code>absdiff</code> 函数，现代编译器一般会把 <code>x - y</code> 和 <code>y - x</code> 都计算出来，最后根据条件码取其中一个放到返回值寄存器上。</p>
<p>但是条件转移的使用是有局限性的，比如说下面两种情况就并不适合：</p>
<ul>
<li><p>某一个分支有副作用，比如说修改了某些其他数据</p></li>
<li><p>某一个分支的计算量过于庞大</p></li>
</ul>
</div>
<p>除去 <code>if</code>，C 语言中还可以使用 <code>switch</code> 语句实现程序跳转。<code>switch</code> 语句可以翻译为若干的 <code>if-else</code> 组，但是更常见的解读方式是<strong>构建跳转表</strong>。</p>
<p><code>TODO</code></p>
<h2 id="实现程序循环">实现程序循环</h2>
<p>C 语言之中使用关键字 <code>do, while, for</code> 可以实现程序循环，同样我们可以使用条件码和 <code>j</code> 系列命令完成等价汇编代码编写，实际上我们只需要改写为等价的 <code>goto</code> 表达的 C 代码就可以。</p>
<p>对于 <code>do ... while</code> 循环，等价改写为：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/* do ... while */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123; <span class="comment">/* CONTENT */</span> &#125; <span class="keyword">while</span> (CASE)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* goto */</span></span><br><span class="line"></span><br><span class="line">Loop:</span><br><span class="line">    <span class="comment">/* CONTENT */</span></span><br><span class="line"><span class="keyword">if</span> (CASE) <span class="keyword">goto</span> Loop;</span><br></pre></td></tr></table></figure>
<p>对于 <code>while</code> 循环，等价改写为：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/* while */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (CASE) &#123; <span class="comment">/* CONTENT */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* goto v1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> Test;</span><br><span class="line">Loop:</span><br><span class="line">    <span class="comment">/* CONTENT */</span></span><br><span class="line">Test:</span><br><span class="line">    <span class="keyword">if</span> (CASE) <span class="keyword">goto</span> Loop;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* goto v2 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!CASE) <span class="keyword">goto</span> Done;</span><br><span class="line">Loop:</span><br><span class="line">    <span class="comment">/* CONTENT */</span></span><br><span class="line"><span class="keyword">if</span> (CASE) <span class="keyword">goto</span> Loop;</span><br><span class="line">Done:</span><br></pre></td></tr></table></figure>
<p>而 <code>for</code> 循环一般是改写为等价的 <code>while</code> 循环后再改写为 <code>goto</code> 版本：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/* for */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="comment">/* INIT */</span>; CASE; <span class="comment">/* UPDATE */</span>) &#123; <span class="comment">/* CONTENT */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* while */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* INIT */</span></span><br><span class="line"><span class="keyword">while</span> (CASE) &#123;</span><br><span class="line">    <span class="comment">/* CONTENT */</span></span><br><span class="line">    <span class="comment">/* UPDATE */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="函数调用与程序栈">函数调用与程序栈</h1>
<h2 id="程序栈和相关指令">程序栈和相关指令</h2>
<p>X86 系统中，将一片内存区域按照栈的方式管理，其中<strong>高地址为栈底</strong>，这片内存区域就被称为<strong>程序栈</strong>，其栈顶地址由寄存器 <code>%rsp</code> 管理。</p>
<p>对程序栈有两种最为基本的操作，即压栈和出栈。压栈操作命令为 <code>pushq [SRC]</code>，含义是将 <code>[SRC]</code> 写入程序栈，寄存器 <code>%rsp</code> 减小一个字节（即减去 <code>8</code>）。而出栈命令为 <code>popq [DEST]</code>，含义是将程序栈栈顶字节写入 <code>[DEST]</code>，寄存器 <code>%rsp</code> 增加一个字节（即加上 <code>8</code>）。</p>
<h2 id="函数调用">函数调用</h2>
<p>有关函数调用的两个命令为 <code>call</code> 和 <code>ret</code>，两者分别代指调用某一个函数和某一个函数返回。</p>
<p><strong>注解：</strong>似乎在汇编之中，更习惯把函数调用说成过程调用，我们之后也使用这样的名称。</p>
<p><code>call</code> 的命令格式为 <code>callq 40050 &lt;mul&gt;</code>。两个参数分别为需要调用的过程的机器码在主存里的位置，系统根据这个参数令程序指针 <code>%rip</code> 跳转。第二个参数则是调用的过程的名称。</p>
<p><code>call</code> 命令一共会完成两个任务。第一个任务是将<strong>返回地址</strong>（返回地址指的是 <code>call</code> 指令<strong>下一条</strong>指令的地址）压入程序栈，这一步是为了在调用的过程终结返回的时候能够返回到正确的位置继续执行。第二个任务是将 <code>%rip</code> 设置为要跳转的过程在主存之中的地址，实现真正的跳转。</p>
<p>而 <code>ret</code> 命令所完成的就是将程序栈的栈顶写入 <code>%rip</code>，让系统回到原先位置继续执行。其不需要接受参数，一般只需要命令本身即可。</p>
<hr />
<p>有的时候调用过程需要传递参数。在 X86 架构之下，如果传递参数不多于 6 个，则使用 <code>%rdi, %rsi, %rdx, %rcx, %r8, %r9</code> 一共 6 个寄存器进行传递。如果参数多余 6 个，则使用程序栈传递，序号越大的参数越在栈底。而函数返回值默认存放在 <code>%rax</code> 之中。</p>
<h2 id="栈帧">栈帧</h2>
<p>类似 C 之类的语言，会支持函数的递归调用，这就说明了这些语言的代码支持<strong>重入（Reentrant）</strong>，即允许多个实例同时运行同一块代码。基于这样的要求，我们不仅需要在程序栈之中记录返回地址，我们还需要记录是哪一个实例调用了过程。而每一次过程调用就会在程序栈之中生成一片用于记录这次调用的数据（包括这一次调用的临时变量、返回地址、寄存器副本等），这就是一个<strong>栈帧（Stack frame）</strong>。</p>
<p>栈帧的管理也是简单的，在过程被调用的时候分配空间、创建栈帧，在过程返回之后，该栈帧被释放。由于栈帧一般多于一个字节，所以除去栈顶指针 <code>%rsp</code> 外，还设定了栈帧指针 <code>%rbp</code> 标记栈帧的起始地址，所以 <code>%rbp</code> 和 <code>%rsp</code> 之间的程序栈指代栈顶的栈帧。</p>
<hr />
<p>另外我们也需要指出，有的时候系统会做出一些“明明没有分配栈帧（<code>%rsp</code> 没有动）但相当于创建了临时栈帧”的行为。一种可能是使用栈空间进行数据传递，这个时候栈就类似于寄存器。比如说系统可以在不动 <code>%rsp</code> 的条件下将数据通过比 <code>%rsp</code> 低一个字节的位置传递一定的数据。但栈空间的也是有限制的，比 <code>%rsp</code> 低多于 128 字节的栈空间一般是被保留的，不能直接使用。</p>
<h2 id="寄存器使用惯例">寄存器使用惯例</h2>
<p>在一个过程调用另外一个过程的时候，往往会出现寄存器冲突，比如说两者都需要使用 <code>%rdi</code> 存放参数。这个时候一般需要将寄存器数据复制到栈帧之中暂且保存，将寄存器空出给另外一方使用。</p>
<p>而到底由调用者还是被调用者的栈帧暂存寄存器，则一般遵循一些惯例。在 X86 架构下寄存器 <code>%rbx, %rbp, %r12, %r13, %r14, %r15</code> 称为<strong>被调用者保存（Callee saved）</strong>寄存器，即被调用者的栈帧保存这些寄存器的数据，在<strong>过程返回之前将栈帧数据复原</strong>。寄存器 <code>%r10, %r11</code> 和所有的传递参数的寄存器称为<strong>调用者保存（Caller saved）</strong>寄存器，即调用者的栈帧保存寄存器的数据，在<strong>调用结束后将栈帧数据复原</strong>。</p>
<h1 id="数组及结构的存储表示">数组及结构的存储表示</h1>
<h2 id="数组的存储">数组的存储</h2>
<p>数组 <code>T a[N]</code> 在主存之中存储的基本原则为连续存储，也就是将连续 <code>N * sizeof(T)</code> 字节的空间用于存储这个数组。</p>
<p>而对于二维数组，我们还是会使用连续的存储空间进行存储，而且一般遵循<strong>行优先</strong>原则。对于 <code>int a[3][5]</code>，其在主存之中的存储顺序为 <code>a[0][0], a[0][1], ..., a[0][4], a[1][0], ..., a[2][4]</code>。这种存储方式称为<strong>嵌套数组（Nested array）</strong>。</p>
<p>除了嵌套数组，还有一种存储方式是<strong>多级指针数组（Multi-level pointer array）</strong>。其基本想法为在根数组上存若干指针，这些指针指向下一级数组的起始地址。这样的存储方式方便进行多级扩展，但相应的由于内存空间不连续，而且读取指针并定位需要多次寻址，一定程度上降低了效率。</p>
<h2 id="结构的存储">结构的存储</h2>
<p>一个结构体的数据是将其成员按照声明顺序，在一片连续的空间内存储的。比如说：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>[<span class="number">4</span>] val;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其将会在连续的 32 个字节中存储这个结构体，其中低地址的 16 字节存放 <code>val</code>，中间的 8 字节存放 <code>i</code>，高地址的 8 字节存放 <code>next</code>。</p>
<p>而在实际存储的时候是需要考虑<strong>对齐</strong>问题的：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">align</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> val;</span><br><span class="line">    align* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果按照正常思维推测，一个字符和一个指针应该只需要 9 字节，但在 X86-64 架构下，实际上会占用 16 字节，其中低地址的 8 字节仅有最低一个字节存储了 <code>val</code>，而剩余的为占位符。</p>
<p>原因是简单的，现代的 CPU 在从主存之中读取数据的时候是同时读取多个，比如说一次性读取 8 个字节。实际上这种读取方式就将每 8 个字节的存储空间划分为了一个机器字（机器字的定义见 <a href="#机器字和字节序">绪论</a>），如果数据在同一个机器字之中，那么一次读取就可以将所有数据读出来。但如果数据跨越了两个机器字，那么就需要两次读取。</p>
<p>所以说编译器会故意在存储结构的空间内部塞入若干的空白空间让每一个成员的数据不跨越机器字以保证读取效率。</p>
<p>另外我们也注意到，变量的声明顺序实际上会影响具体的空间分配。比如说：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    S1* next;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    S2* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里，结构 <code>S1</code> 占用 24 字节，而结构 <code>S2</code> 占用 16 字节。这是因为 <code>S1</code> 在存放 <code>a</code> 后不得不空出 7 字节，否则 <code>next</code> 就会跨机器字。而 <code>S2</code> 中可以先把 <code>a, b</code> 都放置好之后，只需要空出 6 字节就可以让 <code>next</code> 不跨机器字。</p>
<h2 id="联合数据的存储">联合数据的存储</h2>
<p>联合数据类型可以定义多个成员，但是一个联合数据类型的变量在任何时候只能指代某一个成员。这些成员享有同一片存储空间，而联合所占据的空间即其中最大成员占据的空间。比如说：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">U1</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>[<span class="number">2</span>] i;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">double</span> v;</span><br><span class="line">&#125; *p;</span><br></pre></td></tr></table></figure>
<p>这里联合的三个成员分别应该占用 1 字节、 8 字节、 8 字节，所以最后联合占据 8 字节。</p>
<h1 id="程序的链接">程序的链接</h1>
<h2 id="链接的基本概念">链接的基本概念</h2>
<p>多个源代码文件编译成为可执行文件的时候需要经过一个重要过程，即<strong>链接（Linking）</strong>，含义就是将各个独立的文件链接为单一的最终文件。这样做的好处是，某一个文件发生修改，只需要对这个文件编译并重新链接即可，不需要再次编译其他文件。同时，一些常用函数可以事先编译为一个库，需要使用的时候再将其链接进入最后的可执行文件即可。</p>
<p>链接之前，编译器首先会将每一个源代码文件之中每一个符号存储起来，存储的内容包括符号名称、其占据的内存大小和其在主存之中的地址，这就构成了<strong>符号表（Symbol table）</strong>。随后链接器将所有源代码文件综合为单个文件后，会将符号表之中的地址更新为绝对地址。</p>
<h2 id="elf-格式和符号分析">ELF 格式和符号分析</h2>
<p>可以被链接的文件一般有<strong>可重定向对象文件</strong>和<strong>共享对象文件</strong>，前者扩展名通常为 <code>.o</code>，后者则多为 <code>.dll / .so</code>。后者是特殊类型的重定向对象文件，可以被装载入内存后进行动态链接，其链接可以在装载时或者运行时完成。上述两种文件以及可执行文件，这三种二进制文件都必须要符合 <strong>ELF（Executable &amp; Linkable Format）</strong>格式。</p>
<p>ELF 格式的文件依次具有以下的部分：</p>
<ul>
<li><p>ELF header 部分。这一部分会存储与这个文件相关的基本信息。</p></li>
<li><p>Segment header table。这一部分只有可执行文件具有，会存储一些和可执行相关的内容。</p></li>
<li><p><code>.text</code> 部分。这一部分存储代码。</p></li>
<li><p><code>.rodata</code> 部分。这一部分存储只读数据，比如说跳转表。</p></li>
<li><p><code>.data</code> 部分。这一部分存储初始化过的全局变量。</p></li>
<li><p><code>.bss</code> 部分。这一部分存储未初始化的全局变量。</p></li>
<li><p><code>.symtab</code> 部分。这一部分存储符号表。</p></li>
<li><p><code>.rel.text</code> 部分。这一部分是 <code>.text</code> 部分的重定向信息。</p></li>
<li><p><code>.rel.data</code> 部分。这一部分是 <code>.data</code> 部分的重定向信息。</p></li>
</ul>
<p>后续还有一些部分，这里暂且不用讨论。</p>
<p>这里可以提一下 <code>.bss</code> 区设立的原因。<code>.bss</code> 区域的数据不会存储数据类型，并且会默认将这一部分数据的每一个字节全部置 <code>0x00</code>，作为系统默认的初始化。这样做显然要比既要存储数据类型，又要存储数据初始值的 <code>.data</code> 区高效。而能够这样粗暴解决问题的原因是系统约定了非静态全局变量的默认初始化方式为全 <code>0</code>，以及汇编并不区分各种不同的数据类型。</p>
<hr />
<p>在叙述链接过程之前，我们首先要叙述符号的概念。一个程序之中的符号分为三类，即<strong>全局符号</strong>、<strong>局部符号</strong>和<strong>外部符号</strong>。注意，这里全局符号和局部符号的区别不是全局变量和局部变量的区别。局部符号指的是在该模块定义且只可以让该模块引用的符号，包括静态和非静态的局部变量、静态函数和静态全局变量。而全局符号则是可以供给其他模块使用的符号，包括非静态的全局变量和函数。</p>
<p>首先说外部符号，其含义很简单，就是引用的其他模块的符号。包括其他模块开放的非静态全局变量和函数。可以用 <code>extern</code> 关键字声明外部符号，即声明该符号将会在链接的时候再具体给出定义，本文件只是做一个引用。</p>
<p>程序中定义的非静态局部变量，链接器并不会分析。非静态局部变量将会在运行的时候被存储在程序栈之中，使用完立刻释放。</p>
<p>而静态局部变量会被存放在可重定向文件之中的 <code>.data</code> 或者 <code>.bss</code> 部分。对于命名冲突的静态局部变量，编译的时候会给他们赋予后缀以示区分。</p>
<p>对于静态的全局变量和函数，其实际上是局部符号（<code>static</code> 关键字限制了这些变量和函数只能在本模块之中使用），所以其存放在可重定向文件之中的 <code>.data, .bss, .text</code> 部分。其中函数存放在 <code>.data</code> 部分。而如果多个文件中声明了同名的静态全局变量和函数，并不会冲突。</p>
<p>非静态的全局变量和函数一般也是存放在 <code>.data, .bss, .text</code> 部分。这个时候也有可能出现命名冲突，但此时必须作出区分。此时需要引入<strong>强符号（Strong symbol）</strong>和<strong>弱符号（Weak symbol）</strong>的定义。这个定义只对非静态的全局变量和函数成立，其中未被初始化的非静态全局变量被称为弱符号，否则是强符号。</p>
<p>链接器的原则是：</p>
<ul>
<li><p>不允许出现强符号命名冲突，否则链接失败。</p></li>
<li><p>有强符号和弱符号的命名冲突则将弱符号的指代指向强符号（强制覆盖弱符号）。</p></li>
<li><p>弱符号之间的命名冲突，则任取其中之一作为代表，其余弱符号指向被选中的弱符号。</p></li>
</ul>
<p>由于存在强制覆盖，我们应当减少全局变量的使用，或者使用静态的全局变量。如果需要使用，尽量将其初始化变为强符号。并且在使用其他模块的全局变量的时候，尽量先使用 <code>extern</code> 关键字声明这个变量。</p>
<h2 id="代码和数据重定向">代码和数据重定向</h2>
<p>在处理完毕符号后，就可以开始链接了。现在有若干的可重定向对象文件，其中 <code>.text</code> 部分存储着代码，<code>.data</code> 部分存储着变量数据。这些文件的代码之中可能包含着函数调用，而我们知道函数调用需要知道函数在内存之中的位置。编译器在编译生成可重定向对象文件的时候有两个重要信息是不了解的：</p>
<ul>
<li><p>这个模块之中的函数最终会被存放在内存的什么地方。</p></li>
<li><p>这个模块所引用的其他模块的函数的地址是什么。</p></li>
</ul>
<p>针对第一个问题，编译器会存放<strong>相对地址</strong>，也就是这个模块之中的所有函数的地址都是相对于这个模块而言的，而不能表示最后的绝对地址。针对第二个问题，编译器可能会选择将地址留空，比如使用 <code>0x00</code> 留空，之后会在 <code>.rel.data</code> 或者 <code>.rel.text</code> 部分留下信息告诉链接器要补全这里的地址。</p>
<p>到这里，编译器的任务就完成了，接下来链接器会修正相对地址并填充留空地址。</p>
<p>首先链接器会将所有可重定向对象文件的 <code>.data</code> 部分拼接为可执行文件的 <code>.data</code> 部分，<code>.text</code> 部分也如此。拼接完成后，所有函数和全局变量的绝对地址就确定了，链接器会将所有需要调整的相对地址调整为目前的绝对地址，并填充留空地址。</p>
<h2 id="库链接">库链接</h2>
<p>我们提到过，一些常用函数会被事先编译为可重定向对象文件，在使用的时候再链接进入程序。但是一般而言这样的函数库是很大的，如果完全链接进入，则相当消耗时间空间。所以有另外一个解决方案，就是将每一个函数都打包为可重定向对象文件，然后把这些可重定向对象文件打包为<strong>静态库文件</strong>，也称<strong>归档文件（Archive file）</strong>。归档文件的扩展名常常为 <code>.a</code>。</p>
<p>归档文件之中每一个可重定向对象文件是具有索引的，基于此，我们让链接器能够在用户编写的代码之中解析外部符号，并且能够在静态库之中寻找出相应的可重定向对象文件进行链接。</p>
<p>现代的静态库一般允许增量更新。</p>
<p>静态库的缺点在于可执行文件以及运行时内存之中会重复包含库文件函数和数据，同时如果库文件发生变动，则所有的相关文件都需要重新链接。目前已有的解决方式是使用<strong>共享库文件</strong>，其特征在 <a href="#elf-格式和符号分析">ELF 格式和符号分析</a> 部分已经说明。</p>
<h1 id="内存布局与缓冲区">内存布局与缓冲区</h1>
<p>在 X86-64 架构下，主存的最高地址部分是程序栈，其栈顶由 <code>%rsp</code> 管理，且栈空间向低地址增长。程序栈一般具有 8MB 的空间限制。程序栈用于存放局部变量等数据。</p>
<p>之后就是分配给每一个任务的存储空间，每一个任务都会在主存之中占用一片空间，这片空间从高地址到低地址的分配为：</p>
<ul>
<li><p>堆。堆空间可以根据程序需要动态分配，如 C 语言的 <code>malloc</code> 函数。堆空间向高地址增长。</p></li>
<li><p>静态数据。这一部分数据会在将可执行文件加载到主存的时候写入内容，写入的内容就是可执行文件的 <code>.data</code> 部分，称为<strong>数据段</strong>。</p></li>
<li><p>机器代码。这一部分就是可执行文件的 <code>.text</code> 部分，称为<strong>代码段</strong>。</p></li>
</ul>
<p>而程序栈的构成，先前已经叙述过。即分为若干的栈帧，其中栈帧高地址的 8 字节存放这个栈帧的返回地址，剩余的部分存放临时变量等数据。</p>
<hr />
<p>这个时候就可以引入缓冲区溢出攻击了。这个攻击利用的是类似 <code>gets()</code> 等不限制读入长度的函数，可能会越过预留空间对程序栈进行非法写入的漏洞。</p>
<p>比如说函数 <code>foo()</code> 之中调用了 <code>gets()</code>：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">gets</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而函数 <code>foo()</code> 执行的时候是会分配一个栈帧给这个函数存放 <code>buf</code> 这个临时变量的。但是由于 <code>gets()</code> 不限制读入长度，所以我们可以输入相当长的字符串，这样的话就会一直向栈帧的高地址写入，从而会覆写掉返回地址，甚至是上一个函数的栈帧。这样，在 <code>foo()</code> 结束进行返回的时候，就可以控制其跳转到指定的位置执行我们注入的程序。</p>
<p>防御这种攻击的方法也很多。一种是使用可以限制读入长度的函数，如 <code>fgets()</code>。一种是给栈内部加入随机长度的无意义数据，让攻击方无法准确预测 PC 应当跳转到何处。还有比如说可以限制执行权限，让这一片区域的内存不能作为机器指令执行。此外还可以让函数在返回之前检查栈帧是否被修改等等。</p>
<h1 id="x86-汇编编程基础">X86 汇编编程基础</h1>
<p><code>TODO</code></p>
<h1 id="异常">异常</h1>
<h2 id="基本原理">基本原理</h2>
<p><strong>异常（Exception）</strong>指的是会阻止程序正常执行，并且会引起状态切换（比如从用户态切换到内核态）的事件。异常分为同步异常和异步异常。</p>
<p>同步异常一般有三种，即 <strong>Trap</strong>、<strong>Fault</strong> 以及 <strong>Abort</strong>。其中，Trap 一般是由程序主动触发的，比如说产生了系统调用 syscall，或者是触发了断点或者是使用了 Trap 命令，其恢复之后会跳转到原命令的下一条继续执行。Fault 往往是由程序出现的一些问题触发的，一般这种问题都是可以恢复的，恢复之后会重新执行原命令。Abort 则是由不可恢复的问题触发的异常，会引起程序退出。</p>
<p>异步异常则一般由外部事件触发，比如说 IO 设备中断，发生系统重置等等。一般而言，在 MIPS 架构下，如果发生的时候命令已经执行完毕 MEM 阶段，系统会保证这条命令的流水线执行完毕。否则这条流水线会被废弃。这里有关 MIPS 流水线的叙述可以查看下面的 MIPS32 基础。</p>
<h1 id="虚拟内存">虚拟内存</h1>
<h2 id="基本原理-1">基本原理</h2>
<p>我们先前提到过，每一个进程都会分配到一片内存空间，用于存放数据段、代码段并且分配堆空间。但是我们也会注意到，有的进程用不到如此大的内存空间，很容易出现分配了空间但几乎不可能使用的现象。这个问题的一个解决方案是<strong>虚拟内存（Virtual memory）</strong>，其相当类似于懒分配，即真正使用到某一块内存的时候再进行分配。</p>
<p>虚拟内存的工作原理大致为，对于每一个新进程，会分配连续的虚拟内存空间。进程使用到某一个存储地址的时候，处理器会去虚存地址和物理内存地址对照表（这个表一般称为<strong>页表（Page table）</strong>，并且每个进程都会有自己的页表）之中寻找这个虚拟内存地址所对应的真实地址，如果发现还没有给这个虚存地址分配物理内存空间，则会分配并建立两者之间的映射。</p>
<p>虚拟内存地址通常简称为<strong>虚址（Virtual address）</strong>。上述过程中负责将虚址转换为物理地址的单元称为<strong>内存管理单元（MMU）</strong>。</p>
<h2 id="页和页缺失">页和页缺失</h2>
<p>一般而言，我们会将一片固定大小的连续虚存集合起来成为一个<strong>页（Page）</strong>，而每一个虚存的页映射到物理地址空间也是一片连续的空间，这被称为<strong>页帧（Page frame）</strong>。相对应的页和页帧具有相同的大小。MMU 进行地址映射的时候都是以页为单位的。</p>
<p>基于页的结构，处理器实际上传输给 MMU 进行转换的虚地址可以分为两个部分。前半部分为<strong>虚页码（Virtual page number / VPN）</strong>，后半部分是<strong>页内偏置（Page offset）</strong>。虚页码指明了虚存之中我需要映射的字节位于具体哪一页，而页内偏置则表明了我需要映射的字节在页内是第几个字节。</p>
<p>MMU 所进行的页码映射就是将虚页码根据页表映射为<strong>物理页码（Physical page number / PPN）</strong>，之后根据页内偏置获取最后实际的数据。</p>
<p>如果某次映射之中，某个页没有找到对应的页帧，就会触发<strong>页缺失（Page fault）</strong>。页缺失产生后，系统会转入内核态，调用异常处理代码将所需要的数据从外部存储读入内存以解决异常。</p>
<h2 id="页表项的附加标记">页表项的附加标记</h2>
<p>采用虚存机制还有一种好处，就是可以通过页表实现权限管理。页表之中的每一项除去记录页和页帧的映射之外，还可以记录这个进程对物理内存的访问权限，权限控制的具体实现则由硬件完成。</p>
<p>另外，页表项还可以记录目前这个映射是否成立，这一位也常常被称为 valid 位。其为 <code>1</code> 则说明对应的页帧已经被加载到物理内存之中，否则代表对应的页帧还需要从外部存储之中获取。页缺失就会在 valid 位为 <code>0</code> 的时候发生。</p>
<h2 id="快表机制">快表机制</h2>
<p>记住这一句话就可以了：</p>
<div class="note info no-icon"><p>快表（TLB）和页表的关系，就是缓存（Cache）和内存的关系。</p>
</div>
<p>TLB 相当于页表的一个高速缓存，其出现的原因是处理器所请求的内存地址往往是聚集的，也就是说某一小部分地址占据了处理器的大部分请求。所以这个时候我们可以将常用地址缓存到 TLB 之中，请求内存的时候首先查询 TLB 有无相关映射，命中则直接使用。否则再去页表之中查找，命中则直接使用，同时将这个映射缓存到 TLB 之中。TLB 满了之后会触发淘汰机制，删去使用较少的映射项。</p>
<p>之所以提到缓存，因为内存之中的常使用部分会被加载到 cache 之中。而系统从 MMU 获取物理地址之后也会先去 cache 之中查找，找不到才会去内存之中查找。这个过程和 TLB 机制几乎一致。</p>
<h2 id="内存映射">内存映射</h2>
<p><code>TODO: We may learn it later from OS class.</code></p>
<h1 id="mips32-基础">MIPS32 基础</h1>
<p>MIPS 架构的特征可以查看本文最开头的部分，有较为详细的介绍。</p>
<p>这里补充一些其他的 MIPS 基础知识。这些知识并不是重点，但是会影响对 MIPS 架构细节的理解，故不单独开一个二级标题但还是需要分点一条条列出：</p>
<ul>
<li><p>MIPS 架构之中，一个字等于四个字节</p></li>
<li><p>MIPS 架构下返回地址不保存在栈上，而是保存在 31 号寄存器之中</p></li>
<li><p>MIPS 架构下 0 号寄存器永远存储常数 <code>0</code></p></li>
<li><p>MIPS 架构不具有条件码，条件的表示全部使用寄存器</p></li>
<li><p>MIPS32 架构除去 32 个通用寄存器，还有高位寄存器 <code>%hi</code> 以及低位寄存器 <code>%lo</code>。这两者都是 32 位寄存器，其出现的原因是需要处理整数的乘除法。另外需要注意，MIPS32 架构的立即数通常只允许 16 位，而寄存器是 32 位的，所以通常会使用这两个寄存器将 32 位数拆开表示。记号上，<code>%hi($1)</code> 这种写法代表 1 号寄存器的 16 位高位</p></li>
<li><p>MIPS 架构下有四个传参寄存器，即 4 到 7 号寄存器。多余的参数使用栈传递</p></li>
<li><p>MIPS 架构的命令后缀 <code>i</code> 表示立即数，<code>u</code> 表示不启用溢出检测。比如说 <code>addiu</code> 命令表示将某一个寄存器加上一个立即数，溢出的话取模放入结果寄存器</p></li>
</ul>
<h2 id="流水线结构与延迟槽">流水线结构与延迟槽</h2>
<p>在 MIPS 架构之中，任何指令的执行都会分为五个步骤，这五个步骤由不同的硬件完成。这些步骤分别是：</p>
<ul>
<li><p>读取指令（IF）</p></li>
<li><p>读取寄存器（RD）</p></li>
<li><p>代数或逻辑运算（ALU）</p></li>
<li><p>访问内存（MEM）</p></li>
<li><p>回写（WB）</p></li>
</ul>
<p>一个指令的五个执行步骤构成一条<strong>流水线</strong>，而不同指令的流水线是可以并发执行的，只要保证它们不会同时调用某一个硬件资源（比如说两条指令不可以同时在 IF 过程中）。</p>
<p>而这种并行的流水线架构的优越之处就是可以最大程度利用硬件资源。比如说考虑这样的 MIPS 汇编代码：</p>
<figure class="highlight plaintext"><figcaption><span>MIPS32 Assembly</span></figcaption><table><tr><td class="code"><pre><span class="line">jal  printf</span><br><span class="line">move $4, $6</span><br><span class="line">op</span><br></pre></td></tr></table></figure>
<p>这里 <code>jal</code> 类似于 X86 的 <code>call</code> 命令，用于调用过程。但是，与这条指令间隔一条的 <code>op</code> 指令才是 <code>printf</code> 返回后调用的指令（返回地址）。</p>
<p>原因是 <code>jal</code> 指令流水线执行到 ALU 阶段的时候才会发生实质跳转，从 <code>jal</code> 的 IF 阶段结束到实质跳转这段时间 IF 硬件是空闲的，这段时间就被称为<strong>延迟槽（Delay slot）</strong>。但是我们可以让 IF 硬件立刻执行 <code>move $4, $6</code> 的 IF 阶段，这样在实质跳转发生前的这段延迟槽就被利用了。</p>
<p>能这样做的原因是 <code>move</code> 指令在 RD 阶段结束后就执行完毕了，后续的阶段可以忽略或者说当成不存在。如果说 <code>jal</code> 命令之后跟随了一些需要实质 ALU 的命令，则可能会因为和 <code>jal</code> 或者所调用的过程发生硬件冲突而导致异常。所以有的时候我们可以填入 <code>nop</code> 回避掉可能的问题。</p>
<h2 id="多线程操作">多线程操作</h2>
<p>在多线程编程之中，我们往往会涉及到多个线程对共享资源的读写操作。在 MIPS 架构中，针对这个场景，有 <code>ll</code> 和 <code>sc</code> 两个命令。</p>
<p><code>ll</code> 全称为<strong>链接加载（Load linked）</strong>，在使用这个命令从内存之中加载数据之后，处理器会记住这一次操作，这一次操作访问的地址也会被暂时保存。</p>
<p><code>sc</code> 全称为<strong>条件存储（Store conditional）</strong>，使用这个命令将寄存器 <code>v</code> 之中的数据存储到内存的时候，处理器会首先检查上一次 <code>ll</code> 命令操作的内存区域有没有被改动。如果没有被改动过，则存储成功，<code>v</code> 之中的值也会被写为 <code>1</code> 表示操作成功。反之，写入失败，内存不会被修改，<code>v</code> 之中的值也会被写为 <code>0</code> 表示操作失败。</p>
<h2 id="协处理器与异常处理">协处理器与异常处理</h2>
<p>协处理器是用于协助处理器处理类似内存管理、内存映射、异常等工作的硬件，其在可以被认为是一系列拓展寄存器。这里我们主要关注 MIPS 架构下协处理器之中的 Cause 和 Status 寄存器。</p>
<p>MIPS 系统的一个优点就是支持精确异常处理，也就是说保证发生异常的命令之前的所有命令都可以被执行完毕，之后的命令不进行处理。而为了实现这一点，就需要精确记录异常位置，并且处理好延迟槽机制带来的问题。</p>
<p>借助协处理器，MIPS 系统处理异常的步骤大致为：</p>
<ul>
<li><p>保存异常现场信息。协处理器利用<strong>异常程序计数器（Exception program counter / EPC）</strong>记录异常命令的位置，Cause 寄存器会记录异常原因，且其 BD 位会记录延迟槽信息，Status 寄存器的<strong>异常标志位（EXL）</strong>被置 <code>1</code>。另外，一些相关寄存器的值也会被保存，另外 26 和 27 号寄存器会被留给异常处理。</p></li>
<li><p>根据具体类型判定处理异常的方式。这里会使用 Cause 寄存器获取异常类型。</p></li>
<li><p>开辟异常处理内存空间。系统会开辟出空间并且保留一部分通用寄存器用于异常处理。</p></li>
<li><p>处理完毕后返回。此时协处理器清空相关寄存器，跳转到原有命令继续执行。</p></li>
</ul>
<p>这里要注意一点，一般异常处理会在内核态下运行，而正常的程序会在用户态下运行。为了防止异常处理机制被不正当利用于在内核态下执行攻击代码，系统要求状态转换和程序跳转回原有命令必须同时。</p>
<h2 id="mips-内存管理">MIPS 内存管理</h2>
<p>MIPS 使用虚存机制，其虚址一般按照下述方式分配：</p>
<ul>
<li><p>高于 <code>0xC0000000</code> 的虚址为 kseg2 空间，其仅可以由核心态使用，使用的时候需要经过 MMU 转换，也就是说这一部分是 Mapped memory。</p></li>
<li><p>介于 <code>0xA0000000</code> 和 <code>0xC0000000</code> 之间的虚址是 kseg1 空间，其不可以在用户态下使用，使用的时候不需要经过 MMU 转换（其虚址最高三位清零就是物理地址）。另外，这一部分不会被缓存，也就是说这一部分是 Unmapped uncached memory。</p></li>
<li><p>介于 <code>0x80000000</code> 和 <code>0xA0000000</code> 之间的虚址是 kseg0 空间，其不可以在用户态下使用，使用的时候不需要经过 MMU 转换（其虚址最高一位清零就是物理地址）。另外，这一部分可以被缓存，也就是说这一部分是 Unmapped cached memory。</p></li>
<li><p>低于 <code>0x80000000</code> 的虚址为 kuseg 空间，是用户态空间，使用的时候需要经过 MMU 转换，也就是说这一部分是 Mapped memory。</p></li>
</ul>
<p>这样划分的意图就是区分内核态和用户态对内存的访问。另外，上述划分之中有 unmapped 的内存空间，这一部分设置的缘由是系统刚启动的时候 TLB 并未初始化，不可以进行正常的地址转换，故使用 unmapped 的空间进行操作。</p>
<p>另外，为了区分某虚拟地址属于哪一个进程，MIPS 会给虚拟地址附上 ASID 进程标识符。</p>
<hr />
<p>MIPS 架构支持一种特殊的快表，即 JTLB。其内部记录的是<strong>虚页码除以 2</strong> 之后的结果和<strong>两个</strong>物理页码之间的关系，两个映射项都标注了是否 valid 以及是否允许写入（一般称为是否 dirty，如果一个页面不是 dirty 的，则会禁止写入）。</p>
<p>这个时候的转换需要将虚页码先去掉末位进行查表，最后如果命中，则需要根据虚页码末位选取最终的映射项。</p>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
  </entry>
  <entry>
    <title>《信号处理原理》学习笔记</title>
    <url>/1021/09/14/note-of-dsp/</url>
    <content><![CDATA[<p>一门纯数学课，没有什么特别有意思的地方。但也正因为它是数学课，所以我感觉我学起来会稍微轻松一些，希望是我四大原理之中最舒服的一门课。</p>
<p><span class="math display">\[
\newcommand{\d}{\mathrm{d}}
\newcommand{\j}{\mathrm{j}}
\newcommand{\b}{\boldsymbol}
\newcommand{\lv}{\left[\begin{matrix}}
\newcommand{\rv}{\end{matrix}\right]}
\]</span></p>
<span id="more"></span>
<h1 id="信号处理基本知识">信号处理基本知识</h1>
<p>信号是一种载有信息的物理量，所以可以说信号是信息的表现形式，信息是信号蕴含的内容。我们探测信号的工具称为<strong>传感器（Sensor）</strong>，传感器是将一种物理变化转化为另一种物理变化的装置。比如说为了探测声波，我们可以使用传感器将声波转化为电信号。</p>
<p>通过传感器我们可以将某些难以处理的信号转化为我们易于处理的信号。对信号的处理大致可以分为三类，即<strong>降噪</strong>、<strong>特征抽取</strong>以及<strong>编码解码</strong>。</p>
<p>信号常常使用函数或者序列进行描述，而函数具有图像，所以有的时候信号也会使用具体的图像进行描述。</p>
<hr />
<p>信号可以按照对于给定的自变量能不能得到确定的因变量分类为<strong>确定信号</strong>和<strong>随机信号</strong>。另外，信号 <span class="math inline">\(f(t)\)</span> 也可以按照是否存在 <span class="math inline">\(T &gt; 0\)</span> 满足 <span class="math inline">\(\forall t \in \mathbb R, f(t) = f(t + T)\)</span> 分为<strong>周期信号</strong>和<strong>非周期信号</strong>。</p>
<h2 id="常见信号形式">常见信号形式</h2>
<p><strong>正余弦信号</strong>是最常见的信号形式之一，其数学表达式为：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; f(t) = K \sin(\omega t + \theta) \\
&amp; f(t) = K \cos(\omega t + \theta) \\
\end{aligned}
\]</span></p>
<p>这里 <span class="math inline">\(K\)</span> 表示<strong>振幅</strong>，<span class="math inline">\(\omega\)</span> 表示<strong>角频率</strong>，<span class="math inline">\(\theta\)</span> 表示<strong>初相位</strong>。</p>
<hr />
<p>除去正弦余弦信号，<strong>Sa 信号</strong>也是常见的一种信号形式，其数学表达式为：</p>
<p><span class="math display">\[
{\rm Sa}(t) = \frac{\sin t}{t}
\]</span></p>
<p>这个信号是一个偶函数，其零点构成的集合为 <span class="math inline">\(\{ k\pi \mid k \in \mathbb Z, k \neq 0 \}\)</span>。这个信号的积分性质为：</p>
<p><span class="math display">\[
\int_{-\infty}^{+\infty} {\rm Sa}(t) \d t = \pi
\]</span></p>
<p>这个积分一般被称为 <strong>Dirichlet 积分</strong>，其一种计算方式可以看下列推导。</p>
<p>考虑函数：</p>
<p><span class="math display">\[
F(t) = \int_{0}^{+\infty} \frac{\sin x}{x} e^{-tx} \d x
\]</span></p>
<p>这个函数的导数可以描述为：</p>
<p><span class="math display">\[
\frac{\d F}{\d t} = \frac\d{\d t} \int_{0}^{+\infty} \frac{\sin x}{x} e^{-tx} \d x = \int_{0}^{+\infty} \frac{\partial e^{-tx}}{\partial t} \frac{\sin x}{x} \d x = -\int_{0}^{+\infty} e^{-tx}\sin x \d x
\]</span></p>
<p>进一步：</p>
<p><span class="math display">\[
\begin{aligned}
\frac{\d F}{\d t} &amp;= \int_{0}^{+\infty} e^{-tx} \d \cos x = \left. e^{-tx}\cos x \right|_{0}^{+\infty} + t \int_{0}^{+\infty} e^{-tx}\cos x \d x \\
&amp;= -1 + t \int_{0}^{+\infty} e^{-tx} \d \sin x = -1 + t \left( \left. e^{-tx}\sin x \right|_{0}^{+\infty} + t \int_{0}^{+\infty} e^{-tx}\sin x \d x \right) \\
&amp;= -1 + t^2 \int_{0}^{+\infty} e^{-tx}\sin x \d x = -1 - t^2 \frac{\d F}{\d t}
\end{aligned}
\]</span></p>
<p>也就是说：</p>
<p><span class="math display">\[
\frac{\d F}{\d t} = -\frac{1}{1 + t^2} \Rightarrow F(t) = -\arctan t + C
\]</span></p>
<p>不难得知 <span class="math inline">\(F(+\infty) = 0\)</span>，这就说明 <span class="math inline">\(C = \pi / 2\)</span>，从而 Dirichlet 积分的结果为：</p>
<p><span class="math display">\[
\int_{-\infty}^{+\infty} {\rm Sa}(t) \d t = 2F(0) = \pi
\]</span></p>
<hr />
<p>此外，<strong>指数信号</strong>也较为常见，其数学表达式为：</p>
<p><span class="math display">\[
f(t) = K e^{\alpha t}
\]</span></p>
<p>指数信号的特征就是，其积分或微分后依然是指数信号。</p>
<h2 id="复信号分析">复信号分析</h2>
<p>在分析一般的信号的时候，我们可以常常将其看作某一个复信号的实部或者虚部。比如说考虑复指数信号 <span class="math inline">\(f(t) = K e^{st}\)</span>，这里 <span class="math inline">\(s \in \mathbb C\)</span>。显然有：</p>
<p><span class="math display">\[
f(t) = K e^{[\Re(s) + \j\Im(s)]t} = K e^{(\Re s)t} (\cos(t\Im(s)) + \j\sin(t\Im(s)))
\]</span></p>
<p>这里可以发现，<strong>复指数信号的实部和虚部都是正余弦信号</strong>。</p>
<h2 id="函数空间与函数分解">函数空间与函数分解</h2>
<p>我们继续沿用线性空间的基向量、正交向量组、正交基和标准正交基的概念。现在我们考虑这样的一个线性空间，即定义在 <span class="math inline">\([t_1, t_2]\)</span> 上的可积复函数空间，定义其内积为：</p>
<p><span class="math display">\[
\langle\varphi_1, \varphi_2\rangle = \int_{t_1}^{t_2} \varphi_1(t)\varphi^*_2(t) \d t
\]</span></p>
<p>两函数如果内积为零，则称两函数<strong>正交</strong>。</p>
<p>如果函数 <span class="math inline">\(\varphi_1, \varphi_2, \cdots, \varphi_n\)</span> 满足：</p>
<p><span class="math display">\[
\langle\varphi_i, \varphi_j\rangle = \int_{t_1}^{t_2} \varphi_i(t)\varphi^*_j(t) \d t = \begin{cases}
0 &amp; i \neq j \\
k_i &amp; i = j
\end{cases}
\]</span></p>
<p>这里 <span class="math inline">\(k_i\)</span> 为非零常数。那么这些函数构成<strong>正交函数集</strong>。</p>
<p>称一个正交函数集是完备的，如果不存在一个这个函数集之外的函数 <span class="math inline">\(\psi\)</span> 满足 <span class="math inline">\(0 &lt; \psi \cdot \psi &lt; +\infty\)</span> 且 <span class="math inline">\(\psi\)</span> 和该函数集之中所有函数正交。实际上完备的正交函数集就说明了这个函数集不能容纳更多的成员。</p>
<h1 id="信号的运算">信号的运算</h1>
<h2 id="常规运算">常规运算</h2>
<p>对于信号 <span class="math inline">\(f_1, f_2\)</span>，我们可以仿照函数四则运算的规定来规定其四则运算方式：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; (f_1 + f_2)(t) = f_1(t) + f_2(t) \\
&amp; (f_1 - f_2)(t) = f_1(t) - f_2(t) \\
&amp; (f_1 \cdot f_2)(t) = f_1(t) \cdot f_2(t) \\
&amp; \left(\frac{f_1}{f_2}\right)(t) = \frac{f_1(t)}{f_2(t)}
\end{aligned}
\]</span></p>
<p>另外，我们还可以对信号进行波形变换。常见的变换包括<strong>平移变换</strong>、<strong>反褶变换</strong>、<strong>压扩变换</strong>。</p>
<p>考虑平移变换：</p>
<p><span class="math display">\[
\begin{aligned}
f &amp;\mapsto f&#39; \\
f(t) &amp;\to f(t - b)\\
\end{aligned}
\]</span></p>
<p>这个变换可以将信号的波形沿着横轴（时间轴）正向平移 <span class="math inline">\(b\)</span> 个单位。</p>
<p>反褶变换指的是下述的变换：</p>
<p><span class="math display">\[
\begin{aligned}
f &amp;\mapsto f&#39; \\
f(t) &amp;\to f(-t)\\
\end{aligned}
\]</span></p>
<p>这个变换会将信号沿着纵轴翻折。</p>
<p>而压扩变换指的是：</p>
<p><span class="math display">\[
\begin{aligned}
f &amp;\mapsto f&#39; \\
f(t) &amp;\to f(at)\\
\end{aligned}
\]</span></p>
<p>参数 <span class="math inline">\(a\)</span> 控制了压扩的形式。如果 <span class="math inline">\(a &gt; 0\)</span>，则压扩的时候不需要反褶。如果 <span class="math inline">\(a &lt; 0\)</span>，则压扩的时候需要反褶。如果 <span class="math inline">\(|a| &gt; 1\)</span>，则变换是压缩。如果 <span class="math inline">\(|a| &lt; 1\)</span>，则变换是扩张。</p>
<h2 id="积分微分运算与能量">积分微分运算与能量</h2>
<p>对于符合一定条件的信号，我们可以进行微分积分运算，记号为：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \left(\frac{\d}{\d t} f\right)(t_0) = \left.\frac{\d f}{\d t}\right|_{t = t_0} \\
&amp; \left(\int_{-\infty} f \d t\right)(t_0) = \int_{-\infty}^{t_0} f(t) \d t
\end{aligned}
\]</span></p>
<p>基于积分微分运算，我们可以给定信号能量和信号功率的定义。对于连续空间（即定义在全实数上）的信号 <span class="math inline">\(f(t)\)</span>，能量定义为：</p>
<p><span class="math display">\[
E(f) = \int_{-\infty}^{+\infty} \|f(t)\|^2 \d t
\]</span></p>
<p>功率则是能量除以时间，但是考虑到时间范围是无穷大的，所以需要从极限进行定义：</p>
<p><span class="math display">\[
P(f) = \lim_{T\to+\infty}\frac{1}{T}\int_{-T / 2}^{T / 2} \|f(t)\|^2 \d t
\]</span></p>
<p>对于离散空间定义的信号 <span class="math inline">\(f\)</span>，表达类似：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; E(f) = \sum_{n = -\infty}^{+\infty} \|f(n)\|^2 \\
&amp; P(f) = \lim_{N\to\infty}\frac{1}{2N + 1} \sum_{n = -N}^{N} \|f(n)\|^2
\end{aligned}
\]</span></p>
<p>能量有限的信号称为能量有限信号，或在不引起混淆的时候简称<strong>能量信号</strong>。功率有限的信号称为功率有限信号，或在不引起混淆的时候简称<strong>功率信号</strong>。</p>
<h2 id="卷积运算">卷积运算</h2>
<p>对于两个连续时间信号 <span class="math inline">\(f, g\)</span>，定义两者的卷积为：</p>
<p><span class="math display">\[
(f * g)(t) = \int_{-\infty}^{+\infty} f(t - \tau)g(\tau) \d\tau
\]</span></p>
<p>卷积的存在性取决于上述积分是否存在，并且要求积分结果是有限的。</p>
<p>而对于离散的时间信号 <span class="math inline">\(f, g\)</span>，卷积定义为：</p>
<p><span class="math display">\[
(f * g)(n) = \sum_{m = -\infty}^{+\infty} f(n - m)g(m)
\]</span></p>
<p>从几何意义上讲，卷积指的是一个信号的反褶信号在时间轴上滑动的过程中，它与另外一个信号重合部分相乘得到的新信号的面积。</p>
<p>卷积显然符合下述运算律：</p>
<p><span class="math display">\[
\begin{cases}
f_1 * f_2 = f_2 * f_1 \\
f_1 * (f_2 + f_3) = f_1 * f_2 + f_1 * f_3 \\
(f_1 * f_2) * f_3 = f_1 * (f_2 * f_3)
\end{cases}
\]</span></p>
<p>卷积和微分积分运算的关系则为：</p>
<p><span class="math display">\[
\frac{\d}{\d t}(f_1 * f_2) = f_1 * \left(\frac{\d}{\d t} f_2\right) = \left(\frac{\d}{\d t} f_1\right) * f_2
\]</span></p>
<p>以及：</p>
<p><span class="math display">\[
\int_{-\infty} (f_1 * f_2) \d t = f_1 * \left(\int_{-\infty} f_2 \d t\right) = \left(\int_{-\infty} f_1 \d t\right) * f_2
\]</span></p>
<p>对于高阶微分积分，存在下述关系：</p>
<p><span class="math display">\[
(f_1 * f_2)^{(n)} = f_1^{(m)} * f_2^{(n - m)}
\]</span></p>
<p>上标括号中若为正整数，则表示高阶微分。若为负整数，则表示高阶积分。可以发现上述卷积的积分微分运算规律均为该公式的特殊情况。</p>
<h2 id="相关运算">相关运算</h2>
<p>定义两个信号的相关为：</p>
<p><span class="math display">\[
R(f_1, f_2)(t) = \int_{-\infty}^{+\infty} f_1(\tau)f_2^*(\tau - t)\d\tau = \int_{-\infty}^{+\infty} f_1(\tau + t)f_2^*(\tau)\d\tau
\]</span></p>
<p>显然可以注意到：</p>
<p><span class="math display">\[
\begin{cases}
R(f_1, f_2) = \mathcal{R}[R^*(f_2, f_1)] \\
R(f_1, f_2) = f_1 * \mathcal{R}^*[f_2]
\end{cases}
\]</span></p>
<p>这里 <span class="math inline">\(\mathcal{R}\)</span> 表示反褶变换，即 <span class="math inline">\(\mathcal{R}[f](t) = f(-t)\)</span>。</p>
<p>第一条定律说明了相关运算并不是交换的。</p>
<h1 id="常用奇异信号">常用奇异信号</h1>
<p>我们已经介绍过正弦余弦信号、指数信号等常用信号，另外还有一些形式较为特殊的信号称为奇异信号。这些信号的价值一般在于具有一些较为优越的运算特性。</p>
<p>首先介绍<strong>单位斜变信号</strong>，数学形式为：</p>
<p><span class="math display">\[
R(t) := \begin{cases}
0 &amp; t &lt; 0 \\
t &amp; t \geq 0
\end{cases}
\]</span></p>
<p>另外常用的还有<strong>截顶单位斜变信号</strong>：</p>
<p><span class="math display">\[
R_\tau(t) := \begin{cases}
0 &amp; t &lt; 0 \\
t &amp; 0 \leq t &lt; \tau \\
\tau &amp; t \geq \tau
\end{cases}
\]</span></p>
<p>从单位斜变信号衍生得到<strong>单位阶跃信号</strong>：</p>
<p><span class="math display">\[
u(t_0) = \frac{\d R}{\d t}(t_0) := \begin{cases}
0 &amp; t_0 &lt; 0 \\
1 &amp; t_0 \geq 0
\end{cases}
\]</span></p>
<p>进而可以衍生出<strong>单位矩形脉冲信号</strong>：</p>
<p><span class="math display">\[
G_\tau(t) := \begin{cases}
1 &amp; |t| \leq \tau / 2 \\
0 &amp; |t| &gt; \tau / 2
\end{cases}
\]</span></p>
<p>矩形脉冲信号和阶跃信号具有下述的关系：</p>
<p><span class="math display">\[
G_\tau(t) = u\left(t + \frac{\tau}{2}\right) - u\left(t - \frac{\tau}{2}\right)
\]</span></p>
<p>单位矩形脉冲信号的一个重要作用是作<strong>窗函数</strong>以截取某信号的某一段信息。对于信号 <span class="math inline">\(f\)</span>，将其与单位矩形脉冲信号作乘法得到 <span class="math inline">\(G_\tau f\)</span>。该信号仅有 <span class="math inline">\([-\tau / 2, \tau / 2]\)</span> 上的信息被保留，其余均为零。也就是说单位矩形脉冲信号进行了信息截取。</p>
<hr />
<p>单位阶跃信号另外一种衍生是<strong>符号函数信号</strong>：</p>
<p><span class="math display">\[
{\rm sgn}(t) := \begin{cases}
1 &amp; t \geq 0 \\
-1 &amp; t &lt; 0
\end{cases}
\]</span></p>
<p>该信号和单位阶跃信号的关系是：</p>
<p><span class="math display">\[
{\rm sgn}(t) = 2u(t) - 1
\]</span></p>
<hr />
<p>对单位阶跃信号求导即可得到<strong>单位冲激信号</strong> <span class="math inline">\(\delta\)</span>，其定义为：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_{-\infty}^{+\infty} \delta(t) \d t = 1 \\
&amp; \delta(t) = 0 (t \neq 0)
\end{aligned}
\]</span></p>
<p>更一般的冲激信号可以用单位冲激信号定义，对于在 <span class="math inline">\(t_0\)</span> 处冲激，强度为 <span class="math inline">\(E\)</span> 的冲激信号，其表达式为：</p>
<p><span class="math display">\[
\delta_{E, t_0}(t) = E\delta(t - t_0)
\]</span></p>
<p>另外一种定义方式是利用单位矩形脉冲信号取极限，也就是保证全实数集上积分为 <span class="math inline">\(1\)</span> 的条件下令取非零值的区间尽可能小：</p>
<p><span class="math display">\[
\delta = \lim_{\tau\to 0}\frac{G_\tau}{\tau}
\]</span></p>
<p>冲激信号具有下述压扩性质：</p>
<p><span class="math display">\[
\delta(at) = \frac{1}{|a|}\delta(t) (a \neq 0)
\]</span></p>
<p>冲激信号的一个特征就是<strong>搬移特性</strong>：</p>
<p><span class="math display">\[
f * \delta_{1, t_0} = \mathcal{S}_{t_0}[f]
\]</span></p>
<p>这里 <span class="math inline">\(\mathcal{S}_{t_0}\)</span> 表示平移变换，即 <span class="math inline">\(\mathcal{S}_{t_0}[f](t) = f(t - t_0)\)</span>。</p>
<p>上述的平移会将 <span class="math inline">\(f\)</span> 原先的原点平移到冲激信号的冲激点处。</p>
<p>证明则可以直接根据卷积的定义：</p>
<p><span class="math display">\[
(f * \delta_{1, t_0})(t) = \int_{-\infty}^{+\infty}f(t - \tau)\delta_{1, t_0}(\tau)\d\tau = f(t - t_0) = \mathcal{S}_{t_0}[f](t)
\]</span></p>
<p>与搬移特性原理类似的是<strong>筛选特性</strong>，也就是冲激信号和信号乘积的积分会得到该信号在冲激点处的值：</p>
<p><span class="math display">\[
\int_{-\infty}^{+\infty}f(t)\delta(t - t_0)\d t = f(t_0)
\]</span></p>
<h1 id="一般模拟信号分解">一般模拟信号分解</h1>
<h2 id="基本分解">基本分解</h2>
<p>对于信号 <span class="math inline">\(f\)</span>，我们可以将其分解为直流分量和交流分量，我们规定交流分量的积分为零，即：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; f_{\rm DC}(t) = \lim_{T\to+\infty}\frac{1}{T}\int_{-T / 2}^{T / 2}f(t)\d t \\
&amp; f_{\rm AC}(t) = f(t) - f_{\rm DC}(t) \\
\end{aligned}
\]</span></p>
<p>此外，还有奇偶分解：</p>
<p><span class="math display">\[
\begin{aligned}
f_e(t) = \frac{f(t) + f(-t)}{2} \\
f_o(t) = \frac{f(t) - f(-t)}{2} \\
\end{aligned}
\]</span></p>
<p>以及实虚分解：</p>
<p><span class="math display">\[
\begin{aligned}
f_r(t) = \frac{f(t) + f^*(t)}{2} \\
f_i(t) = \frac{f(t) - f^*(t)}{2\j} \\
\end{aligned}
\]</span></p>
<p>上述分解都是严格的，但下述的脉冲分解则是一种近似分解。脉冲分解的思想是把信号分解为若干个矩形脉冲的和，在 <span class="math inline">\([t_0, t_0 + \Delta t]\)</span> 区间上，信号 <span class="math inline">\(f\)</span> 可以近似表示为：</p>
<p><span class="math display">\[
f(t) \approx f(t_0)[u(t - t_0) - u(t - t_0 - \Delta t)]
\]</span></p>
<p>将这些脉冲求和，则得到了信号 <span class="math inline">\(f\)</span> 的一个近似表达。</p>
<h2 id="正交分解概述">正交分解概述</h2>
<p>下述讨论均基于函数平方可积的性质。如果函数 <span class="math inline">\(f\)</span> 满足：</p>
<p><span class="math display">\[
\int_{-\infty}^{+\infty} f^2(t) \d t &lt; +\infty
\]</span></p>
<p>那么函数 <span class="math inline">\(f\)</span> 平方可积。所有的平方可积函数构成函数空间 <span class="math inline">\(\mathcal{L}^2(\mathbb{R})\)</span>。</p>
<p>此外，依然沿用先前的函数内积、正交、完备正交函数集等定义。</p>
<hr />
<p>我们考虑 <span class="math inline">\([t_1, t_2]\)</span> 上的完备正交函数集 <span class="math inline">\(\{\varphi_i\}\)</span> 以及函数 <span class="math inline">\(f\)</span>，其正交分解为：</p>
<p><span class="math display">\[
f = \sum_{k = 1}^{+\infty} c_k\varphi_k
\]</span></p>
<p>显然我们可以得到（这一步求解系数的变换称为 Karhunen-Loeve 变换）：</p>
<p><span class="math display">\[
c_k = \frac{\langle f, \varphi_k \rangle}{\langle \varphi_k, \varphi_k \rangle}
\]</span></p>
<p>据此，可以证明 Parseval 恒等式：</p>
<p><span class="math display">\[
E(f) = \int_{t_1}^{t_2} \|f(t)\|^2 \d t = \sum_{k = 1}^{+\infty} \langle \varphi_k, \varphi_k \rangle\|c_k\|^2 = \sum_{k = 1}^{+\infty} E(c_k\varphi_k)
\]</span></p>
<p>这个定理表明，在正交分解下，信号的能量等于各个分量能量的和。其证明只需要进行展开就可得到：</p>
<p><span class="math display">\[
\begin{aligned}
\int_{t_1}^{t_2} \|f\|^2 \d t &amp;= \int_{t_1}^{t_2} \left\|\sum_{k = 1}^{+\infty} c_k\varphi_k(t)\right\|^2 \d t = \int_{t_1}^{t_2} \left(\sum_{k = 1}^{+\infty} c_k\varphi_k(t)\right)\left(\sum_{k = 1}^{+\infty} c_k\varphi_k(t)\right)^* \d t \\
&amp;= \int_{t_1}^{t_2} \left(\sum_{k = 1}^{+\infty} c_k\varphi_k(t)\right)\left(\sum_{k = 1}^{+\infty} c_k^*\varphi_k^*(t)\right) \d t \\
&amp;= \int_{t_1}^{t_2} \left(\sum_{k = 1}^{+\infty} c_kc_k^*\varphi_k(t)\varphi_k^*(t) + \sum_{i\neq j} c_ic_j^*\varphi_i(t)\varphi_j^*(t)\right) \d t \\
&amp;= \sum_{k = 1}^{+\infty} \|c_k\|^2 \int_{t_1}^{t_2} \varphi_k(t)\varphi_k^*(t) \d t = \sum_{k = 1}^{+\infty} \langle \varphi_k, \varphi_k \rangle\|c_k\|^2
\end{aligned}
\]</span></p>
<div class="note info"><p>你说我展开没考虑连续、可导、收敛啥的？我们工科生不懂这些。</p>
</div>
<p>将信号展开为完全正交函数集的线性组合的过程即函数正交分解，求解线性组合系数的过程为<strong>信号变换</strong>。</p>
<h2 id="周期信号的正交分解">周期信号的正交分解</h2>
<p>现在考虑满足 Dirichlet 条件的周期信号 <span class="math inline">\(f\)</span>。Dirichlet 条件指的是：</p>
<ul>
<li><p>在一个周期内间断点有限</p></li>
<li><p>在一个周期内极值点有限</p></li>
<li><p>在一个周期内绝对值积分有限</p></li>
</ul>
<p>我们考虑下述两个常见的完备正交函数集，这里 <span class="math inline">\(\omega = 2\pi / T\)</span>，<span class="math inline">\(T\)</span> 是 <span class="math inline">\(f\)</span> 的周期，下述函数集在任意的长度为 <span class="math inline">\(T\)</span> 的闭区间上正交完备：</p>
<ul>
<li><p>三角函数集 <span class="math inline">\(\{1, \cos(n\omega t), \sin(n\omega t): n \in \mathbb{N}^+\}\)</span></p></li>
<li><p>指数函数集 <span class="math inline">\(\{e^{\j n\omega t}: n \in \mathbb{Z}\}\)</span></p></li>
</ul>
<p>在这两个基底下展开得到的线性组合式可以理解为一个无穷级数，这个无穷级数就是<strong>傅里叶级数（Fourier series）</strong>。两个函数集得到的傅里叶级数分别称为三角形式的傅里叶级数和指数形式的傅里叶级数。</p>
<p>三角形式的傅里叶级数表示为：</p>
<p><span class="math display">\[
f(t) = a_0 + \sum_{k = 1}^{+\infty} (a_n\cos(n\omega t) + b_n\sin(n\omega t))
\]</span></p>
<p>不难根据先前的论证得到系数的计算公式，这里 <span class="math inline">\(t_0\)</span> 为任意实数：</p>
<p><span class="math display">\[
\begin{aligned}
a_0 &amp;= \frac{\omega}{2\pi} \int_{t_0}^{t_0 + 2\pi / \omega} f(t) \d t \\
a_n &amp;= \frac{\omega}{\pi} \int_{t_0}^{t_0 + 2\pi / \omega} f(t)\cos(n\omega t) \d t \\
b_n &amp;= \frac{\omega}{\pi} \int_{t_0}^{t_0 + 2\pi / \omega} f(t)\sin(n\omega t) \d t \\
\end{aligned}
\]</span></p>
<p>指数形式的傅里叶级数表示为：</p>
<p><span class="math display">\[
f(t) = \sum_{k = -\infty}^{+\infty} F_ke^{\j k\omega t}
\]</span></p>
<p>其中有：</p>
<p><span class="math display">\[
F_k = \frac{\omega}{2\pi} \int_{t_0}^{t_0 + 2\pi / \omega} f(t)e^{-\j k\omega t} \d t
\]</span></p>
<div class="note info"><p>两个形式的傅里叶级数的适用范围均是全实数，但实际上这只是因为 <span class="math inline">\(f\)</span> 是周期的。</p>
<p>严格意义上说，由于我们给定的正交函数集只是在某个长度为 <span class="math inline">\(T\)</span> 的闭区间上正交，所以展开的傅里叶级数也只应当在这个闭区间上可用。但是由于周期性，我们可以简单地说明闭区间外这个级数表达依然成立。</p>
<p>这个区分是有必要的，因为严格意义上，在计算 <span class="math inline">\(f\)</span> 的能量、功率等数值的时候，积分区间均应该是长度为 <span class="math inline">\(T\)</span> 的闭区间。</p>
</div>
<p>三角形式和指数形式的傅里叶级数之间的关系可以考虑下述变形：</p>
<p><span class="math display">\[
\begin{aligned}
f(t) &amp;= a_0 + \sum_{k = 1}^{+\infty} (a_n\cos(n\omega t) + b_n\sin(n\omega t)) \\
&amp;= a_0 + \sum_{k = 1}^{+\infty} \left(a_n\frac{e^{\j n\omega t} - e^{-\j n\omega t}}{2\j} + b_n\frac{e^{\j n\omega t} + e^{-\j n\omega t}}{2}\right) \\
&amp;= a_0 + \sum_{k = 1}^{+\infty} \left(-\j a_n\frac{e^{\j n\omega t} - e^{-\j n\omega t}}{2} + b_n\frac{e^{\j n\omega t} + e^{-\j n\omega t}}{2}\right) \\
&amp;= a_0 + \sum_{k = 1}^{+\infty} \left(\frac{b_n - \j a_n}{2} e^{\j n\omega t} + \frac{b_n + \j a_n}{2} e^{-\j n\omega t}\right) \\
\end{aligned}
\]</span></p>
<p>也就是说这两者之间是等价的，并且可以据此发现上述系数计算公式之间的关系。</p>
<p>据此，我们也可以得到，如果周期信号 <span class="math inline">\(f\)</span> 是偶函数，那么其指数形式 FS 系数为实数序列。如果为奇函数，则为纯虚数序列。</p>
<hr />
<p>考虑 Parseval 定律在 FS 上的应用，显然有（注意积分区间是长度为 <span class="math inline">\(T\)</span> 的闭区间）：</p>
<p><span class="math display">\[
P(f) = \sum_{k = -\infty}^{+\infty} \|F_k\|^2 = \|a_0\|^2 + \frac12 \sum_{k = 1}^{+\infty}(\|a_k\|^2 + \|b_k\|^2)
\]</span></p>
<h2 id="频谱">频谱</h2>
<h3 id="频谱的定义">频谱的定义</h3>
<p>现在默认 FS 使用指数形式的。考虑系数序列 <span class="math inline">\(\{F_n \in \mathbb C\}_{-\infty &lt; n &lt; +\infty}\)</span>。以频率为横轴，将频率所对应的 FS 系数的模为该处的频谱值，即可做出信号的幅度频谱。如果以 FS 系数的辐角作为该处的频谱值，则得到相位频谱。两个频谱合并就可以表现出该信号所有的 FS 系数的信息。</p>
<p>我们思考 FS 系数的意义，事实上 FS 系数作为线性组合的系数，代表了被分解信号中某一个频率的成分的多少。从而这就意味着，频谱表现的是信号在频率意义上的构成。</p>
<p>不过注意，由于指数形式的 FS 之中包含 <span class="math inline">\(e^{-\j n\omega t}(n\in \mathbb{N}^+)\)</span> 项，其频率为负数 <span class="math inline">\(-n\omega\)</span>，所以信号的频谱图上会出现负频率。</p>
<p>我们可以断定频谱的一些性质：</p>
<ul>
<li><p>频谱是离散的，且只会在 <span class="math inline">\(n\omega(n\in \mathbb Z)\)</span> 点处存在值，这些具有值的频率称为<strong>谐波频率（Harmonic frequency）</strong>。</p></li>
<li><p>幅度频谱图是关于纵轴对称的，而相位频谱是关于原点对称的，这是由于 <span class="math inline">\(F_k\)</span> 与 <span class="math inline">\(F_{-k}\)</span> 共轭。</p></li>
</ul>
<p>现在我们考虑一个重要周期信号的频谱，即周期矩形脉冲。</p>
<p>假设某一周期矩形脉冲信号 <span class="math inline">\(f\)</span> 周期为 <span class="math inline">\(T_0 = 2\pi / \omega_0\)</span>，在区间 <span class="math inline">\([-T_0 / 2, T_0 / 2]\)</span> 上定义为：</p>
<p><span class="math display">\[
f(t) = \begin{cases}
E &amp; |t| \leq \tau_0 / 2 \\
0 &amp; |t| &gt; \tau_0 / 2
\end{cases}
\]</span></p>
<p>这里 <span class="math inline">\(E &gt; 0\)</span> 且 <span class="math inline">\(\tau_0 &lt; T_0\)</span>。</p>
<p>其 FS 系数是显然的：</p>
<p><span class="math display">\[
F_k = \frac{\omega_0}{2\pi} \int_{-\pi / \omega_0}^{\pi / \omega_0} f(t)e^{-\j k\omega_0 t} \d t = \frac{E\omega_0}{2\pi} \int_{-\tau_0 / 2}^{\tau_0 / 2} e^{-\j k\omega_0 t} \d t = \frac{E\omega_0\tau_0}{2\pi}\frac{\sin(\omega_0 k\tau_0 / 2)}{\omega_0 k\tau_0 / 2}
\]</span></p>
<p>也就是：</p>
<p><span class="math display">\[
F_k = \frac{E\omega_0\tau_0}{2\pi}{\rm Sa}\left(\frac{\omega_0 k\tau_0}{2}\right)
\]</span></p>
<p>这个结果说明了，周期矩形脉冲信号的频谱具有包络线：</p>
<p><span class="math display">\[
F(\omega) = \frac{E\omega_0\tau_0}{2\pi}{\rm Sa}\left(\frac{\omega\tau_0}{2}\right)
\]</span></p>
<h3 id="带宽">带宽</h3>
<p>事实上我们注意到，大多的信号幅度频谱在高频区域取值很小，这也就说明大多信号在高频区域几乎不具有能量。</p>
<p>实际应用中，在失真可忽略的条件下，信号传递可以只传递低频分量（一般而言取频谱包络线最小绝对值的零点以内的分量），这一段区间的长度称为<strong>频带宽度</strong>，简称<strong>带宽</strong>。</p>
<h2 id="非周期信号的正交分解和频谱">非周期信号的正交分解和频谱</h2>
<h3 id="ft-表达式的推理">FT 表达式的推理</h3>
<p>任何非周期信号 <span class="math inline">\(f\)</span> 实际上都可以看成周期无穷大的周期信号。我们考虑周期为 <span class="math inline">\(T\)</span> 的周期信号 <span class="math inline">\(f_T\)</span>，其在周期 <span class="math inline">\([-T / 2, T / 2)\)</span> 上定义为 <span class="math inline">\(f_T(t) = f(t), t \in [-T / 2, T / 2)\)</span>。实际上可以得到：</p>
<p><span class="math display">\[
\lim_{T \to +\infty} f_T = f
\]</span></p>
<div class="note info"><p>我们没有定义过一个函数列如何收敛为一个函数，故这样的表述并非严谨。</p>
<p>后续很多证明也仅仅是形式化的，其作用仅仅是形成对定律的直观理解，请不要将这些推导用于严谨的证明之中。</p>
</div>
<p>考虑 <span class="math inline">\(f_T\)</span> 的傅里叶级数，如果令 <span class="math inline">\(\omega = 2\pi / T\)</span>，显然有：</p>
<p><span class="math display">\[
\begin{aligned}
f_T(t) &amp;= \sum_{k = -\infty}^{+\infty} F_k e^{\j k\omega t} = \sum_{k = -\infty}^{+\infty} \left(\frac{1}{T}\int_{-T / 2}^{T / 2} f_T(\tau)e^{-\j k\omega\tau} \d\tau\right)e^{\j k\omega t}
\end{aligned}
\]</span></p>
<p>考虑离散频谱中相邻谱线之间的间隔，即 <span class="math inline">\(\Delta\omega = \omega = \dfrac{2\pi}{T}\)</span>，在 <span class="math inline">\(T \to +\infty\)</span> 的时候谱线间隔 <span class="math inline">\(\Delta\omega \to 0\)</span>，那么我们有：</p>
<p><span class="math display">\[
\begin{aligned}
f(t) &amp;= \lim_{T \to +\infty} f_T(t) = \lim_{T \to +\infty} \sum_{k = -\infty}^{+\infty} \left(\frac{1}{T}\int_{-T / 2}^{T / 2} f_T(\tau)e^{-\j k\omega\tau} \d\tau\right)e^{\j k\omega t} \\
&amp;= \frac{1}{2\pi} \lim_{\Delta\omega \to 0} \sum_{k = -\infty}^{+\infty} \left(\int_{-T / 2}^{T / 2} f_T(\tau)e^{-\j k\omega\tau} \d\tau\right)e^{\j k\omega t} \Delta\omega
\end{aligned}
\]</span></p>
<p>现在我们定义：</p>
<p><span class="math display">\[
\begin{aligned}
F_T(x) &amp;= \int_{-T / 2}^{T / 2} f_T(\tau)e^{-\j x\tau} \d\tau \\
F(x) &amp;= \int_{-\infty}^{+\infty} f(\tau)e^{-\j x\tau} \d\tau
\end{aligned}
\]</span></p>
<p>显然有：</p>
<p><span class="math display">\[
\lim_{\Delta\omega \to 0} F_T = F
\]</span></p>
<p>该定义下，可以有：</p>
<p><span class="math display">\[
f(t) = \frac{1}{2\pi} \lim_{\Delta\omega \to 0} \sum_{k = -\infty}^{+\infty} F_T(k\omega) e^{\j k\omega t} \Delta\omega
\]</span></p>
<p>下一步则是将该极限转写为积分。但我们注意这样的一点，即 <span class="math inline">\(\Delta\omega\)</span> 在变动的时候，被积函数 <span class="math inline">\(F_T\)</span> 本身也在变动。按照严格的数学理论，这里我们应当严格说明收敛性。但我们只需要直观理解，具体的证明则省略：</p>
<p><span class="math display">\[
f(t) = \frac{1}{2\pi} \lim_{\Delta\omega \to 0} \sum_{k = -\infty}^{+\infty} F_T(k\omega) e^{\j k\omega t} \Delta\omega = \frac{1}{2\pi} \int_{-\infty}^{+\infty} F(\omega) e^{\j\omega t} \d\omega
\]</span></p>
<hr />
<p>上述推导中，我们实际上已经给出了一个函数 <span class="math inline">\(F(\omega)\)</span> 和信号 <span class="math inline">\(f(t)\)</span> 之间的关系：</p>
<p><span class="math display">\[
\begin{aligned}
f(t) &amp;= \frac{1}{2\pi} \int_{-\infty}^{+\infty} F(\omega) e^{\j\omega t} \d\omega \\
F(\omega) &amp;= \int_{-\infty}^{+\infty} f(t)e^{-\j\omega t} \d t
\end{aligned}
\]</span></p>
<p>这里我们可以给出函数 <span class="math inline">\(F(\omega)\)</span> 的一个理解，我们将其和 FS 比较：</p>
<p><span class="math display">\[
\begin{aligned}
f(t) &amp;= \sum_{k = -\infty}^{+\infty} F_ke^{\j k\omega t} \\
f(t) &amp;= \frac{1}{2\pi} \int_{-\infty}^{+\infty} F(\omega) e^{\j\omega t} \d\omega \\
\end{aligned}
\]</span></p>
<p>可以发现上述用 <span class="math inline">\(F(\omega)\)</span> 推出 <span class="math inline">\(f(t)\)</span> 的公式实际上类似于将 <span class="math inline">\(f\)</span> 表达为正交函数的线性组合，只不过这里的正交函数集是无穷集。这里 <span class="math inline">\(F(\omega)\)</span> 实际上相当于信号 <span class="math inline">\(f(t)\)</span> 的频谱，即其频域表现。</p>
<p>由 <span class="math inline">\(f\)</span> 推出 <span class="math inline">\(F\)</span> 的过程就称为<strong>傅立叶变换（Fourier transformation）</strong>，简称 FT。反过来由 <span class="math inline">\(F\)</span> 推出 <span class="math inline">\(f\)</span> 则称为<strong>傅立叶逆变换</strong>，简称 IFT。标记为：</p>
<p><span class="math display">\[
F = \mathcal{F}[f], f = \mathcal{F}^{-1}[F]
\]</span></p>
<h3 id="ft-的运算性质">FT 的运算性质</h3>
<p>FT 显然是线性变换：</p>
<p><span class="math display">\[
\mathcal{F}\left[\sum_{k = 1}^n \lambda_kf_k\right] = \sum_{k = 1}^n \lambda_k\mathcal{F}[f_k]
\]</span></p>
<p>下述论述中，记 <span class="math inline">\(F := \mathcal{F}[f]\)</span>。</p>
<p>其与反褶变换 <span class="math inline">\(\mathcal{R}\)</span> 具有以下性质：</p>
<p><span class="math display">\[
\begin{cases}
\mathcal{F}\mathcal{R}[f] = \mathcal{R}[F] \\
\mathcal{F}[f^*] = \mathcal{R}^*[F] \\
\mathcal{F}\mathcal{R}^*[f] = F^* \\
\end{cases}
\]</span></p>
<p>即时域上反褶等价于频域反褶，时域上共轭等价于频域反褶共轭，时域上反褶共轭等价于频域共轭。</p>
<p>而对于压扩变换 <span class="math inline">\(\mathcal{E}_a\)</span>，这里 <span class="math inline">\(\mathcal{E}_a[f](t) = f(at)\)</span>，我们有：</p>
<p><span class="math display">\[
\mathcal{F}\mathcal{E}_a[f] = \frac{1}{|a|}\mathcal{E}_{\frac{1}{a}}[F]
\]</span></p>
<p>对于平移变换 <span class="math inline">\(\mathcal{S}_{t_0}\)</span>，我们有（这里符号 <span class="math inline">\(\mathcal{F}\)</span> 的两个下标分别代表时域和频域使用的自变量符号）：</p>
<p><span class="math display">\[
\mathcal{F}_{t, \omega}[f(t - t_0)] = F(\omega)e^{-\j\omega t_0}
\]</span></p>
<p>综合压扩变换和平移变换：</p>
<p><span class="math display">\[
\mathcal{F}_{t, \omega}[f(at - t_0)] = \frac{1}{|a|}F\left(\frac{\omega}{a}\right)e^{-\j\omega t_0 / a}
\]</span></p>
<p>综合上述可以看出，时域的压扩会导致频域相反的压扩，并且会伴随幅度的变化。而时域的平移不影响幅度频谱，但是相位频谱会发生改变。</p>
<div class="note info"><p>这里使用 <span class="math inline">\(\mathcal{F}_{t, \omega}\)</span> 实在是折中之举。我自己一向是想要明确函数和函数值的区别的，比如说对函数的变换应该使用花写字体，使用中括号。按照这样的思路，<span class="math inline">\(\mathcal{F}[f(at - t_0)]\)</span> 是错误表达，因为方括号内实际上是函数值而非一个函数。</p>
<p>但是由于通用数学符号很多时候并没有区分两者，所以为了避免使用更多自定义符号导致难以阅读，还是暂且使用 <span class="math inline">\(\mathcal{F}_{t, \omega}\)</span> 这样的折中符号。</p>
</div>
<p>实际上我们注意到 FT 和 IFT 具有相同的数学结构，那么如果在时域上乘以复指数，频域则会发生平移：</p>
<p><span class="math display">\[
\mathcal{F}_{t, \omega}[f(t)e^{\j\omega_0 t}] = F(\omega - \omega_0)
\]</span></p>
<p>结合压扩变换得到：</p>
<p><span class="math display">\[
\mathcal{F}_{t, \omega}\left[\frac{1}{|a|}f\left(\frac{t}{a}\right)e^{\j\omega_0 t / a}\right] = F(a\omega - \omega_0)
\]</span></p>
<hr />
<p>FT 和微分积分运算关系大致如下。</p>
<p>考虑时域上的微分：</p>
<p><span class="math display">\[
\mathcal{F}_{t, \omega}\left[f^{(1)}(t)\right] = \j\omega F(\omega)
\]</span></p>
<p>考虑频域上的微分：</p>
<p><span class="math display">\[
\mathcal{F}^{-1}_{t, \omega}\left[F^{(1)}(\omega)\right] = -\j tf(t)
\]</span></p>
<p>考虑时域上的积分：</p>
<p><span class="math display">\[
\mathcal{F}_{t, \omega}\left[f^{(-1)}(t)\right] = \frac{1}{\j\omega}F(\omega) + \pi F(0)\delta(\omega)
\]</span></p>
<p>考虑频域上的积分：</p>
<p><span class="math display">\[
\mathcal{F}^{-1}_{t, \omega}\left[F^{(-1)}(\omega)\right] = -\frac{1}{\j t}f(t) + \pi f(0)\delta(t)
\]</span></p>
<hr />
<p>而 FT 和卷积的关系就很明朗，时域与频域相对，其中一个域上的乘积直接对应另一个域上的卷积。不过需要注意可能出现的常系数：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \mathcal{F}[f_1 * f_2] = \mathcal{F}[f_1] \cdot \mathcal{F}[f_2] \\
&amp; \mathcal{F}[f_1 \cdot f_2] = \frac{1}{2\pi} \mathcal{F}[f_1] * \mathcal{F}[f_2] \\
\end{aligned}
\]</span></p>
<p>FT 和相关运算的关系为：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \mathcal{F}[R(f_1, f_2)] = F_1F_2^* \\
&amp; \mathcal{F}[R(f, f)] = \|F\|^2
\end{aligned}
\]</span></p>
<div class="note info"><p>使用这个数学关系就可以得到矩形窗截取可能导致频域畸形的理论解释。我们提到过矩形脉冲乘以某一个信号可以用于截取信号指定区间的信息。但是截取后的信号在频域上的表现则会畸形，考虑下述关系：</p>
<p><span class="math display">\[
\mathcal{F}[G_\tau f] = \frac{1}{2\pi} \mathcal{F}[G_\tau] * \mathcal{F}[f]
\]</span></p>
<p>而 <span class="math inline">\(\mathcal{F}[G_\tau]\)</span> 是 <span class="math inline">\({\rm Sa}\)</span> 函数的衍生函数，其和原信号频谱的卷积可能导致频域畸变。</p>
</div>
<h3 id="fs-和-ft-的关系">FS 和 FT 的关系</h3>
<p>我们可以这样研究 FS 和 FT 的关系，考虑非周期信号 <span class="math inline">\(f\)</span>，其在区间 <span class="math inline">\([-T / 2, T / 2]\)</span> 外取值均为零。定义周期为 <span class="math inline">\(T\)</span> 的周期信号 <span class="math inline">\(\tilde{f}\)</span>，其在周期 <span class="math inline">\([-T / 2, T / 2]\)</span> 上有 <span class="math inline">\(\tilde{f} = f\)</span>。</p>
<p>考虑 <span class="math inline">\(\tilde{f}\)</span> 的 FS 系数（这里 <span class="math inline">\(\omega := 2\pi / T\)</span>）：</p>
<p><span class="math display">\[
F_k = \frac{1}{T} \int_{-T / 2}^{T / 2} \tilde{f}(t)e^{-\j k\omega t} \d t = \frac{1}{T} \int_{-\infty}^{+\infty} f(t)e^{-\j k\omega t} \d t = \frac{1}{T} F(k\omega)
\]</span></p>
<p>也就是说如果将一个脉冲式的信号（即除了某一个有限区间外取值均为零）扩展为一个周期信号，那么周期信号的离散频谱的包络线和脉冲信号的连续频谱仅仅相差一个常数倍数。</p>
<p>比如说上述求解过的周期矩形脉冲信号，如果我们仅仅关注一个周期内的矩形脉冲，其连续频谱的表达式为（和之前的论证使用相同的变量符号）：</p>
<p><span class="math display">\[
F(\omega) = E\tau_0{\rm Sa}\left(\frac{\omega\tau_0}{2}\right)
\]</span></p>
<h3 id="准周期信号">准周期信号</h3>
<p>有一些非周期信号可能会具有类似周期信号的时域重复结构，即可以将时域均匀划分为准周期，每一个准周期内信号的结构相互类似，这类信号就是准周期信号，如果其准周期的长度为 <span class="math inline">\(T\)</span>，一般会将 <span class="math inline">\(f_0 = 1 / T\)</span> 称为准周期信号的<strong>基频（Pitch）</strong>。</p>
<p>准周期信号的频谱特征也介于周期信号频谱和非周期信号频谱之间，即其频谱依然连续，但是在谐波频率处具有明显的尖峰。谐波频率处的尖峰就是准周期信号的一大特征。</p>
<h3 id="周期信号的-ft">周期信号的 FT</h3>
<p>鉴于 FS 和 FT 具有相同的本质，而周期信号的频谱表现是离散的，我们可以预料到对周期信号求解 FT 会得到若干离散的冲激函数之和。</p>
<p>比如说根据：</p>
<p><span class="math display">\[
\frac{1}{2\pi} \int_{-\infty}^{+\infty} (2\pi\delta(\omega - \omega_0)) e^{\j\omega t} \d\omega = e^{\j\omega_0 t}
\]</span></p>
<p>就可以得到复指数信号的 FT 为：</p>
<p><span class="math display">\[
\mathcal{F}_{t, \omega}[e^{\j\omega_0 t}] = 2\pi\delta(\omega - \omega_0)
\]</span></p>
<p>进一步可以推出：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \mathcal{F}_{t, \omega}[\cos\omega_0 t] = \pi(\delta(\omega + \omega_0) + \delta(\omega - \omega_0)) \\
&amp; \mathcal{F}_{t, \omega}[\sin\omega_0 t] = \j\pi(\delta(\omega + \omega_0) - \delta(\omega - \omega_0)) \\
\end{aligned}
\]</span></p>
<h3 id="其他常用函数的-ft">其他常用函数的 FT</h3>
<p>考虑冲激函数的 FT：</p>
<p><span class="math display">\[
\mathcal{F}[\delta_{E, 0}](\omega) = \int_{-\infty}^{+\infty} E\delta(t)e^{-\j\omega t} \d t = E
\]</span></p>
<p>也就是说冲激函数的傅立叶变换为常函数。这意味着冲激信号的频谱是处处均匀的，这种频谱一般称为<strong>白色谱</strong>或者<strong>均匀谱</strong>。</p>
<p>对冲激函数做 IFT 得到：</p>
<p><span class="math display">\[
\mathcal{F}^{-1}[\delta_{E, 0}](t) = \frac{1}{2\pi} \int_{-\infty}^{+\infty} E\delta(\omega) e^{\j\omega t} \d\omega = \frac{E}{2\pi}
\]</span></p>
<p>也就是说常函数的傅立叶变换是在原点的冲激函数，这是好理解的，因为常函数就是频率为零的三角函数。</p>
<p>上述推理说明了：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \mathcal{F}[\delta] = 1 \\
&amp; \mathcal{F}[1] = 2\pi\delta \\
\end{aligned}
\]</span></p>
<h1 id="信号采样">信号采样</h1>
<h2 id="采样的概念">采样的概念</h2>
<p>我们使用计算机存储时域上连续的信号的时候，只能存储部分点处的信号幅度，这就要求我们决定存储哪些点的信号值。这类每隔一定的时间间隔，从连续信号上取出该点信号幅度的行为就是<strong>采样</strong>。每次采样之间的时间间隔称为<strong>采样周期</strong>，一般标记为 <span class="math inline">\(T_s\)</span>。其倒数 <span class="math inline">\(f_s = 1 / T_s\)</span> 即称为<strong>采样频率</strong>，<span class="math inline">\(\omega_s = 2\pi / T_s\)</span> 则是<strong>采样（角）频率</strong>。</p>
<p>理想情况下，我们一般使用冲激串采样，即使用函数：</p>
<p><span class="math display">\[
p(t) = \sum_{k = -\infty}^{+\infty} \delta(t - kT_s)
\]</span></p>
<p>使用 <span class="math inline">\(p(t)\)</span> 乘以需要采样的信号 <span class="math inline">\(f(t)\)</span> 即可得到采样的结果。</p>
<h2 id="采样定理">采样定理</h2>
<p>现在考虑理想冲激串采样，我们考虑采样后信号的频谱表现。记：</p>
<p><span class="math display">\[
f_p(t) := f(t)p(t) = \sum_{k = -\infty}^{+\infty} f(t)\delta(t - kT_s)
\]</span></p>
<p>那么根据 FT 和卷积的关系（这里规定 <span class="math inline">\(F := \mathcal{F}[f]\)</span>）：</p>
<p><span class="math display">\[
\begin{aligned}
\mathcal{F}[f_p] &amp;= \frac{1}{2\pi}F * \mathcal{F}[p]
\end{aligned}
\]</span></p>
<p>这里我们需要求解 <span class="math inline">\(\mathcal{F}[p]\)</span>，即冲激串的傅立叶变换。由于冲激串函数实际上是周期函数，所以可以得知其频谱表现也是冲激串。我们可以求解其 FS 系数（这里 <span class="math inline">\(\omega_s := 2\pi / T_s\)</span>）：</p>
<p><span class="math display">\[
F_k = \frac{1}{T_s} \int_{-T_s / 2}^{T_s / 2} p(t)e^{-\j k\omega_s t} \d t = \frac{1}{T_s}
\]</span></p>
<p>将 <span class="math inline">\(p(t)\)</span> 写成 FS 得到：</p>
<p><span class="math display">\[
p(t) = \sum_{k = -\infty}^{+\infty} \frac{1}{T_s}e^{\j k\omega_s t}
\]</span></p>
<p>所以说可以有：</p>
<p><span class="math display">\[
\mathcal{F}[p](\omega) = \mathcal{F}_{t, \omega}\left[\sum_{k = -\infty}^{+\infty} \frac{1}{T_s}e^{\j k\omega_s t}\right] = \frac{1}{T_s} \sum_{k = -\infty}^{+\infty} \mathcal{F}_{t, \omega}[e^{\j k\omega_s t}] = \frac{2\pi}{T_s} \sum_{k = -\infty}^{+\infty} \delta(\omega - k\omega_s)
\]</span></p>
<p>也就是说时域的冲激串在频域上也是冲激串。</p>
<div class="note info"><p>如果你尝试这样求解 <span class="math inline">\(\mathcal{F}[p]\)</span>：</p>
<p><span class="math display">\[
\mathcal{F}[p] = \mathcal{F}\left[\sum_{k = -\infty}^{+\infty} \delta_{1, kT_s}\right] = \sum_{k = -\infty}^{+\infty} \mathcal{F}[\delta_{1, kT_s}]
\]</span></p>
<p>显然这会得到错误的结果。错误的原因是这里的级数和傅立叶变换这里不能交换（而上面先写成 FS 再 FT 的时候，级数和傅立叶变换又是可以交换的），而更深层次的原因则是冲激串严格上不具有 FT（不满足 Dirichlet 条件）。</p>
<p>实际上如果从更深层的意义上说，我们根本没有严格定义冲激函数，毕竟我们能看出来冲激函数根本不可能使用 Riemann 积分计算，所以还有更深层的数学原理被忽视了。</p>
<p>但一定程度上，这就是工科。想要钻研这些理论内部严格数学原理的读者可以阅读拓扑、泛函、实分析相关内容。</p>
</div>
<p>那么就可以计算取样后信号的频谱了：</p>
<p><span class="math display">\[
\mathcal{F}[f_p] = \frac{1}{2\pi}F * \mathcal{F}[p] = \frac{1}{T_s}F * \left(\sum_{k = -\infty}^{+\infty} \delta_{1, k\omega_s}\right) = \frac{1}{T_s}\sum_{k = -\infty}^{+\infty} \mathcal{S}_{k\omega_s}[F]
\]</span></p>
<p>也就是说抽样后的信号的频谱是将原先的频谱以 <span class="math inline">\(\omega_s\)</span> 为周期平移后叠加后得到的。</p>
<hr />
<p>现在我们考虑现实中常见的信号。常见信号往往具有一个<strong>高频截止频率</strong> <span class="math inline">\(\omega_M\)</span>，其含义为信号的频谱 <span class="math inline">\(F\)</span> 在区间 <span class="math inline">\([-\omega_M, \omega_M]\)</span> 外均取零。此外，之前也有提到过带宽相关知识，即大多数信号的能量聚集在低频区段，所以往往会截断高频的部分，而这个截断频率，也可以称为高频截止频率。这类信号频谱中位于区间 <span class="math inline">\([-\omega_M, \omega_M]\)</span> 内的频谱峰称为<strong>主峰</strong>。</p>
<p>对一个高频截止频率为 <span class="math inline">\(\omega_M\)</span> 的信号按照频率 <span class="math inline">\(\omega_s\)</span> 采样，采样后的频谱记为 <span class="math inline">\(F_p\)</span>，其是周期为 <span class="math inline">\(\omega_s\)</span> 的周期函数，每一个周期都是由原先信号的频谱主峰平移而来。我们现在固定高频截止频率，降低采样频率，考察 <span class="math inline">\(F_p\)</span> 的变化。在 <span class="math inline">\(\omega_s\)</span> 降低的时候，<span class="math inline">\(F_p\)</span> 周期减小，峰与峰之间的距离减小，从而存在一个临界取样频率，让相邻的两个频谱峰恰好相交。如果取样频率低于这个临界频率，就意味着 <span class="math inline">\(F_p\)</span> 的各个相邻的频谱峰会相互重叠，即发生<strong>频谱混叠</strong>。</p>
<p>如果没有发生频谱混叠，我们可以在采样之后使用低通滤波器将 <span class="math inline">\(F_p\)</span> 的主峰过滤出来，从而完美还原原先的信号。但是如果发生混叠，这种完美复原则是不可能的。而这个临界频率是显而易见的，即 <span class="math inline">\(\omega_s = 2\omega_M\)</span>。</p>
<p>这就是 Nyquist 取样定理，即使用不低于两倍高频截止频率 <span class="math inline">\(\omega_M\)</span> 的采样频率 <span class="math inline">\(\omega_s\)</span> 采样得到的数据点可以完美还原原信号。</p>
<p>综合上述，只有信号满足<strong>频带受限</strong>（即严格具有高频截止频率）并且<strong>取样频率足够高</strong>的时候，取样才能无损表示原有信号。</p>
<h2 id="信号复原内插">信号复原（内插）</h2>
<p>思考从采样序列恢复原先连续信号的方法，这其实就是<strong>插值法</strong>的应用，只不过在信号处理原理中我们将之称为内插法。</p>
<p>现在我们有信号 <span class="math inline">\(x(t)\)</span> 以抽样周期 <span class="math inline">\(T\)</span> 抽样得到的抽样序列 <span class="math inline">\(\{x(nT)\}_{n \in \mathbb Z}\)</span>。进行内插之前，我们需要确定内插函数 <span class="math inline">\(h(t)\)</span>，而内插函数一般就是我们使用的滤波器的单位冲激响应函数。随后用下述方法计算出内插后的连续信号 <span class="math inline">\(\tilde x(t)\)</span>：</p>
<p><span class="math display">\[
\tilde x(t) := \sum_{n = -\infty}^{+\infty} x(nT)h(t - nT) \approx x(t)
\]</span></p>
<p>使用不同的滤波器对应的内插函数 <span class="math inline">\(h(t)\)</span>，我们能获取到不同效果的复原信号 <span class="math inline">\(x(t)\)</span>。</p>
<div class="note info"><p>这里需要尝试解释一下滤波器、单位冲激响应、内插这些概念。</p>
<p>首先简单理解一下<strong>系统（System）</strong>的概念。系统可以简单理解为对给定输入（称之为<strong>激励</strong>）给出给定输出（称之为<strong>响应</strong>）的，具有特定功能的整体。</p>
<p>滤波器本质上就是一个对信号函数的变换，也是一种系统。只不过这个变换很多时候是用于过滤信号频谱之中的低频（或高频）成分的，所以才会有低通滤波器（或高通滤波器）之类的名称。其激励就是要过滤的信号，响应就是过滤后的信号。根据我们对滤波器性质的要求，我们至少需要滤波器是线性系统，满足激励叠加等于响应叠加以及激励倍增等于响应倍增。</p>
<p>而单位冲激响应就是一种特殊的响应。如果某一个滤波器的激励为单位冲激信号，其在这个条件下的响应就是单位冲激响应。</p>
<p>现在考虑一个滤波器，其对应的函数变换为 <span class="math inline">\(\mathcal{P}\)</span>，其单位冲激响应为 <span class="math inline">\(h\)</span>，即 <span class="math inline">\(\mathcal{P}[\delta] = h\)</span>。滤波器的线性保证了下述的性质：</p>
<p><span class="math display">\[
\begin{cases}
\mathcal{P}[f + g] = \mathcal{P}[f] + \mathcal{P}[g] \\
\mathcal{P}[\lambda f] = \lambda\mathcal{P}[f]
\end{cases}
\]</span></p>
<p>接下来我们证明<strong>任何激励和单位冲激响应的卷积就是该激励下滤波器的响应</strong>。这个结论说明了单位冲激响应携带了一个线性系统所有的信息，即只需要知晓一个线性系统的单位冲激响应就可以计算任何激励下的系统响应。本证明完全不理会系统函数变换和极限、级数是否可交换，工科生不管这些：</p>
<p><span class="math display">\[
\begin{aligned}
\mathcal{P}[x] &amp;= \mathcal{P}[x * \delta] = \mathcal{P}\left[\int_{-\infty}^{+\infty} x(\tau)\delta(\cdot - \tau) \d\tau\right] = \mathcal{P}\left[\lim_{\Delta \to 0} \sum_{k = -\infty}^{+\infty} x(k\Delta)\delta(\cdot - k\Delta) \Delta\right] \\
&amp;= \lim_{\Delta \to 0} \sum_{k = -\infty}^{+\infty} x(k\Delta) \mathcal{P}[\delta_{1, k\Delta}]\Delta = \lim_{\Delta \to 0} \sum_{k = -\infty}^{+\infty} x(k\Delta) h(\cdot - k\Delta)\Delta \\
&amp;= \int_{-\infty}^{+\infty} x(\tau)h(\cdot - \tau) \d\tau = x * h
\end{aligned}
\]</span></p>
<p>这里第一行到第二行直接默认系统函数变换和极限可交换且无穷求和下系统线性依然可以保证。</p>
<p>现在我们讨论上述说明的这些和信号复原（内插）是什么关系。我们已经说明了在符合取样定理的条件下，时域取样等价于频域周期延拓，所以我们要复原信号，只需要在频域上过滤出主峰即可。这个时候就需要使用到低通滤波器，我们假设使用的低通滤波器具有单位冲激响应 <span class="math inline">\(h(t)\)</span>。而这个滤波器的输入信号就是取样周期为 <span class="math inline">\(T\)</span> 的理想冲激串对原信号 <span class="math inline">\(x(t)\)</span> 取样得到的取样信号：</p>
<p><span class="math display">\[
x_p(t) = \sum_{k = -\infty}^{+\infty} x(kT)\delta(t - kT)
\]</span></p>
<p>我们考虑 <span class="math inline">\(x_p(t)\)</span> 通过滤波器处理后的输出，根据上述结论，该输出就是 <span class="math inline">\(x_p\)</span> 与 <span class="math inline">\(h\)</span> 的卷积，这里证明依然默认级数和无穷积分可交换：</p>
<p><span class="math display">\[
\begin{aligned}
(x_p * h)(t) &amp;= \int_{-\infty}^{+\infty} x_p(\tau)h(t - \tau) \d\tau = \int_{-\infty}^{+\infty} \left(\sum_{k = -\infty}^{+\infty} x(kT)\delta(\tau - kT)\right) h(t - \tau) \d\tau \\
&amp;= \sum_{k = -\infty}^{+\infty} x(kT) \int_{-\infty}^{+\infty} h(t - \tau)\delta(\tau - kT) \d\tau = \sum_{k = -\infty}^{+\infty} x(kT)h(t - kT)
\end{aligned}
\]</span></p>
<p>这个结果和我们介绍的使用内插函数 <span class="math inline">\(h\)</span> 对 <span class="math inline">\(x\)</span> 的取样序列进行内插法得到 <span class="math inline">\(\tilde x\)</span> 的公式一致。</p>
<p>其实内插法和使用滤波器滤波本质上在叙说同样的概念，只不过内插法是从时域的角度观察，即这样操作之后时域上缺失的数值点就会被插入回来，从而复原信号。而滤波是从频域的角度观察，即这样的操作本质上是在频域上过滤出低频峰。内插和滤波其实就是信号复原这个操作两个角度下观察的结果。</p>
</div>
<p>在此基础上我们继续介绍。为了复原初始连续信号，最理想的情况是使用理想低通滤波器，其频域表现为矩形窗，时域表现为 Sa 函数。其只需要在时域上将取样后的信号卷积上一个 Sa 函数即可获取原先的连续信号。</p>
<p>但是这里我们介绍两个不完全恢复的内插函数，即<strong>零阶保持内插</strong>和<strong>一阶保持内插（线性内插）</strong>。零阶保持内插的内插函数为：</p>
<p><span class="math display">\[
h(t) = \begin{cases}
1 &amp; 0 \leq t \leq T \\
0 &amp; {\rm otherwise}
\end{cases}
\]</span></p>
<p>这里 <span class="math inline">\(T\)</span> 是取样周期。可以发现，内插函数是时域上的矩形窗，将其代入 <span class="math inline">\(\tilde x\)</span> 的公式会发现其复原出的信号大致为：</p>
<p><img src="/uploads/note-of-dsp/1.png" /></p>
<p>这里灰色线是原先的信号 <span class="math inline">\(x\)</span>，红色线则是内插后得到的 <span class="math inline">\(\tilde x\)</span>。这样的内插在每一个抽样周期内保持了抽样值本身，最终复原得到了类似阶跃的信号。</p>
<p>而一阶保持内插则是使用线性的方式插值，其内插函数为三角窗：</p>
<p><span class="math display">\[
h(t) = \begin{cases}
\dfrac{t}{T} + 1 &amp; -T \leq t &lt; 0 \\
-\dfrac{t}{T} + 1 &amp; 0 \leq t \leq T \\
0 &amp; {\rm otherwise}
\end{cases}
\]</span></p>
<p>其内插复原的信号则为：</p>
<p><img src="/uploads/note-of-dsp/2.png" /></p>
<p>可见其效果为直接使用线段连接各取样值以近似原信号。</p>
<hr />
<p>上述讨论完全基于采样满足采样定理，现在讨论采样频率过低导致频谱混叠的<strong>欠采样</strong>情况。此时即使采用理想低通滤波也无法获取原信号，但是我们可以说明，无论如何内插，采样点处的值保持。即无论采用何种内插函数 <span class="math inline">\(h\)</span>，得到的 <span class="math inline">\(\tilde x\)</span> 都保证 <span class="math inline">\(\tilde x(kT) = x(kT)(k \in \mathbb Z)\)</span>。</p>
<div class="note warning"><p>事实上这个性质要求内插函数 <span class="math inline">\(h\)</span> 满足这样的条件：</p>
<p><span class="math display">\[
\begin{cases}
h(0) = 1 \\
h(kT) = 0, k \in \mathbb Z \backslash \{0\}
\end{cases}
\]</span></p>
<p>事实上我们上面的叙述也只能为大家建立内插和滤波之间的一个直观感受，但是严格而言内插和滤波并非是一对完全严格对应的概念。内插法，或者说插值，天然要求插值后采样点处的函数值不改变，但是滤波并不严格保证这一点，比如说令滤波器的单位脉冲响应为 <span class="math inline">\(h(t) \equiv 1\)</span>，就不能保证采样点处函数值不变了。</p>
</div>
<h1 id="离散信号处理">离散信号处理</h1>
<p>上述的讨论均是理论的，理论的模拟信号时域连续、时域无限长、数值取值范围无限、精度无限。但是实际使用计算机处理的时候，这三点均无法满足，即计算机能处理的信号时域离散、时域有限长、数值取值范围有限、精度有限。</p>
<p>所以我们需要将上述的理论进行一定的修正才能应用到真实的信号处理场景中。</p>
<h2 id="从抽样序列还原原信号时域">从抽样序列还原原信号时域</h2>
<p>这一问题已经在采样部分叙述过，频带有限信号的采样频率足够高的时候，就可以根据抽样序列无损还原原信号。</p>
<h2 id="从抽样序列还原原信号频谱">从抽样序列还原原信号频谱</h2>
<p>连续时域信号通过抽样可以得到离散时域信号。考虑具有高频截止频率 <span class="math inline">\(\omega_M\)</span> 的频带有限信号 <span class="math inline">\(f\)</span>，其抽样信号 <span class="math inline">\(f_p\)</span> 定义为下式，这里 <span class="math inline">\(T_s\)</span> 是抽样周期：</p>
<p><span class="math display">\[
f_p(t) = \sum_{n = -\infty}^{+\infty} f(nT_s)\delta(t - nT_s)
\]</span></p>
<p>我们先前计算过抽样信号的 FT，这里 <span class="math inline">\(\omega_s\)</span> 是抽样频率，<span class="math inline">\(F\)</span> 是 <span class="math inline">\(f\)</span> 的频谱：</p>
<p><span class="math display">\[
F_p(\omega) = \frac{1}{T_s} \sum_{m = -\infty}^{+\infty} F(\omega - m\omega_s)
\]</span></p>
<p>在不发生频谱混叠的时候，抽样信号的频谱的主峰严格和原信号的频谱仅相差常数系数。也就是说在满足抽样定理的时候：</p>
<p><span class="math display">\[
F_p(\omega) = \frac{1}{T_s} F(\omega), \omega \in \left[-\frac{\omega_s}{2}, \frac{\omega_s}{2}\right] 
\]</span></p>
<p>我们形式上根据 FT 的计算公式可以推理得到下述关系，这里形式上将级数和无穷积分认为是可以交换的，所以严格而言是不严谨的推理：</p>
<p><span class="math display">\[
\begin{aligned}
F_p(\omega) &amp;= \int_{-\infty}^{+\infty} f_p(t)e^{-\j\omega t} \d t = \int_{-\infty}^{+\infty} \left(\sum_{n = -\infty}^{+\infty} f(nT_s)\delta(t - nT_s)\right)e^{-\j\omega t} \d t \\
&amp;= \sum_{n = -\infty}^{+\infty} f(nT_s) \left(\int_{-\infty}^{+\infty} \delta(t - nT_s)e^{-\j\omega t} \d t\right) = \sum_{n = -\infty}^{+\infty} f(nT_s) e^{-\j\omega nT_s} \d t
\end{aligned}
\]</span></p>
<p>那么：</p>
<p><span class="math display">\[
F(\omega) = T_sF_p(\omega) = T_s\sum_{n = -\infty}^{+\infty} f(nT_s) e^{-\j\omega nT_s}, \omega \in \left[-\frac{\omega_s}{2}, \frac{\omega_s}{2}\right] 
\]</span></p>
<p>从而我们就有从抽样信号序列复原原信号频谱的方式，这种变换相当于从离散信号作傅立叶变换，称为<strong>离散时间傅立叶变换（Discrete Time Fourier Transformation / DTFT）</strong>。</p>
<p>考虑其逆变换，即从原信号的频谱获取抽样信号。事实上 DTFT 的式子可以认为是一个 FS，<span class="math inline">\(\{f(nT_s)\}_{n \in \mathbb Z}\)</span> 可以认为是频域上的 FS 系数数列，原信号周期为 <span class="math inline">\(\omega_s\)</span>，不过注意这里指数上是 <span class="math inline">\(-\j\omega nT_s\)</span>，是有负号的。那么根据 FS 系数的公式：</p>
<p><span class="math display">\[
f(nT_s) = \frac{1}{\omega_s} \int_{-\omega_s / 2}^{\omega_s / 2} F_p(\omega)e^{\j n\omega T_s} \d\omega
\]</span></p>
<p>现在我们尝试进行归一化。由于 <span class="math inline">\(T_s\)</span> 实质上只是作为系数出现，所以可以将其归一化为 <span class="math inline">\(1\)</span>。而原先的采样序列记作数列 <span class="math inline">\(\{x(n)\}_{n \in \mathbb Z}\)</span>，这种归一化后的采样序列一般称为<strong>数字信号（Digital signal）</strong>。在这样的表示之下考虑 DTFT 和 IDTFT，我们将 DTFT 的结果记作 <span class="math inline">\(X(\omega)\)</span>，这也称为数字信号的频谱：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; X(\omega) = {\rm DTFT}[x](\omega) = \sum_{n = -\infty}^{+\infty} x(n) e^{-\j\omega n} \\
&amp; x(n) = \frac{1}{2\pi} \int_{-\pi}^{\pi} X(\omega)e^{\j n\omega} \d\omega
\end{aligned}
\]</span></p>
<p>根据上述推理，很容易知晓数字信号的频谱一定是周期的（根据 FT 和 IFT 的对偶，实际上根据周期信号的频谱离散就不难理解），并且由于进行了归一化处理，所以这个周期一定是 <span class="math inline">\(2\pi\)</span>：</p>
<p><span class="math display">\[
X(\omega + 2\pi) = X(\omega)
\]</span></p>
<p>DTFT 的运算法则和 FT 有很大类似之处。首先有 DTFT 是线性的：</p>
<p><span class="math display">\[
{\rm DTFT}\left[\sum_{k = 1}^n \lambda_kx_k\right] = \sum_{k = 1}^n \lambda_k{\rm DTFT}[x_k]
\]</span></p>
<p>时域和频域的平移均会导致另外一个域的相位平移：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; {\rm DTFT}_{n, \omega}[x(n - n_0)] = X(\omega)e^{-\j\omega n_0} \\
&amp; {\rm DTFT}_{n, \omega}[x(t)e^{\j\omega_0 n}] = X(\omega - \omega_0)
\end{aligned}
\]</span></p>
<p>其和反褶、共轭的关系也和 FT 类似：</p>
<p><span class="math display">\[
\begin{cases}
{\rm DTFT}[\mathcal{R}x] = \mathcal{R}[X] \\
{\rm DTFT}[x^*] = \mathcal{R}^*[X] \\
{\rm DTFT}[\mathcal{R}^*x] = X^* \\
\end{cases}
\]</span></p>
<p>压扩变换不能直接应用到数字信号上，所以我们给出时域扩展的定义：</p>
<p><span class="math display">\[
\mathcal{E}_a[x](n) = \begin{cases}
x(k) &amp; n = ka, k \in \mathbb Z \\
0 &amp; {\rm otherwise}
\end{cases} \ (a \in \mathbb{Z} \backslash \{0\})
\]</span></p>
<p>和 FT 类似，时域扩展的 DTFT 满足：</p>
<p><span class="math display">\[
{\rm DTFT}_{n, \omega}[\mathcal{E}_a[x](n)] = X(a\omega)
\]</span></p>
<p>DTFT 我们只探讨频域微分，和 FT 类似，频域微分等价于时域上的加权求和：</p>
<p><span class="math display">\[
{\rm DTFT}_{n, \omega}[nx(n)] = \j X^{(1)}(\omega)
\]</span></p>
<p>讨论卷积的时候，就不得不考虑到 DTFT 得到的频谱是周期的，普通的卷积可能不收敛。所以这里定义<strong>圆卷积</strong>，直观上而言就是指考虑一个周期内的卷积。比如说周期为 <span class="math inline">\(T\)</span> 的两个周期信号 <span class="math inline">\(x, y\)</span> 的圆卷积定义为：</p>
<p><span class="math display">\[
(x\otimes y)(t) := \int_T x(\tau)y(t - \tau) \d\tau
\]</span></p>
<p>那么：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; {\rm DTFT}[x_1 * x_2] = {\rm DTFT}[x_1] \cdot {\rm DTFT}[x_2] \\
&amp; {\rm DTFT}[x_1 \cdot x_2] = \frac{1}{2\pi} {\rm DTFT}[x_1] \otimes {\rm DTFT}[x_2] \\
\end{aligned}
\]</span></p>
<p>Parseval 定律依然类似成立：</p>
<p><span class="math display">\[
\sum_{n = -\infty}^{+\infty} \|x(n)\|^2 = \frac{1}{2\pi} \int_{-\pi}^{\pi} \|X(\omega)\|^2 \d\omega
\]</span></p>
<h2 id="从有限抽样序列还原信号频谱">从有限抽样序列还原信号频谱</h2>
<p>现在我们基本上解决了时域离散的问题，但是我们要考虑到计算机处理信号的时候时域不可能无限。</p>
<p>我们考虑对数字信号加上一个窗函数：</p>
<p><span class="math display">\[
w(n) := \begin{cases}
1 &amp; 0 \leq n \leq L - 1 \\
0 &amp; {\rm otherwise}
\end{cases}
\]</span></p>
<p>那么 <span class="math inline">\(L\)</span> 长的有限长度数字信号就可以表示为：</p>
<p><span class="math display">\[
x_L = x \cdot w
\]</span></p>
<p>那么显然根据 DTFT 的性质得到 <span class="math inline">\(x_L\)</span> 的 DTFT 为：</p>
<p><span class="math display">\[
X_L(\omega) = \frac{1}{2\pi} ({\rm DTFT}[x] \otimes {\rm DTFT}[w])(\omega)
\]</span></p>
<p>显然：</p>
<p><span class="math display">\[
\begin{aligned}
{\rm DTFT}[w](\omega) &amp;= \sum_{n = -\infty}^{+\infty} w(n)e^{-\j\omega n} = \sum_{n = 0}^{L - 1} e^{-\j\omega n} \\
&amp;= \frac{1 - e^{-\j L\omega}}{1 - e^{-\j\omega}}
\end{aligned}
\]</span></p>
<p>这个窗函数的频谱在周期 <span class="math inline">\([-\pi, \pi]\)</span> 内表现为低频有一个主峰，其余部分有若干指数衰减的副峰。主峰的宽度是绝对值最小两个零点的距离：</p>
<p><span class="math display">\[
\Delta\omega_L = \frac{2\pi}{L}
\]</span></p>
<h3 id="窗宽的限制">窗宽的限制</h3>
<p>现在我们考虑下述数字信号：</p>
<p><span class="math display">\[
x(n) = A_1e^{\j\omega_1 n} + A_2e^{\j\omega_2 n} (0 &lt; \omega_1, \omega_2 &lt; \pi)
\]</span></p>
<p>显然其 DTFT 为：</p>
<p><span class="math display">\[
X(\omega) = 2\pi(A_1\delta(\omega - \omega_1) + A_2\delta(\omega - \omega_2))
\]</span></p>
<p>现在我们将其乘上窗函数得到有限长的数字信号：</p>
<p><span class="math display">\[
x_L(n) = x(n)w(n)
\]</span></p>
<p>其 DTFT 为：</p>
<p><span class="math display">\[
X_L(\omega) = \frac{1}{2\pi}(X \otimes W)(\omega) = A_1W(\omega - \omega_1) + A_2W(\omega - \omega_2)
\]</span></p>
<p>这里我们只考虑 <span class="math inline">\(W\)</span> 的主峰，显然使用窗函数截取之后，频谱上原先是两个冲激的位置变为了两个窗函数频谱主峰。为了保证这两个主峰可以区分，我们要求这两个主峰不重叠。显然这需要 <span class="math inline">\(|\omega_1 - \omega_2|\)</span> 足够大。根据已知的主峰宽度，我们有：</p>
<p><span class="math display">\[
|\omega_1 - \omega_2| &gt; \frac{2\pi}{L}
\]</span></p>
<p>也就是说如果数字信号的最小频率间隔为 <span class="math inline">\(\Delta\omega\)</span>，那么为了保证截取后频谱上各个频率峰可分辨，必须要求窗函数宽度 <span class="math inline">\(L\)</span> 不小于 <span class="math inline">\(2\pi / \Delta\omega\)</span>。</p>
<h3 id="dft-的引入和矩阵形式">DFT 的引入和矩阵形式</h3>
<p>现在我们回到求解有限长数字信号傅立叶变换的问题上。我们继续延续上述 DTFT 的思路。不过我们现在只考虑在 <span class="math inline">\(\omega_k = 2k\pi / N\)</span> 处频谱的取值，即频域 <span class="math inline">\([0, 2\pi]\)</span> 区间内的 <span class="math inline">\(N\)</span> 个特征点：</p>
<p><span class="math display">\[
\begin{aligned}
X_L(\omega_k) &amp;= \frac{1}{2\pi} ({\rm DTFT}[x] \otimes {\rm DTFT}[w])(\omega) \\
&amp;= \frac{1}{2\pi} \int_{-\pi}^{\pi} \left(\sum_{m = -\infty}^{+\infty} x(m)e^{-\j\left(\frac{2k\pi}{N} - \mu\right) m}\right)\left(\sum_{n = 0}^{L - 1} e^{-\j\mu n}\right) \d\mu \\
&amp;= \frac{1}{2\pi} \int_{-\pi}^{\pi} \sum_{n = 0}^{L - 1}\sum_{m = -\infty}^{+\infty} x(m)e^{-\j\frac{2km\pi}{N}}e^{-\j\mu (n - m)} \d\mu \\
&amp;= \frac{1}{2\pi} \sum_{n = 0}^{L - 1}\sum_{m = -\infty}^{+\infty} x(m)e^{-\j\frac{2km\pi}{N}} \int_{-\pi}^{\pi} e^{-\j\mu (n - m)} \d\mu \\
&amp;= \sum_{n = 0}^{L - 1} x(n)e^{-\j\frac{2kn\pi}{N}}
\end{aligned}
\]</span></p>
<p>这里最后一个等号是利用指数函数在周期上的积分除非系数为零，否则积分结果均为零，所以最后只有 <span class="math inline">\(m = n\)</span> 的项被保留。</p>
<p>便于表示，我们把 <span class="math inline">\(X_L(\omega_k)\)</span> 简记为 <span class="math inline">\(X(k)\)</span>。</p>
<p>从而我们就可以做到从有限长的数字信号还原出原信号频谱，这个变换就是<strong>离散傅立叶变换（Discrete Fourier Transformation / DFT）</strong>。</p>
<p>我们注意到这样的一点，就是这里有两个参数是可以独立确定的，即窗函数长度 <span class="math inline">\(L\)</span> 和频域特征点数 <span class="math inline">\(N\)</span>。但实际应用中一般都有 <span class="math inline">\(L = N\)</span>，这主要是因为这样计算方便且 <span class="math inline">\(L \neq N\)</span> 的情况均可以还原成 <span class="math inline">\(L = N\)</span> 的情况。</p>
<hr />
<p>为了论证这一点，我们可以从另外一个角度推导 DFT 公式。也就是回归傅里叶分析的本质，而傅里叶分析的本质就是将函数分解成若干个指数函数的线性组合。之前论述过的 FT 用于分解时域无限的连续信号，而 DFT 则会用于分析时域有限的离散信号。</p>
<p>考虑信号 <span class="math inline">\(f\)</span>，我们在区间 <span class="math inline">\([0, 1]\)</span> 上均匀取 <span class="math inline">\(N\)</span> 个样，组成代表这个信号的向量：</p>
<p><span class="math display">\[
\b{x} = \lv
f(0) &amp; f\left(\frac{1}{N}\right) &amp; \cdots &amp; f\left(\frac{N - 1}{N}\right)
\rv
\]</span></p>
<p>同样的，我们需要对作为基的函数 <span class="math inline">\(e^{2\pi\j kt}\)</span> 也在这些点取样，函数 <span class="math inline">\(e^{2\pi\j kt}\)</span> 取到的样为：</p>
<p><span class="math display">\[
\b{e}_k = \lv
\varepsilon_N^0 &amp; \varepsilon_N^k &amp; \cdots &amp; \varepsilon_N^{(N - 1)k}
\rv
\]</span></p>
<p>这里 <span class="math inline">\(\varepsilon_N\)</span> 表示 <span class="math inline">\(N\)</span> 次单位根。</p>
<p>根据周期性，显然得到：</p>
<p><span class="math display">\[
\b{e}_k = \b{e}_{k + N}
\]</span></p>
<p>所以将 <span class="math inline">\(\b{x}\)</span> 拆分为 <span class="math inline">\(\b{e}_k\)</span> 的线性组合的时候只需要考虑一个周期内的 <span class="math inline">\(\b{e}_k\)</span> 即可，也就是说我们假设存在这样的一系列系数 <span class="math inline">\(\b{X} = \lv X(0) &amp; X(1) &amp; \cdots &amp; X(N - 1)\rv\)</span> 满足（这里的系数 <span class="math inline">\(1 / N\)</span> 是为了简化后续的讨论）：</p>
<p><span class="math display">\[
\b{x} = \frac{1}{N}\sum_{k = 0}^{N - 1} X(k)\b{e}_k
\]</span></p>
<p>如果我们定义这样的一个矩阵：</p>
<p><span class="math display">\[
F_N = \lv \b{e}_0 &amp; \b{e}_1 &amp; \cdots &amp; \b{e}_{N - 1}\rv
\]</span></p>
<p>上述等式实际上就是 <span class="math inline">\(N\b{x} = F_N\b{x}\)</span>。所以要求解系数向量，其实就等价于求解 <span class="math inline">\(F_N\)</span> 的逆矩阵。</p>
<p>考虑这样的数学关系（这里 <span class="math inline">\(\cdot^H\)</span> 表示 Hermit 转置，即共轭转置）：</p>
<p><span class="math display">\[
\b{e}_i^H\b{e}_j = \sum_{k = 0}^{N - 1} (\varepsilon_N^{ik})^*\varepsilon_N^{jk} = \sum_{k = 0}^{N - 1} \varepsilon_N^{(j - i)k} = \begin{cases}
N &amp; i = j \\
\dfrac{1 - \varepsilon_N^{N(j - i)}}{1 - \varepsilon_N^{j - i}} = 0 &amp; i \neq j
\end{cases}
\]</span></p>
<p>这说明 <span class="math inline">\(\dfrac{F_N}{\sqrt{N}}\)</span> 是酉矩阵。即有：</p>
<p><span class="math display">\[
F_N^{-1} = \frac{1}{\sqrt{N}}\left(\frac{F_N}{\sqrt{N}}\right)^{-1} = \frac{1}{\sqrt{N}}\left(\frac{F_N}{\sqrt{N}}\right)^H = \frac{1}{N} (F_N^T)^* = \frac{1}{N} F_N^*
\]</span></p>
<p>所以系数向量就可以表示为：</p>
<p><span class="math display">\[
\b{X} = F_N^* \b{x}
\]</span></p>
<p>对比会发现这个和我们之前推导出来的 DFT 公式是一致的。也就是说我们得到了 <span class="math inline">\(L = N\)</span> 时的 DFT 向量表示。</p>
<hr />
<p>回到先前的问题，我们思考为何 <span class="math inline">\(L \neq N\)</span> 的情况都可以化归为 <span class="math inline">\(L = N\)</span>。</p>
<p>如果 <span class="math inline">\(L &lt; N\)</span>，也就是说窗宽（序列长度）不足，我们可以在序列 <span class="math inline">\(x(n)\)</span> 末尾补零至 <span class="math inline">\(N\)</span> 位得到 <span class="math inline">\(x_D(n)\)</span>，以此计算 DFT：</p>
<p><span class="math display">\[
X_D(k) = \sum_{n = 0}^{N - 1} x_D(n)e^{-\j\frac{2\pi nk}{N}} = \sum_{n = 0}^{L - 1} x_D(n)e^{-\j\frac{2\pi nk}{N}} = \sum_{n = 0}^{L - 1} x(n)e^{-\j\frac{2\pi nk}{N}} = X(k)
\]</span></p>
<p>可见通过补零，补零序列的 DFT 就是原序列的 DFT。所以完全可以认为 <span class="math inline">\(L &lt; N\)</span> 时应化归为 <span class="math inline">\(L = N\)</span>。</p>
<p>而在 <span class="math inline">\(L &gt; N\)</span> 的时候，我们需要使用<strong>回绕</strong>。即定义这样的新序列：</p>
<p><span class="math display">\[
\tilde{x}(n) = \sum_{k \mathop{\equiv} n \mathop{\rm mod} N} x(k)
\]</span></p>
<p>直观而言，就是将原先的过长序列拆为若干长度为 <span class="math inline">\(N\)</span> 的短序列后对齐相加。为了解释此时依然可以化归，我们使用先前得到矩阵形式的 DFT 即可说明。首先我们取 <span class="math inline">\(F_N\)</span>，这里 <span class="math inline">\(N\)</span> 即 DFT 点数，<span class="math inline">\(F_N\)</span> 定义与之前相同。取新矩阵：</p>
<p><span class="math display">\[
F_{N\times L} = \lv F_N &amp; F_N &amp; \cdots \rv
\]</span></p>
<p>即使用 <span class="math inline">\(F_N\)</span> 的列按顺序拼接出一个 <span class="math inline">\(N\)</span> 行 <span class="math inline">\(L\)</span> 列的新矩阵，那么：</p>
<p><span class="math display">\[
{\rm DFT}[x](k) = F_{N\times L}\b{x} = (F_N\lv I_N &amp; I_N &amp; \cdots \rv)\b{x} = F_N\tilde{\b{x}} = {\rm DFT}[\tilde{x}](k)
\]</span></p>
<p>所以回绕序列和原序列具有相同的 DFT。</p>
<p>基于上述讨论，考虑到 <span class="math inline">\(L\)</span> 一般而言是原信号的长度，是一个不能修改的量。而 DFT 的点数 <span class="math inline">\(N\)</span> 则是计算过程中自由选取的参数，是可以随意更改的。为了方便，一般而言直接选定 <span class="math inline">\(N = L\)</span> 以方便计算。</p>
<h3 id="dft-的性质">DFT 的性质</h3>
<p>实际上我们可以发现 DFT 就是对 DTFT 频域一个周期内的取样，即时域从无限变为有限的时候，频域就会变成原先频域一个周期内的取样。这一点对连续信号也是成立的，时域从无限（周期无限）变为有限（有限周期信号）的时候，频域也会变为原先频域一个周期内的取样（周期信号的频域是离散的）。</p>
<p>现在考虑实序列的 DFT，实际上我们考虑 DTFT 即可。令实序列 <span class="math inline">\(x(n)\)</span> 的 DTFT 为 <span class="math inline">\(X(\omega)\)</span>。根据 DTFT 定义：</p>
<p><span class="math display">\[
X(\omega) = \sum_{n = -\infty}^{+\infty} x(n)e^{-\j\omega n}
\]</span></p>
<p>显然：</p>
<p><span class="math display">\[
X(-\omega) = X^*(\omega)
\]</span></p>
<p>另外一个相当重要的性质是：</p>
<p><span class="math display">\[
X(\omega) = X^*(2\pi - \omega)
\]</span></p>
<p>这说明了在周期 <span class="math inline">\([0, 2\pi]\)</span> 上，实序列的 DTFT 和自身共轭对称。这个性质的证明也是简单的：</p>
<p><span class="math display">\[
\begin{aligned}
X(2\pi - \omega) = \sum_{n = -\infty}^{+\infty} x(n)e^{-\j(2\pi - \omega) n} = \sum_{n = -\infty}^{+\infty} x(n)e^{\j\omega n} = X^*(\omega)
\end{aligned}
\]</span></p>
<p>这个性质反映在 DFT 上就是，实序列的偶数点 DFT 序列自身和自身共轭对称。即长度为 <span class="math inline">\(2N\)</span> 的实序列 <span class="math inline">\(x\)</span> 的 DFT 序列 <span class="math inline">\(X\)</span> 满足：</p>
<p><span class="math display">\[
X(N + k) = X^*(N - k)
\]</span></p>
<hr />
<p>DFT 的其他性质和 FT 类似。比如 DFT 是线性的，和共轭及反褶的关系也和 FT 一致，其余类似时域平移、频域平移等性质则自行推导。</p>
<p><code>TODO</code></p>
<h3 id="fft-算法">FFT 算法</h3>
<p>直接计算 <span class="math inline">\(N\)</span> 点 DFT 的时间复杂度为 <span class="math inline">\(O(n^2)\)</span>，但是考虑到 <span class="math inline">\(F_N\)</span> 矩阵的优良性质，应该具有更快速的算法。有一种思路是使用分治，考虑下述数学事实，这里 <span class="math inline">\(X\)</span> 为 <span class="math inline">\(x\)</span> 的 <span class="math inline">\(N\)</span> 点 DFT 序列，<span class="math inline">\(x\)</span> 长度为 <span class="math inline">\(N\)</span>，不妨 <span class="math inline">\(N\)</span> 是偶数：</p>
<p><span class="math display">\[
\begin{aligned}
{\rm DFT}_{n, k}[x(n)](k) &amp;= \sum_{n = 0}^{N - 1} x(n)e^{-\j\frac{2\pi nk}{N}} \\
&amp;= \sum_{r = 0}^{N / 2 - 1} x(2r)e^{-\j\frac{2\pi rk}{N / 2}} + \sum_{r = 0}^{N / 2 - 1} x(2r + 1)e^{-\j\frac{2\pi(r + 1 / 2)k}{N / 2}} \\
&amp;= \sum_{r = 0}^{N / 2 - 1} x(2r)e^{-\j\frac{2\pi rk}{N / 2}} + e^{-\j\frac{2\pi k}{N}}\sum_{r = 0}^{N / 2 - 1} x(2r + 1)e^{-\j\frac{2\pi rk}{N / 2}} \\
&amp;= {\rm DFT}_{n, k}[x(2n)](k) + e^{-\j\frac{2\pi k}{N}}{\rm DFT}_{n, k}[x(2n + 1)](k)
\end{aligned}
\]</span></p>
<p>也就是说，将原序列按照奇偶拆为两个序列，分别作 DFT 后再合并即得到原序列的 DFT。按此分治算法即可得到 <span class="math inline">\(O(n\log n)\)</span> 的 FFT 算法。</p>
<h1 id="laplace-变换与-z-变换">Laplace 变换与 Z 变换</h1>
<p>首先给出两个感性认识，Laplace 变换是拓展的 Fourier 变换，Z 变换是拓展的离散时间 Fourier 变换。</p>
<p>Fourier 变换显然要求连续信号平方可积，但是对于平方积分发散的信号，其进行 FT 后是不收敛的。最简单的让信号 <span class="math inline">\(f\)</span> 平方积分收敛的方式是乘以一个指数衰减 <span class="math inline">\(e^{-\sigma t}(\sigma \in \mathbb R)\)</span>。感性理解就是，大部分信号总是可以用指数信号迫敛的。</p>
<p>此时我们对迫敛后的信号进行 Fourier 变换：</p>
<p><span class="math display">\[
\mathcal{F}_{t, \omega}[f(t)e^{-\sigma t}] = \int_{-\infty}^{+\infty} f(t)e^{-\sigma t}e^{-\j\omega t} \d t = \int_{-\infty}^{+\infty} f(t)e^{-(\sigma + \j\omega) t} \d t
\]</span></p>
<p>此时考虑到 <span class="math inline">\(\sigma\)</span> 的不确定性和 <span class="math inline">\(\omega\)</span> 的任意性，我们取 <span class="math inline">\(s := \sigma + \j\omega \in \mathbb C\)</span>，定义新的变换：</p>
<p><span class="math display">\[
\mathcal{L}[f](s) := \int_{-\infty}^{+\infty} f(t)e^{-st} \d t
\]</span></p>
<p>这就是 Laplace 变换，其为拓展后的 Fourier 变换。Laplace 变换中 <span class="math inline">\(s\)</span> 可以取全复数集，而如果沿用 <span class="math inline">\(\omega\)</span> 是角频率的物理意义，Laplace 变换本质上引入了复频率空间。而如果一个信号 Laplace 变换后的复频率空间的虚轴上全收敛，就说明其 Fourier 变换收敛，此时其频域就是负频率空间虚轴截面。</p>
<hr />
<p>而同样的，DTFT 要求序列之模求和收敛。如果不收敛，我们同样模仿 Laplace 变换的引入，将序列乘以一个指数衰减 <span class="math inline">\(a^{-n}(a &gt; 0)\)</span>，对此时的序列进行 DTFT：</p>
<p><span class="math display">\[
{\rm DTFT}_{n, \omega}[x(n)a^{-n}] = \sum_{n = -\infty}^{+\infty} x(n)a^{-n}e^{-\j\omega n} = \sum_{n = -\infty}^{+\infty} x(n)(ae^{\j\omega})^{-n}
\]</span></p>
<p>同样发现 <span class="math inline">\(z = ae^{\j\omega}\)</span> 取遍全复平面，则不妨定义新变换：</p>
<p><span class="math display">\[
\mathcal{Z}[x](z) := \sum_{n = -\infty}^{+\infty} x(n)z^{-n}
\]</span></p>
<p>此时类似的，Z 变换将变换结果拓展到了整个复平面上。但是和 Laplace 变换后原先 FT 的残余是虚轴不同，Z 变换下 DTFT 的残余是单位圆（即 <span class="math inline">\(a = 1\)</span>）。也就是说，如果 Z 变换下，单位圆上处处收敛，就说明原先信号 DTFT 收敛，此时信号的 DTFT 后频域的一个周期就是单位圆截面。</p>
<hr />
<p>上述讲解的 ZT 是双边 ZT，事实上在应用的时候可能会使用单边 ZT。比如左边 ZT 的表达为：</p>
<p><span class="math display">\[
\mathcal{Z}_L[x](z) := \sum_{n = -\infty}^{0} x(n)z^{-n}
\]</span></p>
<p>右边 ZT 的表达为：</p>
<p><span class="math display">\[
\mathcal{Z}_R[x](z) := \sum_{n = 0}^{+\infty} x(n)z^{-n}
\]</span></p>
<p>一般而言，单边 ZT 中使用最多的是右边 ZT，所以在不引起混淆的时候，可以用单边 ZT 代表右边 ZT。</p>
<h2 id="z-变换的收敛域">Z 变换的收敛域</h2>
<p>Z 变换实际上是一个复平面上的幂级数，所以其具有收敛域（ROC）。</p>
<p>思考两个单边 ZT 的 ROC，这里考虑两个特殊点，即复平面零点 <span class="math inline">\(0\)</span> 与复平面无穷点 <span class="math inline">\(\infty\)</span>。显然左边 ZT 中 <span class="math inline">\(z = 0\)</span> 的时候幂级数收敛至 <span class="math inline">\(0\)</span>，而右边 ZT 中 <span class="math inline">\(z = \infty\)</span> 的时候幂级数收敛至 <span class="math inline">\(0\)</span>。所以左边 ZT 的 ROC 永远包含零点，而右边 ZT 的 ROC 永远包含无穷远点。</p>
<p>此外，考虑这样显然的结论（Abel 定理）。如果幂级数 <span class="math inline">\(\sum_{n = 0}^{+\infty} x(n)z^n\)</span> 在 <span class="math inline">\(z_0\)</span> 处绝对收敛，那么该级数在 <span class="math inline">\(|z| &lt; z_0\)</span> 处均收敛。如果在 <span class="math inline">\(z_0\)</span> 处发散，那么该级数在 <span class="math inline">\(|z| &gt; z_0\)</span> 处发散。那么左边 ZT 的 ROC 的表现为一个圆的内部，右边 ZT 的 ROC 的表现为一个圆的外部。</p>
<p>考虑双边 ZT，其显然可以认为是一个左边 ZT 和右边 ZT 的和，所以其 ROC 只能为两个单边 ZT 的交。考虑到左边 ZT 的 ROC 为圆的内部，右边 ZT 的 ROC 为圆的外部，所以双边 ZT 的 ROC 可以为空集，也可以为某一个圆环。</p>
<hr />
<p>我们需要指出的是，对于同一个 ZT 的结果，只有在指定 ROC 之后才能唯一确定 IZT 的结果。也就是说，必须要指定 ZT 结果和相应的 ROC 才能确定变换前的序列。</p>
<p>考虑某一个 ZT 的结果，假设其极点构成有限集 <span class="math inline">\(\{z_1, z_2, \cdots, z_n\}(|z_i| \leq |z_{i + 1}|)\)</span>。数学上可以证明，所有可能的 ROC 仅可以是 <span class="math inline">\(\{z: |z_i| \leq |z| \leq |z_{i + 1}|\}(0 \leq i \leq n)\)</span>，这里 <span class="math inline">\(z_0 = 0, z_{n + 1} = \infty\)</span>。</p>
<h2 id="z-变换的性质简介">Z 变换的性质简介</h2>
<p>首先简单介绍一些特殊信号的 Z 变换。先考虑单位阶跃信号：</p>
<p><span class="math display">\[
\delta(n) := \begin{cases}
1 &amp; n = 0 \\
0 &amp; n \neq 0
\end{cases}
\Rightarrow \mathcal{Z}[\delta] = 1, {\rm ROC} = \{z: 0 \leq |z| \leq +\infty\}
\]</span></p>
<p>随后是单位阶跃信号：</p>
<p><span class="math display">\[
u(n) := \begin{cases}
1 &amp; n \geq 0 \\
0 &amp; n &lt; 0
\end{cases}
\Rightarrow \mathcal{Z}[u](z) = \frac{1}{1 - z^{-1}}, {\rm ROC} = \{z: |z| &gt; 1\}
\]</span></p>
<p>然后是矩形窗信号：</p>
<p><span class="math display">\[
G_N(n) := \begin{cases}
1 &amp; 0 \leq n &lt; N \\
0 &amp; {\rm otherwise}
\end{cases}
\Rightarrow \mathcal{Z}[G_N](z) = \frac{1 - z^{-N}}{1 - z^{-1}}, {\rm ROC} = \{z: 0 &lt; |z| \leq +\infty\}
\]</span></p>
<p>然后是指数序列的右侧：</p>
<p><span class="math display">\[
\mathcal{Z}_{n, z}[a^nu(n)](z) = \frac{1}{1 - az^{-1}}, {\rm ROC} = \{z: |z| &gt; |a|\}
\]</span></p>
<p>最后是指数序列的左侧：</p>
<p><span class="math display">\[
\mathcal{Z}_{n, z}[-a^nu(-n - 1)](z) = \begin{cases}
\dfrac{1}{1 - az^{-1}} &amp; 0 &lt; |z| &lt; |a| \\
0 &amp; z = 0
\end{cases}, {\rm ROC} = \{z: |z| &lt; |a|\}
\]</span></p>
<hr />
<p>接下来的讨论默认 <span class="math inline">\(X := \mathcal{Z}[x]\)</span>。</p>
<p>ZT 显然是线性的。其时域平移对复频域影响为：</p>
<p><span class="math display">\[
\mathcal{Z}_{n, z}[x(n + m)] = z^mX(z)
\]</span></p>
<h1 id="数字滤波器">数字滤波器</h1>
<p>滤波器我们已经讲解过很多次，但是在理解了离散信号处理的基础上，我们需要说明一下<strong>数字滤波器</strong>和<strong>模拟滤波器</strong>的差别。不过我们首先建立这样的认同，即滤波器可以使用其单位冲激响应唯一代表。</p>
<p>我们在采样部分一直采用的是模拟滤波器的概念，其工作在连续的时域上，具有连续的单位冲激响应，其接受的激励也是连续的模拟信号。从频域上观察其单位冲激响应，显然其单位冲激响应的频域并非周期（这个和非周期信号的频域连续类似，根据时域频域的对偶，时域上连续的单位冲激响应在频域上就不周期）。比如说理想（模拟）低通滤波器在频域上就是一个低频区域的矩形窗，其余部分频域均为零。</p>
<p>接下来我们需要引入新的概念，即数字滤波器。在具体讲解之前，我们先根据我们对模拟滤波器的了解给出一些感性理解。</p>
<ul>
<li><p>数字滤波器是工作在离散时域上的，接受离散激励，具有离散的单位冲激响应</p></li>
<li><p>频域上，其单位冲激响应是周期的，且周期是该滤波器单位冲激响应的采样频率</p></li>
</ul>
<h2 id="数字滤波器的差分方程">数字滤波器的差分方程</h2>
<p>约定这样的记号，<span class="math inline">\(x(n)\)</span> 表示数字滤波器接收到的激励，<span class="math inline">\(y(n)\)</span> 表示数字滤波器作出的响应。</p>
<p>首先我们说明，我们要求滤波器是线性时不变因果系统。线性系统定义先前已经阐述，时不变的含义是无论何时系统接收到相同的激励，其永远给出相同的响应。因果系统则要求系统响应仅依赖于现在及先前的激励，而不依赖于未来未知的激励。所有实际系统都是因果系统。</p>
<p>有时我们要求系统稳定性，即对于任何有界激励都给出有界响应。</p>
<p>基于此，我们考虑数字滤波器。根据其线性时不变及因果性，我们给出数字滤波器需要满足的一般规律，这一般称为滤波器的<strong>差分方程</strong>：</p>
<p><span class="math display">\[
\sum_{k = 0}^N b_ky(n - k) = \sum_{r = 0}^M a_rx(n - r)
\]</span></p>
<p>这里 <span class="math inline">\(N\)</span> 表示滤波器需要的过去输出的个数，一般也称为滤波器的<strong>阶数</strong>。</p>
<p>我们考虑该滤波器的单位冲激响应。如果 <span class="math inline">\(N = 1\)</span>，我们可以注意到在足够大的 <span class="math inline">\(n\)</span> 下，<span class="math inline">\(x(n - r) = \delta(n - r)\)</span> 总是会全部变为零，此时响应为零。也就是说在有限长时间内，滤波器响应总会衰变为零，此时的滤波器称为<strong>有限脉冲响应滤波器</strong>，简称 <strong>FIR 滤波器</strong>。</p>
<p>对应的，如果 <span class="math inline">\(N &gt; 1\)</span>，由于每一个响应都依赖于先前的非零响应，其响应始终不消失，该滤波器则为<strong>无限脉冲响应滤波器</strong>，简称 <strong>IIR 滤波器</strong>。</p>
<h2 id="数字滤波器的流图">数字滤波器的流图</h2>
<p>流图是系统的一种表示方式，没有很深刻的理论需要讲解，这里不赘述。该课程基本仅要求掌握根据差分方程绘制滤波器的 I 型直接实现和 II 型直接实现，根据 PPT 即可很快掌握。</p>
<h2 id="数字滤波器的频率响应">数字滤波器的频率响应</h2>
<p>假设数字滤波器具有单位冲激响应 <span class="math inline">\(h(n)\)</span>，我们先前证明过：</p>
<p><span class="math display">\[
y(n) = (x * h)(n) = \sum_{k = -\infty}^{+\infty} h(k)x(n - k)
\]</span></p>
<p>考虑对两边同时 DTFT，如果将 <span class="math inline">\(x, y, h\)</span> 的 DTFT 分别记作 <span class="math inline">\(X, Y, H\)</span>，则显然有 <span class="math inline">\(Y = XH\)</span>。定义：</p>
<p><span class="math display">\[
H(\omega) = \frac{Y(\omega)}{X(\omega)}
\]</span></p>
<p>为数字滤波器的<strong>频率响应</strong>，频率响应是单位冲激响应的 DTFT。根据 DTFT 可逆，我们实际上也可以说明频率响应唯一代表了一个数字滤波器。然而差分方程的系数理论上也唯一代表了一个数字滤波器。实际上，我们可以使用差分方程系数推导频率响应，即这两者实际等价。</p>
<p>对差分方程两边 DTFT：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{k = 0}^N b_ky(n - k) = \sum_{r = 0}^M a_rx(n - r) \\
\iff&amp; {\rm DTFT}_{n, \omega}\left[\sum_{k = 0}^N b_ky(n - k)\right] = {\rm DTFT}_{n, \omega}\left[\sum_{r = 0}^M a_rx(n - r)\right] \\
\iff&amp; \sum_{k = 0}^N b_k{\rm DTFT}_{n, \omega}[y(n - k)] = \sum_{r = 0}^M a_r{\rm DTFT}_{n, \omega}[x(n - r)] \\
\iff&amp; Y(\omega)\sum_{k = 0}^N b_ke^{-\j k\omega} = X(\omega)\sum_{r = 0}^M a_re^{-\j r\omega} \\
\iff&amp; H(\omega) = \frac{Y(\omega)}{X(\omega)} = \frac{\sum_{r = 0}^M a_re^{-\j r\omega}}{\sum_{k = 0}^N b_ke^{-\j k\omega}}
\end{aligned}
\]</span></p>
<p>频率响应可以用来断定滤波器的通阻性质。比如说具有下述差分方程的数字滤波器：</p>
<p><span class="math display">\[
y(n) = ay(n - 1) + x(n)
\]</span></p>
<p>计算其频率响应：</p>
<p><span class="math display">\[
H(\omega) = \frac{\sum_{r = 0}^M a_re^{-\j r\omega}}{\sum_{k = 0}^N b_ke^{-\j k\omega}} = \frac{e^{\j\omega}}{e^{\j\omega} - a} = \frac{1}{1 - a\cos\omega + \j a\sin\omega}
\]</span></p>
<p>那么：</p>
<p><span class="math display">\[
|H(\omega)| = \frac{1}{\sqrt{1 + a^2 - 2a\cos\omega}}
\]</span></p>
<p>其在区间 <span class="math inline">\([-\pi, \pi]\)</span> 上的图像为：</p>
<p><img src="/uploads/note-of-dsp/4.png" /></p>
<p>其对低频段给出高响应，所以该数字滤波器为低通滤波器。</p>
<div class="note info"><p>显然可以看出频率响应作为单位冲激响应的 DTFT，其是以 <span class="math inline">\(2\pi\)</span> 为周期的函数。所以我们只需要关注一个周期内的函数表现即可，一般选用 <span class="math inline">\([-\pi, \pi]\)</span>。</p>
</div>
<h2 id="数字滤波器的传递函数与零极点图">数字滤波器的传递函数与零极点图</h2>
<p>我们现在研究系统的稳定性，我们给出下述定理。线性时不变系统稳定的充分必要条件为其单位冲激响应 <span class="math inline">\(h(n)\)</span> 满足：</p>
<p><span class="math display">\[
\sum_{k = -\infty}^{+\infty} |h(k)| &lt; +\infty
\]</span></p>
<p>如果单位冲激响应的模之和收敛，假设其收敛为 <span class="math inline">\(A &lt; +\infty\)</span>，考虑一个有界输入 <span class="math inline">\(x(n)\)</span>，其满足 <span class="math inline">\(|x(n)| &lt; B &lt; +\infty\)</span>。那么系统的响应为：</p>
<p><span class="math display">\[
|y(n)| = \left|\sum_{k = -\infty}^{+\infty} h(k)x(n - k)\right| \leq \sum_{k = -\infty}^{+\infty} |h(k)|\cdot|x(n - k)| &lt; B\sum_{k = -\infty}^{+\infty} h(k) = AB
\]</span></p>
<p>得到了系统稳定的结论。</p>
<p>如果单位冲激响应的模之和发散，考虑这样的激励：</p>
<p><span class="math display">\[
x(n) = {\rm sgn}(h(-n))
\]</span></p>
<p>那么：</p>
<p><span class="math display">\[
|y(0)| = \left|\sum_{k = -\infty}^{+\infty} h(k)x(-k)\right| = \left|\sum_{k = -\infty}^{+\infty} h(k){\rm sgn}(h(k))\right| = \left|\sum_{k = -\infty}^{+\infty} |h(k)|\right| = +\infty
\]</span></p>
<p>得到了系统不稳定的结论。</p>
<hr />
<p>这样思考，如果系统的单位冲激响应之模的和不收敛，就意味着我们不能对其进行 DTFT。而我们先前已经介绍过作为 DTFT 拓展的 Z 变换，不妨对用 ZT 代替 DTFT，我们对差分方程两边取 ZT。如果假设 <span class="math inline">\(x, y, h\)</span> 的 ZT 分别为 <span class="math inline">\(X, Y, H\)</span>，仿照之前推导频率响应的方法，不难说明：</p>
<p><span class="math display">\[
H(z) = \frac{Y(z)}{X(z)} = \frac{\sum_{r = 0}^M a_rz^{-r}}{\sum_{k = 0}^N b_kz^{-k}}
\]</span></p>
<p>此时的 <span class="math inline">\(H\)</span> 称为<strong>传递函数</strong>，其为单位冲激响应的 ZT。如果滤波器的传递函数的 ROC 包含了单位圆，意味着其单位冲激响应可以进行 DTFT，也意味着单位冲激响应模之和收敛，这就意味着系统稳定。</p>
<p>从这个角度观察，一个数字滤波器的稳定性等价于其传递函数的 ROC 包含单位圆。</p>
<p>现在我们考虑因果性。显然一个因果数字滤波器的单位冲激响应必然在负数上取零，所以其 ZT 最终退化为右边 ZT，这意味着其 ROC 必然是一个圆的外部。换言之，非因果数字滤波器的单位冲激响应会在负数上取非零，非退化的双边 ZT 的 ROC 不包含无穷远点。从这个角度观察，数字滤波器的因果性等价于 ROC 为某一圆的外部，包含无穷远点。</p>
<hr />
<p>现在考虑 <span class="math inline">\(H(z)\)</span> 的形式，显然其是一个有理分式，其分子为 <span class="math inline">\(z^{-1}\)</span> 的 <span class="math inline">\(M\)</span> 次多项式，分母则是 <span class="math inline">\(N\)</span> 次。那么根据代数基本定理，<span class="math inline">\(H(z)\)</span> 具有 <span class="math inline">\(M\)</span> 个零点和 <span class="math inline">\(N\)</span> 个极点。另外，<span class="math inline">\(0, \infty\)</span> 也可能是零点或者极点。将这些零点和极点绘制在复平面上，则得到了传递函数的零极点图。</p>
<h2 id="由传递函数推算单位冲激响应">由传递函数推算单位冲激响应</h2>
<p>通过传递函数可以推算数字滤波器的差分方程，之后我们可以通过令输入为单位冲激信号的方式求解单位冲激响应。但实际上，我们考虑到传递函数是单位冲激响应的 ZT，而我们已经知道，在给定 ZT 结果和 ROC 之后可以唯一确定 IZT 的结果，而 ROC 可以通过极点来确定。</p>
<h1 id="数模转换">数模转换</h1>
<p>之前讲解的采样与信号复原实际上就已经简单引入了数模转换这个话题。但是当时我们并没有讲解如何处理数字信号（时域离散信号），所以完全采用了模拟信号的视角。现在我们希望能够在理解了数字信号处理的基础上对数模转换进行更深刻的理解。</p>
<p>这里需要提一下，模拟滤波器一般而言成本高，截止频率低的模拟低通滤波器成本则相当高。这一因素决定了实际信号处理往往会<strong>使用高质量的数字信号处理来弥补低成本的模拟抗混叠滤波器</strong>。</p>
<h2 id="抗混叠滤波器">抗混叠滤波器</h2>
<p>我们先前提到过，如果取样频率达不到信号的高频截止频率的两倍则会发生频谱混叠导致无法通过理想低通滤波还原信号。然而现实中的信号的高频截止频率可以很高也可以很低，无法通过统一的采样频率进行采样。面对这种情况，有一种解决方式是引入<strong>抗混叠滤波器</strong>，其作用是滤去信号中过高频率的部分，这样就可以保证后续取样一定不会发生混叠。</p>
<p>抗混叠滤波器是低通滤波器，但是不一定是理想的矩形窗低通滤波器，其频谱表现一般为从低频到高频逐步下降，而非理想矩形窗滤波器的突变。这样做的原因是尽可能保留原信号的所有信息：</p>
<p><img src="/uploads/note-of-dsp/3.png" /></p>
<p>上述图中灰色实线是某信号的频谱，红色虚线是抗混叠滤波器的频谱。</p>
<p>抗混叠滤波器需要和后续的采样器配合使用以保证频谱不混叠。如果后续使用的采样频率过低，则要求抗混叠滤波器的频谱在较低的频段就需要降低到零，这对滤波器设计提出了较高要求，实现成本高。所以即使有抗混叠滤波器，采样频率也不能很低。</p>
<h2 id="过采样与二次采样">过采样与二次采样</h2>
<p>过采样与二次采样就是一种使用高质量数字信号处理弥补低成本模拟抗混叠滤波器的方法。我们考虑这样的实际场景，即需要对某模拟信号以 <span class="math inline">\(2\omega\)</span> 频率进行采样，该信号的重要信息分布于频谱的 <span class="math inline">\([0, \omega)\)</span> 频段。</p>
<p>按照先抗混叠再直接 <span class="math inline">\(2\omega\)</span> 采样的思路，模拟抗混叠滤波器的截止频率必须至多为 <span class="math inline">\(\omega\)</span>，否则会发生频谱混叠，但是这会导致成本过高。</p>
<p>有一种这样的思路，也就是使用很高的采样频率，降低对模拟抗混叠滤波器的截止频率要求，最后再二次取样，将实际的采样频率降回需求值。</p>
<p>比如说我们可以实际使用 <span class="math inline">\(8\omega\)</span> 的采样频率，此时模拟抗混叠滤波器的最高截止频率就放松到了 <span class="math inline">\(4\omega\)</span>。经过模拟抗混叠滤波器和 <span class="math inline">\(8\omega\)</span> 采样后，信号的频谱的 <span class="math inline">\([\omega + 8k\omega, 7\omega + 8k\omega](k \in \mathbb Z)\)</span> 频段实际上混杂着不需要的高频信息，需要过滤。但是注意，此时信号已经是数字信号，所以可以使用数字滤波器处理。</p>
<p>此时使用截止频率为 <span class="math inline">\(\omega\)</span> 的数字滤波器过滤出原信号在低频段的重要信息，再使用 <span class="math inline">\(2\omega\)</span> 频率取样。这样，我们就既做到了抗混叠，也做到了过滤不必要的高频信息。</p>
<p>这里使用远高于二倍高频截止频率的采样频率进行采样的方式称为<strong>过采样</strong>，而二次滤波之后进行的第二次采样就是<strong>二次采样</strong>。这样的方法可以放松对模拟滤波器的要求以降低成本。</p>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
  </entry>
  <entry>
    <title>《GAMES101》学习笔记</title>
    <url>/2021/10/16/note-of-games101/</url>
    <content><![CDATA[<p>这门课是万恶的安主席推荐的，但毕竟已经进入渲染这个计算机方向，这门课必然是首先需要学明白的课程。总之现在这个笔记，既可以是我自己的学习笔记，也是图形学兴趣小组的整理笔记，也可以是技能引导文档，同时也是目前实验室的工作。属于是真的赢麻了。</p>
<span id="more"></span>
<p><span class="math display">\[
\newcommand{\b}{\boldsymbol}
\newcommand{\lv}{\left(\begin{matrix}}
\newcommand{\rv}{\end{matrix}\right)}
\]</span></p>
<h2 id="课程简介">课程简介</h2>
<p>本课程主要分为四个部分，即光栅化、曲线与曲面、光线追踪、动画仿真。</p>
<p><strong>光栅化（Rasterization）</strong>指的是将三维图形实时显示在二维平面上。在图形学中，30 FPS 就可以认为是实时的，低于这个帧率的则认为是离线渲染。</p>
<p><strong>光线追踪（Ray tracing）</strong>指的是像每一个像素发射光，令光线不断反射。这样的技术能够让渲染更加真实，但是效率会更低。使用光线追踪是效果和效率的 Trade-off。</p>
<h3 id="图形学与计算机视觉">图形学与计算机视觉</h3>
<p>从二维图像和三维模型的角度出发，我们认为一切以三维模型为起点的都是<strong>计算机图形学（Computer graphics）</strong>的范畴，而所有从二维图像为起点的都是<strong>计算机视觉（Computer vision）</strong>。特别的，从三维模型出发获得二维图像的称为<strong>渲染（Rendering）</strong>，从三维模型出发获得新的三维模型的可以是<strong>模拟（Simulation）</strong>。但是上述的分类也是粗糙而模糊的。</p>
<h2 id="线性代数回顾">线性代数回顾</h2>
<div class="note success"><p>这里我们默认大家线性代数都挺好的。</p>
</div>
<p>首先明确记号，向量 <span class="math inline">\(\b{a}\)</span> 的长度标记为 <span class="math inline">\(\|\b{a}\|\)</span>。与向量 <span class="math inline">\(\b{a}\)</span> 同方向的单位向量标记为 <span class="math inline">\(\hat{\b{a}}\)</span>，其满足：</p>
<p><span class="math display">\[
\hat{\b{a}} = \frac{\b{a}}{\|\b{a}\|}
\]</span></p>
<p>向量的加减运算、点乘和叉乘运算省略。</p>
<p>另外，该课程明确向量默认为列向量，比如说二维向量表示为：</p>
<p><span class="math display">\[
\b{a} = \lv x \\ y \rv
\]</span></p>
<p>在这个标记下，三维向量的叉乘可以表示为：</p>
<p><span class="math display">\[
\b{a} = \lv \b{a}_x \\ \b{a}_y \\ \b{a}_z \rv, \b{b} = \lv \b{b}_x \\ \b{b}_y \\ \b{b}_z \rv \Rightarrow \b{a}\times\b{b} = \lv \b{a}_y\b{b}_z - \b{b}_y\b{a}_z \\ \b{a}_z\b{b}_x - \b{a}_x\b{b}_z \\ \b{a}_x\b{b}_y - \b{a}_y\b{b}_x \rv
\]</span></p>
<p>此外还需要正交基、矩阵的基本计算等基本知识。</p>
<h2 id="齐次坐标系统">齐次坐标系统</h2>
<p>矩阵可以用于描述线性变换，常见的线性变换包括缩放、反射、切变、旋转。但是注意，在图形学中有一个常见变换并不能简单用矩阵表述，即<strong>平移变换</strong>，其不满足一般的线性变换定义（变换不保原点）。考虑下述二维空间平移：</p>
<p><span class="math display">\[
\begin{cases}
x&#39; = x + \b{t}_x \\
y&#39; = y + \b{t}_y \\
\end{cases}
\]</span></p>
<p>实际上一种解决方式是给点和向量的表述添加一个维度。我们将向量 <span class="math inline">\(\b{a} = \lv x \\ y \rv\)</span> 转换为下述标记：</p>
<p><span class="math display">\[
\b{a} = \lv x \\ y \\ 0 \rv
\]</span></p>
<p>将点 <span class="math inline">\(A(x, y)\)</span> 转换为下述标记：</p>
<p><span class="math display">\[
A = \lv x \\ y \\ 1 \rv
\]</span></p>
<p>并且人为规定第三维度必须归一化，即：</p>
<p><span class="math display">\[
\lv x \\ y \\ w \rv := \lv x / w \\ y / w \\ 1 \rv(w \neq 0)
\]</span></p>
<p>在这种标记下，向量的线性运算得到的依然是向量，点与点的差得到向量，点与点的和得到中点，向量和点的线性运算得到点。这些性质都是符合直觉的。</p>
<p>那么上述的平移变换（变换均指的是对点的变换）在这个标记下就可以表示为：</p>
<p><span class="math display">\[
\lv x&#39; \\ y&#39; \\ 1 \rv = \lv 1 &amp; 0 &amp; \b{t}_x \\ 0 &amp; 1 &amp; \b{t}_y \\ 0 &amp; 0 &amp; 1 \rv \lv x \\ y \\ 1 \rv
\]</span></p>
<p>实际上，上述所有的变换均可以被统一表示为：</p>
<p><span class="math display">\[
\lv x&#39; \\ y&#39; \\ 1 \rv = \lv a &amp; b &amp; \b{t}_x \\ c &amp; d &amp; \b{t}_y \\ 0 &amp; 0 &amp; 1 \rv \lv x \\ y \\ 1 \rv
\]</span></p>
<p>这些变换统称<strong>仿射变换（Affine transformation）</strong>，仿射变换即对某一个点先进行线性变换后再平移的一类变换（考虑到变换复合没有交换律，注意顺序不能变）。仿射变换的矩阵具有一定的结构，即左上角的子阵表示除去平移之外的变换对应的矩阵，右侧的一列则代表平移量。</p>
<p>这种添加维度以表示平移的坐标系统为<strong>齐次坐标</strong>。</p>
<h3 id="三维旋转">三维旋转</h3>
<p>这里着重介绍 Rodrigue 旋转公式，考虑绕轴 <span class="math inline">\(\b{n}\)</span> 逆时针旋转 <span class="math inline">\(\alpha\)</span>，这个变换的矩阵可以表示为：</p>
<p><span class="math display">\[
\b{R}(\b{n}, \alpha) = \cos\alpha \b{I} + (1 - \cos\alpha) \b{n}\b{n}^T + \sin\alpha\lv
0 &amp; -\b{n}_z &amp; \b{n}_y \\
\b{n}_z &amp; 0 &amp; -\b{n}_x \\
-\b{n}_y &amp; \b{n}_x &amp; 0 \\
\rv
\]</span></p>
<p>这是一个三阶矩阵，构成的是齐次坐标意义下的变换矩阵的左上角子阵。</p>
<h2 id="mvp-变换">MVP 变换</h2>
<p>我们的渲染过程一般分为三个部分，即模型变换、视图变换和投影，这一整个变换过程就是 MVP 变换。</p>
<p>模型变换和视图变换一般可以认为是定义相机的位置的过程，定义相机需要三个量：</p>
<ul>
<li><p>位置矢量（Position）<span class="math inline">\(\b{e}\)</span></p></li>
<li><p>相机朝向（Gaze direction）<span class="math inline">\(\hat{\b{g}}\)</span></p></li>
<li><p>向上方向（Up direction）<span class="math inline">\(\hat{\b{t}}\)</span></p></li>
</ul>
<p>位置矢量定义了相机的位置，之后需要使用相机朝向定义观测方向，但是除此之外，我们需要使用向上方向定义相机最后的旋转形态（同一位置且朝向相同的相机依然有一个旋转自由度）。</p>
<p>另外，我们考虑到如果相机和物体进行了完全一致的变换，那么最后渲染结果不应当变化。所以说我们默认模型变换和视图变换最后的结果为：</p>
<ul>
<li><p>相机在原点</p></li>
<li><p>相机朝向 <span class="math inline">\(-z\)</span>，向上方向为 <span class="math inline">\(y\)</span></p></li>
</ul>
<p>为了保证渲染结果不变，该变换需要对物体和相机同时作变换。</p>
<hr />
<p>现在推导模型视图变换的矩阵，考虑原先的相机形态为 <span class="math inline">\((\b{e}, \hat{\b{g}}, \hat{\b{t}})\)</span>。</p>
<p>模型视图变换过程可以这样考虑，即首先将相机平移到原点，随后旋转调整相机。平移的矩阵显然是：</p>
<p><span class="math display">\[
\b{T}_v = \lv
1 &amp; 0 &amp; 0 &amp; -\b{e}_x \\
0 &amp; 1 &amp; 0 &amp; -\b{e}_y \\
0 &amp; 0 &amp; 1 &amp; -\b{e}_z \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\rv
\]</span></p>
<p>写旋转矩阵的时候我们可以先考虑逆矩阵，也就是把规范的相机旋转到 <span class="math inline">\((\hat{\b{g}}, \hat{\b{t}})\)</span> 的视角，这个旋转的矩阵是要求的矩阵的逆矩阵：</p>
<p><span class="math display">\[
\b{R}_v^{-1} = \lv
(\hat{\b{g}} \times \hat{\b{t}})_x &amp; \b{t}_x &amp; -\b{g}_x &amp; 0 \\
(\hat{\b{g}} \times \hat{\b{t}})_y &amp; \b{t}_y &amp; -\b{g}_y &amp; 0 \\
(\hat{\b{g}} \times \hat{\b{t}})_z &amp; \b{t}_z &amp; -\b{g}_z &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\rv
\]</span></p>
<p>我们显然发现 <span class="math inline">\(\b{R}_v^{-1}\)</span> 是正交矩阵（各列相互正交且为单位矩阵），从而就有：</p>
<p><span class="math display">\[
\b{R}_v = (\b{R}_v^{-1})^{T} = \lv
(\hat{\b{g}} \times \hat{\b{t}})_x &amp; (\hat{\b{g}} \times \hat{\b{t}})_y &amp; (\hat{\b{g}} \times \hat{\b{t}})_z &amp; 0 \\
\b{t}_x &amp; \b{t}_y &amp; \b{t}_z &amp; 0 \\
-\b{g}_x &amp; -\b{g}_y &amp; -\b{g}_z &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\rv
\]</span></p>
<p>而最终模型视图变换的矩阵就是：</p>
<p><span class="math display">\[
\b{M}_v = \b{R}_v\b{T}_v
\]</span></p>
<p>从实际意义上而言，模型视图变换的作用是将世界坐标系转换为以相机为基准的相机坐标系。</p>
<hr />
<p>随后发生投影，投影可以分为<strong>正交投影（Orthographic projection）</strong>和<strong>透视投影（Perspective projection）</strong>，分别表示平行光投影和点光源投影。</p>
<p>正交投影基于模型视图变换，此时相机朝向 <span class="math inline">\(-z\)</span>，所以投影之后投影图像应当在 <span class="math inline">\(xy\)</span> 平面上。随后，为了正规化，需要将 <span class="math inline">\(xy\)</span> 平面上的图像平移缩放到正方形 <span class="math inline">\([-1, 1]\times[-1, 1]\)</span> 内。</p>
]]></content>
      <categories>
        <category>科研杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>《人工智能导论》学习笔记</title>
    <url>/1021/06/16/note-of-iai/</url>
    <content><![CDATA[<p>这个文档就是一时兴起想要好好学学人工智能背后的玩意创建的。主要还是记录《人工智能导论》课程的笔记。</p>
<span id="more"></span>
<p>大概随着这个文档越来越饱满，我应该就能看懂<code>paper.md</code>这个诡异的超纲文档了。</p>
<h2 id="搜索问题">搜索问题</h2>
<h3 id="盲目搜索bfs-dfs">盲目搜索（BFS / DFS）</h3>
<p>DFS 优先扩展深度深的节点，BFS 优先扩展深度浅的节点。由于 DFS 往往存在深度限制，所以 DFS 是有可能找不到最优解的，并且最坏情况下 DFS 等价于枚举。而 BFS 在<strong>单位耗散值的有解问题</strong>上一定能找到最优解。</p>
<p>但有的时候搜索树上的相邻节点之间距离并非一致，所以出现了 Dijkstra 算法。这个算法是最短路算法之中较为重要的一个。在 Dijkstra 算法之中，原则是优先扩展<strong>距离起点最近的节点</strong>。</p>
<p>Dijkstra 算法考虑了当前节点与起点的距离，但是实则没有对距离终点的距离进行评估。所以之后可以引入启发式搜索。</p>
<h3 id="启发式搜索a-a">启发式搜索（A / A*）</h3>
<p>所谓启发式，就是引入<strong>启发知识</strong>，也就是对当前节点与目标之间的距离的评估。</p>
<p>在 A 算法之中，我们引入对节点 <span class="math inline">\(n\)</span> 的<strong>评估函数</strong> <span class="math inline">\(f(n)\)</span>：</p>
<p><span class="math display">\[
f(n) = g(n) + h(n)
\]</span></p>
<p>这里 <span class="math inline">\(h(n)\)</span> 就是对当前节点与目标之间距离的评估，也被称为<strong>启发函数</strong>。</p>
<p>上述函数均为<strong>估计值</strong>。我们把相应的实际值（也就是最短路所对应的）分别标记为 <span class="math inline">\(f^*(n), g^*(n), h^*(n)\)</span>。</p>
<p>A 算法的核心为，优先扩展 <span class="math inline">\(f(n)\)</span> 最小的节点。</p>
<p>在算法的具体实现过程之中，定义了<code>OPEN</code>表以及<code>CLOSE</code>表，分别代表<strong>当前考虑扩展的节点</strong>以及<strong>当前暂时不考虑扩展的节点</strong>。一份伪代码实现为：</p>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line">OPEN = [<span class="string">&#x27;s&#x27;</span>] <span class="comment"># &#x27;s&#x27; is the starting node</span></span><br><span class="line">CLOSE = []</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> OPEN.empty():</span><br><span class="line">    <span class="comment"># Select the node with minimum f value</span></span><br><span class="line">    n = OPEN.node_with_min_f()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># n is the expected node</span></span><br><span class="line">    <span class="keyword">if</span> expected(n):</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    </span><br><span class="line">    OPEN.remove(n)</span><br><span class="line">    CLOSE.add(n)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Traverse the neighbors</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> n.neighbor():</span><br><span class="line">        path_len = g(n) + distance(n, m)</span><br><span class="line">        <span class="comment"># Expand the list</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> m <span class="keyword">in</span> OPEN) <span class="keyword">and</span> (<span class="keyword">not</span> m <span class="keyword">in</span> CLOSE):</span><br><span class="line">            OPEN.add(m)</span><br><span class="line">            n.<span class="built_in">next</span> = m</span><br><span class="line">        <span class="comment"># m has been explored before, but it needs update</span></span><br><span class="line">        <span class="keyword">elif</span> (m <span class="keyword">in</span> OPEN) <span class="keyword">and</span> (path_len &lt; g(m)):</span><br><span class="line">            g(m) = path_len</span><br><span class="line">            n.<span class="built_in">next</span> = m</span><br><span class="line">        <span class="comment"># m has been discarded, but it can be reused now</span></span><br><span class="line">        <span class="keyword">elif</span> (m <span class="keyword">in</span> CLOSE) <span class="keyword">and</span> (path_len &lt; g(m)):</span><br><span class="line">            CLOSE.remove(m)</span><br><span class="line">            OPEN.add(m)</span><br><span class="line">            n.<span class="built_in">next</span> = m</span><br><span class="line"><span class="comment"># Fail</span></span><br><span class="line"><span class="keyword">return</span> FAIL</span><br></pre></td></tr></table></figure>
<p>在 A 算法之中，如果满足：</p>
<p><span class="math display">\[
h(n) \leq h^*(n)
\]</span></p>
<p>那么 A 算法就称为 A* 算法。A* 算法的特点就在于<strong>只要初始节点到目标节点有路径，那么算法永远能找到最优解</strong>，而 A 算法并不保证有最优解。</p>
<p>另外给出一个定理：</p>
<blockquote>
<p>对于两个 A* 算法 <span class="math inline">\(A_1, A_2\)</span>，如果对于非目标节点均满足：</p>
<p><span class="math display">\[
h_2(n) &gt; h_1(n)
\]</span></p>
<p>那么 <span class="math inline">\(A_1\)</span> 所扩展的节点数不小于 <span class="math inline">\(A_2\)</span> 所扩展的节点数。</p>
</blockquote>
<h3 id="改进-a-算法">改进 A* 算法</h3>
<p>A* 算法面临的一个问题在于<strong>可能会多次扩展同一个节点</strong>，这就导致了算法的低效，而实际上多次扩展某一个节点的原因在于扩展该节点所使用的路径并非是最短的。</p>
<p>我们可以认为可以使用<strong>单调的</strong>启发函数来解决这一问题，启发函数的单调性指的是三角形法则：</p>
<p><span class="math display">\[
\begin{cases}
    h(n_i) - h(n_j) \leq {\rm distance}(n_i, n_j) \\
    h(t) = 0
\end{cases}
\]</span></p>
<p>这里 <span class="math inline">\(n_j\)</span> 为 <span class="math inline">\(n_i\)</span> 的子节点。</p>
<p>我们可以证明如果 <span class="math inline">\(h\)</span> 是单调的，那么使用这个启发函数的 A* 算法一旦扩展到了某一个节点 <span class="math inline">\(n\)</span>，就已经找到了从起点到这个节点的最短路，也就是说 <span class="math inline">\(g(n) = g^*(n)\)</span>。</p>
<p>实际上还有一个结论，就是满足单调性的 <span class="math inline">\(h\)</span> 必然满足 A* 条件。</p>
<p>基于此改进 A* 算法如下（伪代码表示）：</p>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line">OPEN = [<span class="string">&#x27;s&#x27;</span>] <span class="comment"># &#x27;s&#x27; is the starting node</span></span><br><span class="line">CLOSE = []</span><br><span class="line">f_max = <span class="number">0</span> <span class="comment"># The maximum f value that has been found till now</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> OPEN.empty():</span><br><span class="line">    <span class="comment"># Find the nodes in OPEN with f value less than f_max</span></span><br><span class="line">    NEST = OPEN.with_f_less_than(f_max)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Select the node</span></span><br><span class="line">    <span class="comment"># When the f value has been small enough to be selected into NEST</span></span><br><span class="line">    <span class="comment"># We just need to select the minimum g value now</span></span><br><span class="line">    n = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> NEST.empty():</span><br><span class="line">        n = OPEN.node_with_min_f()</span><br><span class="line">        f_max = f(n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        n = NEST.node_with_min_g()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># n is the expected node</span></span><br><span class="line">    <span class="keyword">if</span> expected(n):</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    </span><br><span class="line">    OPEN.remove(n)</span><br><span class="line">    CLOSE.add(n)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Traverse the neighbors</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> n.neighbor():</span><br><span class="line">        path_len = g(n) + distance(n, m)</span><br><span class="line">        <span class="comment"># Expand the list</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> m <span class="keyword">in</span> OPEN) <span class="keyword">and</span> (<span class="keyword">not</span> m <span class="keyword">in</span> CLOSE):</span><br><span class="line">            OPEN.add(m)</span><br><span class="line">            n.<span class="built_in">next</span> = m</span><br><span class="line">        <span class="comment"># m has been explored before, but it needs update</span></span><br><span class="line">        <span class="keyword">elif</span> (m <span class="keyword">in</span> OPEN) <span class="keyword">and</span> (path_len &lt; g(m)):</span><br><span class="line">            g(m) = path_len</span><br><span class="line">            n.<span class="built_in">next</span> = m</span><br><span class="line">        <span class="comment"># m has been discarded, but it can be reused now</span></span><br><span class="line">        <span class="keyword">elif</span> (m <span class="keyword">in</span> CLOSE) <span class="keyword">and</span> (path_len &lt; g(m)):</span><br><span class="line">            CLOSE.remove(m)</span><br><span class="line">            OPEN.add(m)</span><br><span class="line">            n.<span class="built_in">next</span> = m</span><br><span class="line"><span class="comment"># Fail</span></span><br><span class="line"><span class="keyword">return</span> FAIL</span><br></pre></td></tr></table></figure>
<h2 id="博弈问题对抗搜索">博弈问题（对抗搜索）</h2>
<h3 id="alpha-beta-剪枝"><span class="math inline">\(\alpha-\beta\)</span> 剪枝</h3>
<p>我们在面临双方博弈，需要我方决策的时候，我们可以先搜索一遍所有可能的双方情况并使用专家知识对局面进行评估。由于对方有利就是我方不利，所以在搜索到最底部回溯得到估值的时候，要注意并不是始终取孩子节点的最大值，而是按层数交替取最大值和最小值。</p>
<p>一般而言，根节点要取最大的儿子节点（一般用方形节点代表<strong>极大过程</strong>），下一层要取最小的儿子节点（一般用圆形节点代表<strong>极小过程</strong>），以此类推。</p>
<p>所谓剪枝，就是目前遍历到此，发现继续遍历子节点都不会更新这个节点的估值了，此时就可以剪枝。注意，判定是否剪枝的时候是要和<strong>当前节点的所有祖先</strong>都进行比较的，不能只比较父节点。</p>
<p>不过要注意，在最后给出根节点估值后确定最后决策的时候，<strong>只能沿着决策树走一步</strong>。这是因为你做出决策后决策树可能会改变形态，不能保证后面的决策的估值情况还保证如此。</p>
<h3 id="蒙特卡罗方法">蒙特卡罗方法</h3>
<p><span class="math inline">\(\alpha-\beta\)</span> 剪枝依赖于大量的专家知识，所以在实际应用上也有所局限。其基本的思路是在给定的时限之内不断通过模拟对弈的方式扩展搜索树，最后再给定走步方式。</p>
<p>基本的循环包括以下几个部分：</p>
<ul>
<li>根据前期评估结果选取最有希望的叶子节点</li>
<li>在该叶子节点处随机进行一步，扩展出新叶子节点</li>
<li>从新叶子节点开始随机模拟对弈直到判定出胜负</li>
<li>根据模拟的结果反向更新决策树上各个节点的评估值</li>
</ul>
<p>一般而言，节点的评估值包含两个方面：</p>
<ul>
<li>当前信息下节点是有希望的</li>
<li>深度较浅的节点具有更大的探索可能</li>
</ul>
<p>一般而言可以选择这样的评估方式：</p>
<p><span class="math display">\[
I_j = \overline{X_j} + c\sqrt{\frac{2\ln n}{T_j(n)}}
\]</span></p>
<p>这里 <span class="math inline">\(\overline{X_j}\)</span> 表示经过当前节点的决策路径的胜率，这是一个守成的选项。</p>
<p><span class="math inline">\(n\)</span> 表示当前搜索总次数，<span class="math inline">\(T_j(n)\)</span> 表示当前节点访问次数。</p>
<h2 id="高级搜索">高级搜索</h2>
<h3 id="局部搜索">局部搜索</h3>
<p>局部搜索的意思就是一直往更好的地方走，具体过程为：</p>
<ul>
<li>选择初始点 <span class="math inline">\(x_0\)</span>，以及其相邻可考察点集 <span class="math inline">\(P\)</span>；</li>
<li>只要不满足退出条件，进行下面循环：
<ul>
<li>选择 <span class="math inline">\(P&#39; \subset P\)</span>，取 <span class="math inline">\(P&#39;\)</span> 之中最优解 <span class="math inline">\(x_b\)</span>；</li>
<li>如果 <span class="math inline">\(x_b\)</span> 更优，则切换为考察 <span class="math inline">\(x_b\)</span>，<span class="math inline">\(P\)</span> 修改为 <span class="math inline">\(x_b\)</span> 的相邻考察点集；</li>
<li>否则 <span class="math inline">\(P = P - P&#39;\)</span>；</li>
</ul></li>
<li>输出结果。</li>
</ul>
<h3 id="模拟退火算法">模拟退火算法</h3>
<p>模拟退火实际上是对局部搜索的一个优化。其基本原理来自于液态金属凝固的时候如果降温过快则有可能由于分子没有充分时间排列为结晶态而导致凝固不工整（没有达到最低能状态），而实际工艺会让温度缓慢下降，并且有回升温度的可能，保证大概率凝固为结晶态。</p>
<p>迁移到局部搜索上，为了防止落入局部最小值，我们可以让“温度回升”是一个有概率发生的事情。对于评估函数 <span class="math inline">\(E(i)\)</span>，以及两个状态 <span class="math inline">\(p,q\)</span>，给出从 <span class="math inline">\(p\)</span> 迁移到 <span class="math inline">\(q\)</span> 的概率：</p>
<p><span class="math display">\[
P(p \rightarrow q) = \begin{cases}
1 &amp; E(q) \leq E(p) \\
\exp\left(\dfrac{E(p) - E(q)}{kT}\right) &amp; E(q) &gt; E(p) \\
\end{cases}
\]</span></p>
<p>这里 <span class="math inline">\(k\)</span> 是一个常量，<span class="math inline">\(T\)</span> 是“温度”，指的是优化问题之中的控制参数。</p>
<p>根据物理定律（Boltzmann 分布）实际上我们可以给出定律：</p>
<ul>
<li>同一温度下，物体处于低能量状态的概率高于高能量状态；</li>
<li>温度无限高的时候，物体等概率处于任何状态；</li>
<li>温度无限低的时候，物体等概率处于任何最低能状态；</li>
<li>温度下降的时候，物体进入低能量状态概率上升，进入高能量状态概率下降。</li>
</ul>
<p>所以我们使用模拟退火方法的时候需要尽可能保证：</p>
<ul>
<li>初始能量足够高；</li>
<li>每个温度下状态交换足够充分；</li>
<li>温度的下降足够缓慢。</li>
</ul>
<p>所以算法的基本思路就是：</p>
<ul>
<li>选定初始状态；</li>
<li>随机选定初始状态的某一个相邻状态，考察它和初始状态的评估函数差：
<ul>
<li>如果新状态更优，直接迁移；</li>
<li>如果原状态更优，则按照概率迁移；</li>
</ul></li>
<li>迁移完毕后降温，重复上述迁移步骤直到寻找到满意的状态。</li>
</ul>
<p>这里有些细节的问题需要考量。</p>
<p>首先是<strong>什么是满意的状态</strong>，一般而言最简单的就是设定温度阈值或者降温次数阈值，另外一个是如果多次降温都没有能够让评估函数的变化超过阈值就可以认为稳定了。</p>
<p>其次是<strong>什么时机降温</strong>，上述算法框架之中每次迁移完毕就会降温，但实际上有的时候会进行若干次迁移后才会降温。一般而言我们可以设定迁移次数阈值。</p>
<p>之后是<strong>怎么降温</strong>。等比例降温是最简单的，另外还有一个较为常用的：</p>
<p><span class="math display">\[
t_{k + 1} = \frac{t_k}{1 + \frac{t_k\ln(1 + \delta)}{3\sigma_{t_k}}}
\]</span></p>
<p>最后是<strong>初始温度如何设定</strong>。一般而言较高就可以了。</p>
<h3 id="遗传算法">遗传算法</h3>
<p>遗传算法的本质就是模拟生物进化的过程，通过引入交叉、变异等干扰因素尝试在若干代迭代后获得满意的结果。不过我们首先关注最为重要的<strong>选优</strong>过程的模拟。</p>
<p>考虑一个包含 <span class="math inline">\(N\)</span> 个个体的群体，其中第 <span class="math inline">\(i\)</span> 个个体的适应值为 <span class="math inline">\(F(x_i)\)</span>，那么在进化过程中其被选中的概率为：</p>
<p><span class="math display">\[
p(x_i) = \frac{F(x_i)}{\sum_{j = 1}^N F(x_j)}
\]</span></p>
<p>之后就可以模拟选优，过程为：</p>
<ul>
<li>从 <span class="math inline">\(x_1\)</span> 开始，以 <span class="math inline">\(p(x_1)\)</span> 的概率选择 <span class="math inline">\(x_1\)</span>。若选中，结束模拟，否则继续；</li>
<li>转到 <span class="math inline">\(x_2\)</span>，以 <span class="math inline">\(p(x_1) + p(x_2)\)</span> 的概率选择 <span class="math inline">\(x_2\)</span>。若选中，结束模拟，否则继续；</li>
<li>......</li>
<li>结束模拟</li>
</ul>
<p>这是选出一个染色体的方式，下面介绍如何选出一个群体：</p>
<p>对于每一个个体 <span class="math inline">\(x_i\)</span>，我们用上述方法在 <span class="math inline">\(N\)</span> 个个体之中选取 <span class="math inline">\(\lfloor p(x_i)N\rfloor\)</span> 次。之后按照 <span class="math inline">\(p(x_i)N - \lfloor p(x_i)N\rfloor\)</span> 从大到小排序群体，再取若干个让选出的群体恰好有 <span class="math inline">\(N\)</span> 个个体。</p>
<p>这种方法就是模拟了群体的一次进化，高适应的个体就有高可能得到繁殖（被多次取到）。</p>
<p>另外，交叉和变异则是对表示状态的二进制（或者十进制）数字串进行一定处理。</p>
<p>从而就有了遗传算法的基本框架：</p>
<ul>
<li>给定群体规模 <span class="math inline">\(N\)</span>，交叉概率 <span class="math inline">\(p_c\)</span> 以及变异概率 <span class="math inline">\(p_m\)</span>；</li>
<li>随机生成 <span class="math inline">\(N\)</span> 个染色体作为初始群体，并计算适应值；</li>
<li>下面不断重复循环直到找到合适的解：
<ul>
<li>选优出 <span class="math inline">\(N\)</span> 个染色体成为扩展群体；</li>
<li>按照 <span class="math inline">\(p_c,p_m\)</span> 进行交叉和变异，未变化的染色体保留，形成新群体；</li>
</ul></li>
<li>选取整个进化过程中最适应的染色体作为最后输出。</li>
</ul>
<p>不过我们注意，我们一定要<strong>选取合适的编码方式</strong>，否则可能会因为问题的状态难以描述而导致编码串有过多无用位，从而导致无效变异。</p>
<p>二进制的交叉和变异是简单的，十进制的交叉可以如此：</p>
<ul>
<li>子代 1 的交叉位之后的基因从父代 2 的所有基因之中按顺序取出尚未在子代 1 之中基因；</li>
<li>指定若干的欠缺位，让父代 2 这些位置留空，之后按照父代1的顺序把原来的数字填回去形成子代 2；</li>
<li>指定一个一一对应的映射，以生成子代。</li>
</ul>
<p>变异则可以：</p>
<ul>
<li>指定两个位置，将后面的数字移到前面的指定位置之前；</li>
<li>指定两个位置，交换两个位置上的基因；</li>
<li>随意打乱某一区间。</li>
</ul>
<h2 id="统计机器学习">统计机器学习</h2>
<h3 id="基本概念">基本概念</h3>
<p>现实中的预测问题都可以归纳为在函数空间 <span class="math inline">\(H = \{f \mid f: X \rightarrow Y\}\)</span> 之中寻找最优的预测函数。这里 <span class="math inline">\(X\)</span> 是输入集，其中的元素一般表示预测的基础（已知信息）。而 <span class="math inline">\(Y\)</span> 是输出集，其中的元素一般表示需要预测的结果。</p>
<p>我们假设 <span class="math inline">\(f \in H\)</span> 为最优函数，也就是我们要寻找的。一般这个函数不会已知，但我们可以知道若干对输入输出组 <span class="math inline">\((x_i, y_i)\)</span> 满足 <span class="math inline">\(f(x_i) = y_i \pm {\rm noise}\)</span>（<span class="math inline">\({\rm noise}\)</span> 指的是可能出现的数据扰动）。这些输入输出组构成<strong>训练集</strong>。</p>
<p>统计机器学习的目标就是根据训练集，按照某种算法尝试找一个 <span class="math inline">\(g \in H\)</span>，让 <span class="math inline">\(g\)</span> 尽可能表现类似 <span class="math inline">\(f\)</span>。</p>
<p>统计机器学习可以按照监督的介入分为：</p>
<ul>
<li>监督学习</li>
<li>无监督学习</li>
<li>半 / 弱监督学习</li>
</ul>
<p>监督学习事实上更贴近我们上述的统计机器学习定义，其又可以被分为<strong>回归</strong>（如线性回归、二次回归）以及<strong>分类</strong>。而无监督学习实际上常常被称为<strong>聚类</strong>。</p>
<p>有无监督的差别可以理解为训练集之中的输入输出对 <span class="math inline">\((x_i, y_i)\)</span> 的 <span class="math inline">\(y_i\)</span> 是否明确。如果 <span class="math inline">\(y_i\)</span> 明确，那么这个学习就有监督，否则无监督。</p>
<p>下面解释为何无监督又被称为聚类。由于 <span class="math inline">\(y_i\)</span> 是不给定的，所以我们不能很明确给出一个已知局面具体属于何种类别，但我们对于给定的两个已知局面，我们可以判断其相似性（断定两者是否大概率属于同一类别），进而将类似的输入输出对聚合在一类里面，不类似的尽可能分开，这就是<strong>聚类（clustering）</strong>。所以尽管学习目标都是寻找 <span class="math inline">\(g\)</span> 让模型的预测尽可能准确，但是两者的学习方式是不同的。</p>
<p>之后我们给出两个概念，就是<strong>过拟合</strong>以及<strong>泛化能力</strong>。</p>
<p>过拟合是机器学习要处理的一个重要问题，其描述的就是算法给出了一个相当复杂的函数 <span class="math inline">\(g\)</span>，其在训练集上能够相当准确率地和 <span class="math inline">\(f\)</span> 类似，但是在其余输入上却不够好。泛化能力描述的是这个模型在面对未知输入的时候是否能够做出合理输出的能力。</p>
<h3 id="朴素-bayes-法">朴素 Bayes 法</h3>
<p>这个方法应用在多分类问题上。我们可以认为输入空间为若干 <span class="math inline">\(n\)</span> 维向量的集合 <span class="math inline">\(\boldsymbol X \subset \mathbb R^n\)</span>，输出空间则是若干类别（标签）的集合 <span class="math inline">\(\boldsymbol Y = \{c_1, c_2, \cdots, c_k\}\)</span>。所以说输入 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(\boldsymbol X\)</span> 上的随机变量，输出 <span class="math inline">\(Y\)</span> 是 <span class="math inline">\(\boldsymbol Y\)</span> 上的随机变量。考虑 <span class="math inline">\(X, Y\)</span> 的联合分布 <span class="math inline">\(f(x, y)\)</span>。</p>
<p>我们得出：</p>
<p><span class="math display">\[
P(Y = c_k \mid X = x) = \frac{
    P(X = x \mid Y = c_k)P(Y = c_k)
} {
    \sum_k P(X = x \mid Y = c_k)P(Y = c_k)
}
\]</span></p>
<p>这个概率实际上是在给定输入 <span class="math inline">\(X = x\)</span> 的时候，输出 <span class="math inline">\(Y = c_k\)</span> 的后验概率。所有的先验概率来源于训练集，也就是用频率近似概率。</p>
<p>我们确定最后的输出的方式是寻找令后验概率最大的 <span class="math inline">\(c_k\)</span>。由于上述分母保持常数，所以输出：</p>
<p><span class="math display">\[
y = \arg\max_{c_k} P(X = x \mid Y = c_k)P(Y = c_k)
\]</span></p>
<p>但是我们这里要注意到先验概率之中的 <span class="math inline">\(P(X = x \mid Y = c_k)\)</span> 项，其复杂度随着 <span class="math inline">\(n\)</span> 的上升而指数上升。但是我们可以假设 <span class="math inline">\(X\)</span> 的各个维度是独立的，所以我们可以得到：</p>
<p><span class="math display">\[
\begin{aligned}
P(X = x \mid Y = c_k) &amp;= P\left(X^{(1)} = x^{(1)}, X^{(2)} = x^{(2)}, \cdots, X^{(n)} = x^{(n)} \ \middle| \  Y = c_k\right) \\
&amp;= \prod_{j = 1}^n P\left(X^{(j)} = x^{(j)} \ \middle| \ Y = c_k\right)
\end{aligned}
\]</span></p>
<p>最终给出的 <strong>Bayes 分类器</strong>为： <span class="math display">\[
y = \arg\max_{c_k} P(Y = c_k)\prod_{j = 1}^n P\left(X^{(j)} = x^{(j)} \ \middle| \ Y = c_k\right)
\]</span></p>
<p>这里给出<strong>平滑</strong>的概念。也就是如果训练集中如果没有出现过某一个 case，这个时候 case 的频率为 <span class="math inline">\(0\)</span>，但是显然我们不能把概率估计为 <span class="math inline">\(0\)</span>，这个时候会引入平滑。这里给出一个例子：</p>
<p><span class="math display">\[
P_\lambda\left(X^{(j)} = a_{jl} \ \middle| \ Y = c_k\right) = \frac{
    \sum_{i = 1}^N {\rm idx}\left(x_i^{(j)} = a_{jl}, y_i = c_k\right) + \lambda
} {
    \sum_{i = 1}^N {\rm idx}(y_i = c_k) + S_j\lambda
}
\]</span></p>
<p><span class="math inline">\({\rm idx}\)</span> 函数为<strong>示性函数</strong>，其参数为布尔表达式，为真的时候函数返回 <span class="math inline">\(1\)</span>，否则返回 <span class="math inline">\(0\)</span>。</p>
<p>这里 <span class="math inline">\(S_j\)</span> 为 <span class="math inline">\(x^{(j)}\)</span>（输入第 <span class="math inline">\(j\)</span> 维）的取值集合 <span class="math inline">\(\{a_{j1}, a_{j2}, \cdots, a_{jS_j}\}\)</span> 的大小。</p>
<p>这里 <span class="math inline">\(\lambda\)</span> 是平滑系数，一般取 <span class="math inline">\(\lambda = 1\)</span>，此时平滑成为 <strong>Laplace 平滑</strong>。</p>
<h3 id="支持向量机svm">支持向量机（SVM）</h3>
<p>SVM 是一个适用于二分类问题的计算模型。</p>
<p>给定线性可分训练集 <span class="math inline">\(T = \{(\boldsymbol x_1, y_1), (\boldsymbol x_2, y_2), \cdots, (\boldsymbol x_N, y_N)\}\)</span>，这里 <span class="math inline">\(\boldsymbol x_i \in X = \mathbb R^n\)</span> 以及 <span class="math inline">\(y_i \in Y = \{1, -1\}\)</span>。这里我们称 <span class="math inline">\(1\)</span> 为正类，<span class="math inline">\(-1\)</span> 为负类。</p>
<p>我们希望寻找一个超平面 <span class="math inline">\(\boldsymbol w^{*T}\boldsymbol x + b^* = 0\)</span>，给定决策函数：</p>
<p><span class="math display">\[
f(\boldsymbol x) = {\rm sgn}(\boldsymbol w^{*T}\boldsymbol x + b^*)
\]</span></p>
<p>这就是<strong>线性可分支持向量机</strong>。</p>
<p>为了评估一个超平面 <span class="math inline">\(\boldsymbol w^T\boldsymbol x + b = 0\)</span>，我们给定 <span class="math inline">\(T\)</span> 之中的一个样本点 <span class="math inline">\((x_i, y_i)\)</span>，定义<strong>函数间隔</strong>：</p>
<p><span class="math display">\[
\hat\gamma_i = y_i(\boldsymbol w^T\boldsymbol x_i + b)
\]</span></p>
<p>定义<strong>几何间隔</strong>：</p>
<p><span class="math display">\[
\gamma_i = y_i\left(\frac{\boldsymbol w^T}{\|\boldsymbol w\|}\boldsymbol x_i + \frac{b}{\|\boldsymbol w\|}\right)
\]</span></p>
<p>上述定义是针对单个样本点的，所以对于整个训练集 <span class="math inline">\(T\)</span>，定义：</p>
<p><span class="math display">\[
\begin{cases}
    \hat\gamma = \min_i \hat\gamma_i \\
    \gamma = \min_i \gamma_i \\
\end{cases}
\]</span></p>
<p>这也就是训练集和超平面的函数间隔以及几何间隔。这两种间隔之间相差 <span class="math inline">\(\|\boldsymbol w\|\)</span> 倍。</p>
<p>我们选择超平面的标准就是<strong>最大化超平面和训练集的间隔</strong>，也就是求取 <span class="math inline">\(\max_{\boldsymbol w, b}\gamma\)</span>。由于 <span class="math inline">\(\boldsymbol w, b\)</span> 可以成比例缩放，所以说我们完全可以假设 <span class="math inline">\(\hat\gamma = 1\)</span>，从而最优化问题转化为最大化 <span class="math inline">\(1 / \|\boldsymbol w\|\)</span>，等价于最小化 <span class="math inline">\(1 / 2\|\boldsymbol w\|^2\)</span>。所以说问题就是求解 <span class="math inline">\(\min_{\boldsymbol w, b} 1 / 2\|\boldsymbol w\|^2\)</span>。</p>
<p>这里由于 <span class="math inline">\(\hat\gamma = 1\)</span>，所以说总是存在 <span class="math inline">\((\boldsymbol x_i, y_i)\)</span> 满足 <span class="math inline">\(y_i(\boldsymbol w^T\boldsymbol x_i + b) = \hat\gamma = 1\)</span>，这个向量就是<strong>支持向量</strong>。</p>
<p>SVM 的学习过程，可以先定义 Lagrange 函数：</p>
<p><span class="math display">\[
L(\boldsymbol w, b, \boldsymbol\alpha) = \frac{1}{2}\|\boldsymbol w\|^2 + \sum_{i = 1}^N \alpha_i[1 - y_i(\boldsymbol w^T\boldsymbol x_i + b)]
\]</span></p>
<p>这里 <span class="math inline">\(\alpha_i \geq 0\)</span>，并且 <span class="math inline">\(\boldsymbol\alpha = (\alpha_1, \alpha_2, \cdots, \alpha_N)^T\)</span> 为 Lagrange 乘子向量。</p>
<p>我们知道：</p>
<p><span class="math display">\[
\max_\boldsymbol\alpha L(\boldsymbol w, b, \boldsymbol\alpha) =
\begin{cases}
    \dfrac{1}{2}\|\boldsymbol w\|^2 &amp; {\rm when\ some\ requirements\ are\ satisfied} \\
    \infty &amp; {\rm otherwise}
\end{cases}
\]</span></p>
<p>所以说 <span class="math inline">\(\min_{\boldsymbol w, b}\max_\alpha L(\boldsymbol w, b, \boldsymbol\alpha)\)</span> 与原问题等价。</p>
<p>另外，我们断定：</p>
<p><span class="math display">\[
\min_{\boldsymbol w, b} L(\boldsymbol w, b, \boldsymbol\alpha) \leq L(\boldsymbol w, b, \boldsymbol\alpha) \leq \max_\boldsymbol\alpha L(\boldsymbol w, b, \boldsymbol\alpha)
\]</span></p>
<p>所以我们有：</p>
<p><span class="math display">\[
\max_\boldsymbol\alpha\min_{\boldsymbol w, b} L(\boldsymbol w, b, \boldsymbol\alpha) \leq \min_{\boldsymbol w, b}\max_\boldsymbol\alpha L(\boldsymbol w, b, \boldsymbol\alpha)
\]</span></p>
<p>这个等号成立的条件为 <strong>KKT 条件</strong>。所以我们将问题转化为求 <span class="math inline">\(\max_\boldsymbol\alpha\min_{\boldsymbol w, b} L(\boldsymbol w, b, \boldsymbol\alpha)\)</span>。</p>
<p>我们令 <span class="math inline">\(L(\boldsymbol w, b, \boldsymbol\alpha)\)</span> 对 <span class="math inline">\(\boldsymbol w, b\)</span> 偏导为 <span class="math inline">\(0\)</span> 并带入就将问题转化为：</p>
<p><span class="math display">\[
\max_\boldsymbol\alpha\left[-\frac{1}{2}\sum_{i = 1}^N \sum_{j = 1}^N \alpha_i\alpha_jy_iy_j(\boldsymbol x_i^T\boldsymbol x_j) + \sum_{i = 1}^N \alpha_i\right]
\]</span></p>
<p>这里的约束条件为：</p>
<p><span class="math display">\[
\sum_{i = 1}^N \alpha_iy_i = 0\ (\alpha_i \geq 0)
\]</span></p>
<p>我们据此获得 <span class="math inline">\(\alpha^*\)</span>，从而我们可以计算：</p>
<p><span class="math display">\[
\begin{cases}
    \boldsymbol w^* = \sum_{i = 1}^N \alpha_i^*y_i\boldsymbol x_i \\
    b^* = y_j - \sum_{i = 1}^N \alpha_i^*y_i(\boldsymbol x_i^T\boldsymbol x_j)\ (\alpha_j^* \neq 0)
\end{cases}
\]</span></p>
<p>但是有的时候这些点并不能被线性超平面完全分隔，所以说 <span class="math inline">\(y_i(\boldsymbol w^T\boldsymbol x_i + b) \geq 1\)</span> 并不能处处满足，所以需要引入<strong>松弛变量</strong>：</p>
<p><span class="math display">\[
y_i(\boldsymbol w^T\boldsymbol x_i + b) \geq 1 - \xi_i
\]</span></p>
<p>为了尽量减小 <span class="math inline">\(\xi_i\)</span> 的影响，所以我们可以把优化目标改为：</p>
<p><span class="math display">\[
\min_{\boldsymbol w, b, \xi}\left(\frac{1}{2}\|\boldsymbol w\|^2 + C\sum_{i = 1}^N \xi_i\right)
\]</span></p>
<p>这种处理方式称为<strong>软间隔最大化</strong>，这里 <span class="math inline">\(C &gt; 0\)</span> 为惩罚参数，<span class="math inline">\(C\)</span> 越大惩罚力度越大。</p>
<p>按照线性可分 SVM 的方法，问题转化为：</p>
<p><span class="math display">\[
\max_\alpha\left[-\frac{1}{2}\sum_{i = 1}^N \sum_{j = 1}^N \alpha_i\alpha_jy_iy_j(\boldsymbol x_i^T\boldsymbol x_j) + \sum_{i = 1}^N \alpha_i\right]
\]</span></p>
<p>这里的约束条件为：</p>
<p><span class="math display">\[
\sum_{i = 1}^N \alpha_iy_i = 0\ (0 \leq \alpha_i \leq C)
\]</span></p>
<p>我们据此获得 <span class="math inline">\(\alpha^*\)</span>，从而我们可以计算：</p>
<p><span class="math display">\[
\begin{cases}
    \boldsymbol w^* = \sum_{i = 1}^N \alpha_i^*y_i\boldsymbol x_i \\
    b^* = y_j - \sum_{i = 1}^N \alpha_i^*y_i(\boldsymbol x_i^T\boldsymbol x_j)\ (0 &lt; \alpha_j^* &lt; C)
\end{cases}
\]</span></p>
<p><span class="math inline">\(\alpha_i^* &gt; 0\)</span> 对应的 <span class="math inline">\(\boldsymbol x_i\)</span> 是支持向量。</p>
<ul>
<li>若 <span class="math inline">\(\alpha_i^* = 0\)</span>，则不是支持向量（对应曲线外侧的点）</li>
<li>若 <span class="math inline">\(0 &lt; \alpha_i^* &lt; C\)</span>，则 <span class="math inline">\(\xi_i = 0\)</span>，那么 <span class="math inline">\(\boldsymbol x_i\)</span> 在间隔边界上，是支持向量（对应两条虚线上的点）</li>
<li>若 <span class="math inline">\(\alpha_i^* = C\)</span>，那么 <span class="math inline">\(\boldsymbol x_i\)</span> 也是支持向量
<ul>
<li>若 <span class="math inline">\(0 &lt; \xi_i &lt; 1\)</span>，则分类正确（对应在己方虚线和实线之间的点）</li>
<li>若 <span class="math inline">\(\xi_i = 1\)</span>，则在超平面上（对应在实线上的点）</li>
<li>若 <span class="math inline">\(\xi_i &gt; 1\)</span>，则被误分（对应在实线和对方虚线之间的点）</li>
</ul></li>
</ul>
<p>这里给出一个结论，也就是样本点到软间隔边界（虚线边界）的距离为 <span class="math inline">\(\xi_i / \|\boldsymbol w\|\)</span>。</p>
<p>另外一方面，我们考虑使用非线性的方式分割数据点。事实上就是尝试建立一个非线性映射将原空间的数据点映射到新空间上，这些数据点在新空间上线性可分。</p>
<p>考虑使用映射 <span class="math inline">\(\phi: X \rightarrow H\)</span> 将输入 <span class="math inline">\(\boldsymbol x \in X\)</span> 映射到新空间 <span class="math inline">\(H\)</span> 上，这里把 <span class="math inline">\(K(\boldsymbol x, \boldsymbol y) := \phi(\boldsymbol x)^T\phi(\boldsymbol y)\)</span> 称为<strong>核函数</strong>。这个时候所有的与内积相关的运算均应该使用核函数进行。</p>
<p>按照线性可分 SVM 的方法，问题转化为：</p>
<p><span class="math display">\[
\max_\alpha\left[-\frac{1}{2}\sum_{i = 1}^N \sum_{j = 1}^N \alpha_i\alpha_jy_iy_jK(\boldsymbol x_i, \boldsymbol x_j) + \sum_{i = 1}^N \alpha_i\right]
\]</span></p>
<p>这里的约束条件为：</p>
<p><span class="math display">\[
\sum_{i = 1}^N \alpha_iy_i = 0\ (0 \leq \alpha_i \leq C)
\]</span></p>
<p>我们据此获得 <span class="math inline">\(\alpha^*\)</span>，从而我们可以计算：</p>
<p><span class="math display">\[
b^* = y_j - \sum_{i = 1}^N \alpha_i^*y_iK(\boldsymbol x_i, \boldsymbol x_j)\ (0 &lt; \alpha_j^* &lt; C)
\]</span></p>
<p>原有的决策函数之中含有内积，所以也需要将其修改为：</p>
<p><span class="math display">\[
f(\boldsymbol x) = {\rm sgn}\left(\sum_{i = 1}^N \alpha_i^*y_iK(\boldsymbol x_i, \boldsymbol x) + b^*\right)
\]</span></p>
<p>常用的核函数包括<strong>多项式核函数</strong>：</p>
<p><span class="math display">\[
K(\boldsymbol x, \boldsymbol y) = (\boldsymbol x^T\boldsymbol y + 1)^p
\]</span></p>
<p>以及<strong>高斯核函数</strong>：</p>
<p><span class="math display">\[
K(\boldsymbol x, \boldsymbol y) = \exp\left(-\frac{\|\boldsymbol x - \boldsymbol y\|^2}{2\sigma^2}\right)
\]</span></p>
<h3 id="决策树">决策树</h3>
<p>我们定义随机变量 <span class="math inline">\(X\)</span> 的熵为：</p>
<p><span class="math display">\[
H(X) = -\sum_{i = 1}^n p_i\log p_i
\]</span></p>
<p>当概率由训练集 <span class="math inline">\(D\)</span> 给出，该熵可以标记为 <span class="math inline">\(H(D)\)</span>。</p>
<p>之后给出条件熵：</p>
<p><span class="math display">\[
H(Y \mid X) = \sum_{i = 1}^n P(X = x_i)H(Y \mid X = x_i)
\]</span></p>
<p>这表示的是已经知道 <span class="math inline">\(X\)</span> 的时候 <span class="math inline">\(Y\)</span> 的不确定性。</p>
<p>之后定义特征 <span class="math inline">\(A\)</span> 对数据集 <span class="math inline">\(D\)</span> 的<strong>信息增益</strong>为：</p>
<p><span class="math display">\[
g(D, A) = H(D) - H(D \mid A)
\]</span></p>
<p>这实际上表示的是给定特征 <span class="math inline">\(A\)</span> 的时候数据集 <span class="math inline">\(D\)</span> 不确定性减少的程度。</p>
<p>假设有训练集 <span class="math inline">\(D\)</span>，有 <span class="math inline">\(K\)</span> 个类 <span class="math inline">\(C_k\)</span>，特征 <span class="math inline">\(A\)</span> 有 <span class="math inline">\(n\)</span> 个取值 <span class="math inline">\(a_i\)</span>，特征 <span class="math inline">\(A\)</span> 的不同取值将 <span class="math inline">\(D\)</span> 划分为 <span class="math inline">\(n\)</span> 个子集 <span class="math inline">\(D_i\)</span>，记 <span class="math inline">\(D_i\)</span> 中属于 <span class="math inline">\(C_k\)</span> 类的样本集合为 <span class="math inline">\(D_{ik}\)</span>，那么：</p>
<p><span class="math display">\[
\begin{aligned}
    g(D, A) &amp;= H(D) - H(D \mid A) \\
    &amp;= -\sum_{k = 1}^K \frac{|C_k|}{|D|}\log\frac{|C_k|}{|D|} + \sum_{i = 1}^n \frac{|D_i|}{|D|}\left(\sum_{k = 1}^K \frac{|D_{ik}|}{|D_i|}\log\frac{|D_{ik}|}{|D_i|}\right)
\end{aligned}
\]</span></p>
<p>下面介绍 ID3 算法，这个算法可以用于生成决策树：</p>
<ul>
<li>如果 <span class="math inline">\(D\)</span> 之中所有例子属于同一类或者没有用于判断的特征，则返回单节点树，类标记为实例数最多的类；</li>
<li>选择信息增益最大的特征 <span class="math inline">\(A_g\)</span>，其信息增益为 <span class="math inline">\(\delta_A\)</span>；</li>
<li>如果 <span class="math inline">\(\delta_A\)</span> 小于阈值 <span class="math inline">\(\varepsilon\)</span>，那么置单节点决策树，类标记为实例数最多的类；</li>
<li>否则按照特征取值分割训练集，如果某个分割后的块为空，那么构建单节点子树，类标记为 <span class="math inline">\(D\)</span> 实例数最多的类。若非空则构建子树，递归上述过程。</li>
</ul>
<p>这样的算法倾向于选择分支比较多的属性。</p>
<p>所以定义<strong>信息增益比</strong>：</p>
<p><span class="math display">\[
g_R(D, A) = \frac{g(D, A)}{H_A(D)}
\]</span></p>
<p>将 ID3 算法之中的信息增益换成信息增益比则得到 C4.5 算法。</p>
<p>这种方法生成的决策树可能产生过拟合，所以需要一定程度上的剪枝。剪枝的基本流程在于找到一个父节点，剪取其下一代后将其作为新的叶子节点，其类型标记为其原来对应的子树中量最大的类。</p>
<p>在数据量足够大的时候，可以使用验证集进行剪枝，也就是不断使用验证集剪枝直到性能下降。如果数据量不够，则使用训练集，从下往上缩节点，直到损失函数回升。损失函数定义：</p>
<p><span class="math display">\[
C_a(T) = \sum_{t = 1}^{|T|}N_tH_t(T) + a|T|
\]</span></p>
<p>这里经验熵定义为：</p>
<p><span class="math display">\[
H_t(T) = -\sum_k \frac{N_{tk}}{N_t}\log\frac{N_{tk}}{N_t}
\]</span></p>
<p>这里某一个节点 <span class="math inline">\(t\)</span> 的样本数为 <span class="math inline">\(N_t\)</span>，其中 <span class="math inline">\(k\)</span> 类的样本数为 <span class="math inline">\(N_{tk}\)</span>。</p>
<h2 id="神经网络与深度学习">神经网络与深度学习</h2>
<h3 id="基本神经元结构">基本神经元结构</h3>
<p>一个神经网络中的神经元一般接受多个输出并产生一个输出，一般而言其数学表达为：</p>
<p><span class="math display">\[
y = g\left(\sum_{i = 1}^n w_ix_i + b\right)
\]</span></p>
<p>这里函数 <span class="math inline">\(g\)</span> 一般是非线性的，称为<strong>激活函数</strong>。激活函数常见的有 sigmoid 等。</p>
<h3 id="反向传播算法bp">反向传播算法（BP）</h3>
<p>训练一个多层神经网络可以分为两步，首先是正向从输入计算出输出，和标准输出对比，算出损失函数（衡量实际输出和标准输出的差别），这是<strong>正向传播</strong>。之后就是根据差别的大小，计算出网络中各个权重对最终输出的偏导数，从而更新权重值，这是<strong>反向传播</strong>。</p>
<p>一般而言我们常常使用均方误差评价输出，也就是说对于某一层神经元以及某一个样本 <span class="math inline">\(d\)</span>，标记其中第 <span class="math inline">\(j\)</span> 个神经元的实际输出为 <span class="math inline">\(o_j\)</span>，理想输出为 <span class="math inline">\(t_j\)</span>，那么损失函数为：</p>
<p><span class="math display">\[
E_d(\boldsymbol w) = \frac{1}{2}\sum_j (t_j - o_j)^2
\]</span></p>
<p>根据损失函数，权重 <span class="math inline">\(w_{ji}\)</span>（第 <span class="math inline">\(j\)</span> 个神经元对第 <span class="math inline">\(i\)</span> 个输入的权重）的更新量为：</p>
<p><span class="math display">\[
\Delta w_{ji} = -\eta\frac{\partial E_d}{\partial w_{ji}}
\]</span></p>
<p>这里 <span class="math inline">\(0 &lt; \eta &lt; 1\)</span> 称为<strong>学习率</strong>。</p>
<p>我们设置一个中间量：</p>
<p><span class="math display">\[
n_j := \sum_iw_{ji}x_{ji} + b_j
\]</span></p>
<p>也就是未激活的神经元输出。那么我们知道：</p>
<p><span class="math display">\[
\frac{\partial E_d}{\partial w_{ji}} = \frac{\partial E_d}{\partial n_j}\frac{\partial n_j}{\partial w_{ji}} = \frac{\partial E_d}{\partial n_j}x_{ji}
\]</span></p>
<p>下面我们对输出层和隐含层分别计算损失函数对未激活输出的偏导数。</p>
<p>如果该层为输出层，那么我们进一步展开：</p>
<p><span class="math display">\[
\frac{\partial E_d}{\partial n_j} = \frac{\partial E_d}{\partial o_j}\frac{\partial o_j}{\partial n_j} = \frac{\partial}{\partial o_j}\left(\frac{1}{2}\sum_k(t_k - o_k)^2\right)\frac{\partial \sigma(n_j)}{\partial n_j} = -(t_j - o_j)o_j(1-o_j)
\]</span></p>
<p>这里默认激活函数为 sigmoid 函数。</p>
<p>如果该层为隐藏层，我们记其下游层的神经元构成集合 <span class="math inline">\(D\)</span>。作如下展开：</p>
<p><span class="math display">\[
\begin{aligned}
\frac{\partial E_d}{\partial n_j} &amp;= \sum_{k \in D}\frac{\partial E_d}{\partial n_k}\frac{\partial n_k}{\partial o_j}\frac{\partial o_j}{\partial n_j} \\
&amp;= \sum_{k \in D}\frac{\partial E_d}{\partial n_k}\frac{\partial}{\partial o_j}\left(\sum_l w_{kj}o_j + b\right)\frac{\partial\sigma(n_j)}{\partial n_j} \\
&amp;= \sum_{k \in D}\frac{\partial E_d}{\partial n_k}w_{kj}o_j(1 - o_j) \\
&amp;= o_j(1 - o_j)\sum_{k \in D}\frac{\partial E_d}{\partial n_k}w_{kj}
\end{aligned}
\]</span></p>
<p>这里还有一项偏导数实则可以继续按照上述的方式递推计算，直到计算到输出层。</p>
<p>这里额外提一下，均方误差只是一个选择，在分类问题中，更常用的是<strong>交叉熵误差</strong>：</p>
<p><span class="math display">\[
H_\boldsymbol t(\boldsymbol o) = -\sum_i t_i\log(o_i)
\]</span></p>
<h3 id="过拟合问题与正则化">过拟合问题与正则化</h3>
<p>过拟合问题在之前有过说明，在深度学习之中减少过拟合的一个方法就是在损失函数之中加入正则项：</p>
<p><span class="math display">\[
E_d(\boldsymbol w) = \frac{1}{2}\sum_k(t_k - o_k)^2 + \|\boldsymbol w\|
\]</span></p>
<p>另外还有引入 Dropout 以及引入验证集的方式，这里均不展开。</p>
<h3 id="卷积神经网络cnn">卷积神经网络（CNN）</h3>
<p><code>TODO</code></p>
<h3 id="循环神经网络rnn">循环神经网络（RNN）</h3>
<p><code>TODO</code></p>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
  </entry>
  <entry>
    <title>《计算机网络原理》学习笔记</title>
    <url>/1021/09/13/note-of-net/</url>
    <content><![CDATA[<p>网原总之是一个没打算认真学的专业课，因为真的对网络没有很大的兴趣。再加上上学期曾经看着迅哥哥他们被网原折磨，自己也没什么信心能学好这门专业课。</p>
<p>这个笔记完全基于上一届流传下来的《网原干饭背诵》，在此基础上对重点做一些标记做一些讲解，反正是个背书课，那么就只能一点一点背了。根据前人经验，这个笔记会把比较重要的东西用星号标注出来。</p>
<span id="more"></span>
<h1 id="计算机网络的历史和新进展">计算机网络的历史和新进展</h1>
<h2 id="背诵-1-网络基础">【背诵 1 】网络基础</h2>
<ul>
<li><p>网络所提供的最基本服务为<strong>信息传递</strong>，不同的网络依据其提供的服务进行区分。而区分服务的依据则包括功能、延迟、带宽等各种<strong>外部特性</strong>。</p></li>
<li><p>网络依据<strong>空间距离</strong>可以分为局域网（LAN）、城域网（MAN）、广域网（WAN）和个域网（PAN）。依据<strong>信息类型</strong>可以分为数据网络、电话网络。依据<strong>应用类型</strong>可以分为专用网络、通用网络。依据<strong>使用权</strong>可以分为私有网络、公用网络。同时，网络也可以按照使用的协议进行分类，如 IP 协议等。</p></li>
</ul>
<h2 id="背诵-2-计算机网络发展历史">【背诵 2 】计算机网络发展历史</h2>
<p>计算机网络的历史可以大致描述为：</p>
<ul>
<li>1940 年代，第一个计算机 ENIAC 诞生</li>
<li>1950 年代，大型机和多终端系统诞生</li>
<li>1960 - 1964 年，分组交换网络诞生（Paul Baran）</li>
<li>1960 年代，计算机网络研究开始</li>
<li>* 1969 年，ARPANET 研究启动</li>
<li>1970 年代，计算机网络发展
<ul>
<li>各国电信部门建设运行 X.25 分组交换网</li>
<li>SNA 以及 DNA 等专用网络体系结构出现</li>
<li>Internet 的前身 ARPANET 进行实验运行，带宽小且仅有不到 100 台计算机接入</li>
<li>* 以太网和 Telnet 出现</li>
<li>* 1979 年，TCP/IP 协议成熟</li>
</ul></li>
<li>1980 年代，计算机网络逐步成型
<ul>
<li>标准化的计算机网络体系结构 ISO/OSI 出现</li>
<li>局域网 LAN 技术发展</li>
<li>FTP、NFS、E-mail、USENET 等技术出现</li>
<li>1980 - 1983 年，ARPANET 和 MILNET 分离，前者采用 TCP/IP 协议</li>
<li>1983 年，BSD UNIX 内置 TCP/IP 协议</li>
<li>1985 - 1986 年，NSFNET 建成，用于连接 6 个超级计算中心</li>
<li>1987 - 1990 年，NSFNET 开始连接地区网络</li>
<li>Internet 初具规模，1987 年，中国第一个电子邮件发送到 Internet</li>
<li>中国开始依赖电话线建立低速广域网</li>
</ul></li>
<li>1990 年代，计算机网络进一步发展
<ul>
<li>Internet 商业化，在中国也得到了广泛应用</li>
<li>Web 技术在 Internet 上得到广泛应用</li>
<li>中国出现局域网，如 Novell 等</li>
<li>1990 - 1992 年，NSFNET 带宽提高，连接了 16 个地区网络</li>
<li>1994 年，NSFNET 骨干网解体，出现了若干其他的商用骨干网</li>
<li>1995 年，中国教育和科研网 CERNET 出现</li>
</ul></li>
<li>2000 年代，计算机网络广泛应用
<ul>
<li>网络应用发展迅速，搜索引擎和社交网络出现</li>
<li>移动互联网产业快速发展</li>
<li>2006 年，与 IPv6 相关的 CNGI-CERNET2 出现</li>
</ul></li>
<li>最近，数据中心网络、天地一体化网络、 IPv6 技术等快速发展
<ul>
<li>2011 年开始设立 World IPv6 Day</li>
<li>2011 年 2 月 3 日，全球互联网名称与数字地址分配机构 ICANN 宣布 IPv4 地址耗尽</li>
</ul></li>
</ul>
<h2 id="背诵-3-internet-技术">【背诵 3 】 Internet 技术</h2>
<ul>
<li>Internet 是全球范围的、通用的、异构的公用计算机网络</li>
<li>Internet 是其他类型的计算机网络技术的基础，如企业内部网（Intranet）</li>
<li>Internet 开放的标准由 IETF 负责制定、维护和协调。其他类似 IRTF、IAB、IESG 等机构也参与了标准的维护
<ul>
<li>IETF 全称 Internet Engineering Task Force，其分为若干个工作组（WG），其提交的 Internet 标准被称为 RFC，即 Request For Comments</li>
<li>IRTF 全称 Internet Researching Task Force，由各类专注某一个领域的研究小组组成</li>
<li>IAB 全称 Internet Architecture Board，负责定义 Internet 的大体框架，为 IETF 提供方向上的指导</li>
<li>IESG 全称 Internet Engineering Steering Group，负责在技术方面上管理 IETF 的活动</li>
</ul></li>
<li>Internet 是历史上发展最快的一种技术，其发展速度甚至超越摩尔定律</li>
</ul>
<h2 id="背诵-4-网络时代三大定律">【背诵 4 】网络时代三大定律</h2>
<ul>
<li>【摩尔定律】 CPU 性能每 18 个月会翻番，每 10 年翻 100 倍</li>
<li>【光纤定律】也称超摩尔定律，骨干网带宽每 9 个月会翻番。每 10 年翻 10000 倍</li>
<li>【麦特卡菲定律】也称联网定律，网络价值和用户数量的平方成正比</li>
</ul>
<h2 id="理解-1-分组交换技术">【理解 1 】分组交换技术</h2>
<p>Paul Baran 在设计能承受核攻击的通信系统的时候，确立了三个设计准则。</p>
<ul>
<li>自适应系统的<strong>热土豆路由策略</strong>（能够学习并适应各种新的环境）
<ul>
<li>如果不知道正确的路由，就将分组转发给所有邻居</li>
<li>通过观察路过的分组来更新路由表，旧的路由表项会被删除</li>
<li>尽可能快地转发分组，分组途径的路径并不一定是最短路径</li>
</ul></li>
<li>分组发送策略（端节点能够容忍错误并恢复）
<ul>
<li>每个节点根据自我的路由表决定如何转发分组</li>
<li>每个分组的转发完全独立于其他的分组</li>
<li>交换节点不保存端节点信息，这一点让网络的可拓展性大大增强</li>
</ul></li>
<li>分布式策略
<ul>
<li>所有交换节点平等，避免单一节点失效问题</li>
<li>通过物理硬件冗余和自适应路由实现系统稳健性</li>
</ul></li>
</ul>
<p>而 Internet 就是这一类网络。Internet 连接了各种异构的子网，提供两个最基本的功能，即全球唯一地址和分组通过动态路由传输。</p>
<p>分组交换技术具有相当多的优点，包括：</p>
<ul>
<li>简单性
<ul>
<li>每个分组自身携带信息</li>
<li>一个路由表可以为所有的流量服务</li>
<li>可以适应快速增长的网络规模</li>
</ul></li>
<li>灵活性
<ul>
<li>可以在各种物理底层上运行</li>
<li>可以支持各种网络应用</li>
</ul></li>
<li>可扩展性
<ul>
<li>可以应对端系统的增加</li>
<li>可以应对流量的增加</li>
<li>可以应对网络规模增大带来的路由表增大和路由频繁变化</li>
</ul></li>
<li>健壮性
<ul>
<li>默认了网络结构变化是正常现象</li>
<li>牺牲一定的效率换取网络的稳定</li>
</ul></li>
</ul>
<h2 id="背诵-5-今日互联网">【背诵 5 】今日互联网</h2>
<ul>
<li>今日的互联网具有更大的规模和更多的用户，而且支持更多的功能，具有更高的价值，但是其健壮性、适应性和互联程度都下降了</li>
<li>当今互联网面临的一个问题就是 IPv4 地址耗尽，而目前缓解这个问题地方案是<strong>网络地址转换协议（Network Address Translation / NAT）</strong>
<ul>
<li>NAT 缓解了地址耗尽的问题，增强了安全性和控制性</li>
<li>但是另外一方面却打破了 Internet 中地址唯一的假设</li>
<li>端到端的分组传输路径变成多个 NAT 域的级联，相当于虚电路</li>
<li>为了恢复 Internet 的原有结构，目前正在推进 IPv6 技术</li>
</ul></li>
</ul>
<h2 id="杂项-1-未分类知识点">【杂项 1 】未分类知识点</h2>
<ul>
<li>二十世纪后期人类两项最伟大的战略工程为<strong>星球大战计划</strong>和<strong>互联网计划</strong>。目前互联网已经发展为继海、陆、空、天之后的<strong>第五空间</strong>。</li>
</ul>
<h1 id="计算机网络体系结构">计算机网络体系结构</h1>
<h2 id="背诵-6-计算机网络的定义和组成">【背诵 6 】计算机网络的定义和组成</h2>
<ul>
<li>计算机网络定义为若干独立自治的计算机系统的互联集合体
<ul>
<li>计算机网络和分布式系统不同，分布式系统虽然也是由若干个计算机系统组成，但其具有<strong>内聚性</strong>和<strong>透明性</strong>，故分布式系统呈现给用户的更像是一台计算机。计算机网络则明显分立，在用户的视角依然是若干不同的计算机</li>
<li>目前分布式系统和计算机网络有合流的趋势，两者正在走向统一</li>
</ul></li>
<li>计算机网络有两级组成，即<strong>资源子网</strong>和<strong>通信子网</strong>。资源子网常常是服务器或者用户计算机，而通信子网常常是通信线路等信道和路由器、交换机等网络互联设备</li>
<li>计算机网络之中的通信通常有两种，即<strong>交换式通信</strong>和<strong>广播式通信</strong>
<ul>
<li>交换式通信又称<strong>点对点通信</strong>
<ul>
<li>需要经过交换设备，将消息转发给一个或一组结点</li>
<li>交换设备根据需要选择输出</li>
<li>网络典型的拓扑结构包括 star / ring(loop) / tree / complete / intersecting rings / irregular</li>
<li>关键技术是<strong>路由选择</strong></li>
</ul></li>
<li>广播式通信
<ul>
<li>多台计算机共享通信线路</li>
<li>任一台计算机发出的信息可以直接被其它计算机接收</li>
<li>网络典型的拓扑结构包括 bus / ring(loop)</li>
<li>关键技术是<strong>通道分配</strong>
<ul>
<li>静态分配，即分时间片。特点是控制简单，但通道利用率低</li>
<li>动态分配，即各站点动态使用通道。特点是控制复杂，但通道利用率高。通道分配方法有两种。集中式指的是只有一个仲裁机构，分布式指的是各站点均有仲裁机构</li>
</ul></li>
</ul></li>
<li>传统的 LAN 一般使用广播式通信，而 MAN 和 WAN 一般使用交换式通信。现代的 LAN 中交换式通信的应用正在增多</li>
</ul></li>
</ul>
<h2 id="理解-2-计算机网络体系结构">【理解 2 】计算机网络体系结构</h2>
<ul>
<li>计算机网络体系结构指的是对计算机网络及其部件所完成功能的比较精确的定义，即从功能的角度描述计算机网络的结构，是<strong>层次和层间关系</strong>的集合。但体系结构只会从功能上定义网络，并不会定义协议的细节和接口关系
<ul>
<li>现代计算机网络体系架构指出，计算机网络的基本功能是为地理位置不同的计算机用户之间提供访问通路，并且应当提供若干功能（具体功能列表见 PPT），这些功能中最重要的是<strong>通信功能</strong></li>
<li>这些功能的特征是<strong>分层</strong>，也就是说计算机网络中提供的功能是分成层次的</li>
<li>位于不同计算机上进行对话的同一层通信各方可分别看成是一种进程，称为<strong>对等（同等）进程</strong></li>
</ul></li>
<li>计算机网络分层的体系结构有三个重要的概念，即协议、服务和接口
<ul>
<li>计算机网络体系结构定义了计算机网络的功能是分层次的，而协议（Protocol）就是计算机网络同等层次中，通信双方进行信息交换时必须遵守的规则
<ul>
<li>协议由三部分组成
<ul>
<li>语法（Syntax）部分。即以二进制形式表示的命令和相应的结构</li>
<li>语义（Semantics）部分。即发出的命令请求，完成的动作和回送的响应组成的集合</li>
<li>定时关系（Timing）部分。即有关事件顺序的说明</li>
</ul></li>
<li>网络体系结构的分层决定了协议的分层，协议的分层构成了<strong>洋葱结构</strong>
<ul>
<li>目的主机某一层收到的报文与源主机同一层发出的报文相同</li>
<li>协议分层要保证整个通信系统功能完备高效</li>
</ul></li>
</ul></li>
<li>协议定义了不同计算机同层次之间的关系，而服务（Service）定义同一个计算机的上下层之间的交换信息时必须遵守的规则
<ul>
<li>服务有两种，即面向连接的服务和无连接服务。
<ul>
<li>在使用面向连接的服务进行传输的时候，首先需要建立连接，然后使用这个连接传递数据，使用完毕需要关闭连接。这类服务的顺序性较好</li>
<li>在使用无连接服务的时候，不建立连接，直接通过服务发送数据每个包都需要独立确定路由。这类服务的顺序性较差</li>
<li>需要注意，连接并不意味着可靠，可靠性依然需要通过确认、重传等机制进行保证</li>
</ul></li>
<li>服务在形式上需要通过一组服务原语（Primitive）规定。原语可以分为四类，即请求、指示、响应、确认</li>
</ul></li>
<li>在同一个计算机之中相邻层之间都有一个接口（Interface），它定义了下层向上层提供的原语操作和服务</li>
</ul></li>
<li>基于三大基本概念，计算机网络体系结构的具体实现大致为
<ul>
<li>服务访问点（Service Access Point / SAP）
<ul>
<li>任何的层间服务都是在接口的 SAP 上完成的</li>
<li>每一个 SAP 都有唯一的识别地址</li>
<li>每一个层间接口可以具有多个 SAP</li>
</ul></li>
<li>接口数据单元（Interface Data Unit / IDU）
<ul>
<li>IDU 是通过 SAP 传递的层间信息单元（上下传输）</li>
<li>IDU 的构成是上一层的服务数据单元（Service Data Unit / SDU）和接口控制信息（Interface Control Information / ICI）的拼接</li>
</ul></li>
<li>协议数据单元（Protocol Data Unit / PDU）
<ul>
<li>PDU 是在同层实体之间通过网络传输的信息单元（水平传输）</li>
<li>PDU 的构成是上一层的 SDU 或其分段和协议控制信息（Protocol Control Information / PCI）的拼接</li>
</ul></li>
<li>基于上述定义，计算机网络的工作类似于下述
<ul>
<li>当本层需要水平传输的时候，首先获得上层通过 SAP 传递的，由 SDU 和 ICI 拼接得到的 IDU。然后本层删除 ICI，将剩余的 SDU 拼接上 PCI 获得 PDU 并通过本层网络协议传输</li>
<li>当本层需要继续向下层传输的时候，首先获得上层的 IDU，这个从上层获得到本层的 IDU 在下层看来就是一个新的 SDU。本层随后直接拼接上新的 ICI 获得新的 IDU 向下传输。所以说，最上层产生的数据包向下传播的时候，会逐层添加各层控制信息。而底层接收的数据包向上传播的时候，会逐层把这些控制信息删去，获取最后的数据</li>
</ul></li>
</ul></li>
<li>分层的优点包括模块化、功能抽象、可复用。缺点是数据隐藏会导致可能的低效</li>
<li>计算机网络体系结构的设计中还有两个原则，分别称为<strong>端到端原则</strong>和 <strong>Rule of thumb</strong>
<ul>
<li>端到端原则的思想是底层需要尽可能简单，但是上层应用可以较为复杂（完成验证、纠错等工作），只有当这样的功能明显能提升功能的时候才会放在底层</li>
<li>Rule of thumb 的思想是，底层的新功能不能影响其他不使用这个新功能的部分</li>
</ul></li>
</ul>
<h2 id="理解-3-osi-和-tcpip-模型及其他网络模型">【理解 3 】 OSI 和 TCP/IP 模型及其他网络模型</h2>
<ul>
<li>模型建立的历史事件见 PPT</li>
<li>OSI 模型在 1983 年提出，模型分为七层，从下至上为
<ul>
<li>物理层，这一层包含基础网络硬件，在物理通信线路上传输二进制位（Bit）</li>
<li>数据链路层，这一层目标是在有差错的物理线路上传输无差错的数据帧（Frame）</li>
<li>网络层，这一层控制通信子网提供数据包（Packet）传输功能</li>
<li>传输层，这一层为用户提供端到端的数据传输功能</li>
<li>会话层，这一层为用户提供类似安全认证等会话控制服务</li>
<li>表示层，这一层为用户提供数据表示和数据转换功能</li>
<li>应用层</li>
</ul></li>
<li>TCP/IP 模型的提出早于 OSI 模型，且仅有四层：
<ul>
<li>Host-to-Internet 层，相当于 OSI 的物理层和数据链路层</li>
<li>Internet 层（网络层），控制通信子网提供源点到目的点的 IP 包传送，实现异构网络互联</li>
<li>传输层，提供端到端的数据传送服务，如 TCP 和 UDP</li>
<li>应用层，内部包含了 OSI 的会话层和表示层</li>
</ul></li>
<li>X.25 分组交换网在 70 年代提出，早于 OSI 模型，为公用包交换网与用户之间提供接口
<ul>
<li>该模型面向连接，支持交换虚电路和永久虚电路</li>
<li>物理层使用协议 X.21 以及 X.3 / X.28 / X.29</li>
<li>数据链路层使用协议 LAP 和 LAPB</li>
<li>网络层使用协议 PLP</li>
<li>该模型提出了以下名词 -（用户侧）数据终端设备（Digital Terminal Equipment / DTE）
<ul>
<li>数字线路设备（Digital Circuit Terminating Equipment / DCE）</li>
<li>打包解包设备（Packet Assembler and Disassembler / PAD）</li>
</ul></li>
</ul></li>
<li>Novell Netware 在 1983 年提出，在 2005 年终止开发
<ul>
<li>模型基于 client-server 结构，设计的基本思想是<strong>文件共享</strong>（同时期其它系统还基于磁盘共享，所以模型有一定先进性）</li>
<li>基于 XNS（Xeror Network System），网络层协议是不可靠无连接协议 IPX（Internet Packet Exchange），传输层协议是面向连接的 NCP（Netware Core Protocol）和 SPX（Sequenced Package Exchange）</li>
</ul></li>
<li>B-ISDN 即宽带综合业务数字网，其技术基础为 ATM 异步传输模式（Asynchronous Transfer Mode）
<ul>
<li>ATM 也是分组交换技术
<ul>
<li>异步传输，即不具有主时钟</li>
<li>传输单元为短而定长的信元（cell）</li>
<li>采用虚电路，面向连接</li>
<li>常见速率包括 155M 和 622M</li>
</ul></li>
</ul></li>
</ul>
<h2 id="杂项-2-未分类知识点">【杂项 2 】未分类知识点</h2>
<ul>
<li>美国的标准化组织包括 ANSI 和 NIST，中国的标准化组织包括 CCSA，行业标准则是 IEEE</li>
<li>计算机网络标准化，电信标准为 ITU 而国际标准则是 ISO</li>
<li>Internet 的标准是自发的，并非政府干预，每个标准诞生前都需要提出请求意见稿，即 RFC</li>
</ul>
<h1 id="数据通信基本原理">数据通信基本原理</h1>
<h2 id="理解-4-信号的傅里叶分析">【理解 4 】信号的傅里叶分析</h2>
<ul>
<li>注意网原里傅里叶级数的定义为：</li>
</ul>
<p><span class="math display">\[
g(t) = \frac12 c + \sum_{n = 1}^{+\infty} a_n\sin(2\pi f nt) + \sum_{n = 1}^{+\infty} b_n\cos(2\pi f nt)
\]</span></p>
<p>所以：</p>
<p><span class="math display">\[
\begin{aligned}
c &amp;= \frac2T \int_0^T g(t) {\rm d}t \\
a_n &amp;= \frac2T \int_0^T g(t)\sin(2\pi f nt) {\rm d}t \\
b_n &amp;= \frac2T \int_0^T g(t)\cos(2\pi f nt) {\rm d}t \\
\end{aligned}
\]</span></p>
<ul>
<li>一个信号所包含的信号频率范围为频谱（Spectrum），其宽度称为信号的绝对带宽（Definite bandwidth）。大部分信号有无穷的绝对带宽，但是其能量可能仅集中于某一个频段，这个频带的宽度称为有效带宽（Effective bandwidth），简称带宽</li>
<li>带宽越宽，信号的信息承载能力越强</li>
<li>信号在给定截止频率 <span class="math inline">\(f_c\)</span> 的信道传输的过程中，高于截止频率的频率分量的振幅衰减明显大于低于截止频率的</li>
<li>通过信道的谐波次数越多，信号越逼真</li>
</ul>
<h2 id="计算-1-信号传输基础计算">【计算 1 】信号传输基础计算</h2>
<ul>
<li>波特率指的是信号每秒钟变化的次数，也称调制速率</li>
<li>比特率指的是信号每秒钟传输的二进制位个数</li>
<li>波特率和比特率的关系取决于信号值与比特位的关系，如果每个信号值能表示 <span class="math inline">\(N\)</span> 个二进制位，那么比特率为波特率的 <span class="math inline">\(N\)</span> 倍</li>
<li>对于比特率为 <span class="math inline">\(B({\rm bps})\)</span> 的信道，如果 <span class="math inline">\(M\)</span> 个二进制位为一个周期，则波特率为 <span class="math inline">\(B/M({\rm baud})\)</span>，一次谐波的频率为 <span class="math inline">\(f_1 = B/M({\rm Hz})\)</span>（一次谐波指的是信号傅里叶级数中周期等于原信号周期的分量），能通过信道的最高次谐波次数为 <span class="math inline">\(N = f_c / f_1\)</span>，这里 <span class="math inline">\(f_c\)</span> 为信道的截止频率</li>
<li>信道的有限带宽限制了信号的传输速率，<strong>无噪声</strong>带宽为 <span class="math inline">\(H\)</span> 的信道传输有 <span class="math inline">\(V\)</span> 种电平状态的信号时，最高传输速率为：</li>
</ul>
<p><span class="math display">\[
v = 2H\log_2 V({\rm bps})
\]</span></p>
<ul>
<li>对于<strong>有噪声</strong>信道，其噪声功率为 <span class="math inline">\(N\)</span>，信号功率为 <span class="math inline">\(S\)</span>，其<strong>信噪比</strong>为：</li>
</ul>
<p><span class="math display">\[
x = 10\log_{10}\frac{S}{N}({\rm dB})
\]</span></p>
<p>一般电话系统的典型信噪比为 <span class="math inline">\(30({\rm dB})\)</span>。</p>
<p>带宽为 <span class="math inline">\(H({\rm Hz})\)</span>，信噪比为 <span class="math inline">\(S/N\)</span> 的任何信道的最大传输速率为：</p>
<p><span class="math display">\[
v = H\log_2\left(1 + \frac{S}{N}\right)({\rm bps})
\]</span></p>
<p>该传输速率为理论上限，实际很难达到。该传输速率与电平级数和采样速度无关</p>
<h2 id="背诵-7-传输方式分类">【背诵 7 】传输方式分类</h2>
<ul>
<li>数字传输、模拟传输
<ul>
<li>数字传输的优点是成本低，对噪声不敏感，缺点是易受衰减（频率越高越严重）</li>
</ul></li>
<li>并行传输、串行传输</li>
<li>点到点传输、点到多点传输
<ul>
<li>为适应不同的需要，通信线路采用不同的连接方式</li>
</ul></li>
<li>单工、半双工和全双工传输
<ul>
<li>单工传输：信息只能单向传输，监视信号可回送</li>
<li>半双工传输：信息可以双向传输，但在某一时刻只能单向传输</li>
<li>全双工传输：信息可以同时双向传输</li>
</ul></li>
<li>同步传输、异步传输
<ul>
<li>同步传输
<ul>
<li>传输以报文为基本单位</li>
<li>传输开始的时候需要传输<strong>同步字符</strong>让双方同步</li>
<li>可以不间断传输，传输效率较高但是需要<strong>透明传输处理</strong>，即传输的信息中不存在同步字符</li>
<li>接收方必须知道每一位信号的开始及其持续时间，以便正确的采样接收</li>
<li>基于<strong>二进制位</strong>的传输一般使用同步传输，信息以<strong>二进制位流</strong>为单位传送，传输过程中以<strong>位</strong>为单位同步，传输的开始和结束以特定的<strong>八位二进制位</strong>同步</li>
</ul></li>
<li>异步传输
<ul>
<li>需要辅助位，如起始位、奇偶校验位、终止位</li>
<li>传输效率低，主要用于字符终端与计算机之间的通信</li>
<li>传输字符时，信息传送以字符为单位</li>
</ul></li>
</ul></li>
</ul>
<h2 id="背诵-8-信号发送方式">【背诵 8 】信号发送方式</h2>
<ul>
<li>数据表示分为两种，即模拟数据和数字数据</li>
<li>数据传输方式中以信号为载体，分为模拟信号（模拟信道）和数字信号（数字信道）两种（见【背诵 7 】）</li>
<li>两种数据表示和两种数据传输方式对应形成四种信号发送方式：</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">模拟数据</th>
<th style="text-align: center;">数字数据</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">模拟信道</td>
<td style="text-align: center;">电话系统</td>
<td style="text-align: center;">频带传输、调制解调器（Modem）</td>
</tr>
<tr class="even">
<td style="text-align: center;">数字信道</td>
<td style="text-align: center;">编码解码器（Codec）</td>
<td style="text-align: center;">基带传输、数字编码解码器</td>
</tr>
</tbody>
</table>
<ul>
<li>数字数据的数字传输
<ul>
<li>基带传输
<ul>
<li>基带指的是传输变换前所占用的频带，是原始信号所固有的频带</li>
<li>基带传输指的是在传输时直接使用基带信号，是一种基本的传输方式，适用于高速低速各种情况</li>
<li>其限制为因基带信号所带的频率成分很宽，所以对传输线有一定的要求</li>
</ul></li>
<li>编码方式
<ul>
<li>不归零制码（NRZ）
<ul>
<li>用高电平表示 1，用低电平表示 0</li>
<li>难以分辨某一位的开始或结束，所以发送和接受方都需要时钟同步</li>
<li>如果信号中 0 或者 1 连续出现，直流电平会叠加</li>
<li>容易产生传播错误</li>
</ul></li>
<li>曼彻斯特码（相位编码）
<ul>
<li>每个周期中间有一个跳变，由低到高为 0，由高到低为 1</li>
<li>克服了 NRZ 的不足，并且每个周期中间的跳变既是信息又是时钟，可以自同步</li>
</ul></li>
<li>差分曼彻斯特码
<ul>
<li>每个周期中间有一个跳变作为时钟</li>
<li>每个周期开始有跳变表示 0，没有跳变表示 1</li>
<li>时钟、数据相分离，便于提取</li>
<li>差分曼彻斯特注意分类讨论初始时是高电平还是低电平</li>
</ul></li>
<li>逢 0 变化 NRZ
<ul>
<li>每个周期开始有跳变表示 0，没有跳变表示 1</li>
<li>每个周期中间没有跳变</li>
<li>注意讨论初始时的电平</li>
</ul></li>
<li>逢 1 变化 NRZ
<ul>
<li>每个周期开始有跳变表示 1，没有跳变表示 0</li>
<li>每个周期中间没有跳变</li>
<li>注意讨论初始时的电平</li>
</ul></li>
</ul></li>
</ul></li>
<li>数字数据的模拟传输
<ul>
<li>频带传输
<ul>
<li>在一定频率范围内的线路上，进行载波传输</li>
<li>用基带信号对载波进行调制，使其变为适合于线路传送的信号</li>
<li>调制指的是用基带脉冲控制载波参数，使得这些参数反应基带脉冲信息</li>
<li>使用调制解调器</li>
</ul></li>
<li>调制技术
<ul>
<li>幅移键控法（调幅 / ASK），即根据基带脉冲调整载波振幅</li>
<li>频移键控法（调频 / FSK），即根据基带脉冲调整载波频率</li>
<li>相移键控法（调相 / PSK），即根据基带脉冲调整载波相位</li>
</ul></li>
</ul></li>
<li>模拟数据的数字传输
<ul>
<li>脉冲代码调制 PCM 技术
<ul>
<li>根据 Nyquist 原理进行采样</li>
<li>将模拟信号的振幅分为 <span class="math inline">\(2^n\)</span> 级，每一个采样点用 <span class="math inline">\(n\)</span> 位二进制位表示</li>
<li>贝尔系统的 T1 载波每个采样点用 7 位二进制表示</li>
</ul></li>
<li>差分脉冲代码调制
<ul>
<li>与 PCM 数字化振幅不同，差分脉冲代码调制数字化的是相邻采样点的振幅差值</li>
<li>可以使用较少的二进制位表示</li>
</ul></li>
<li><span class="math inline">\(\delta\)</span> 调制
<ul>
<li>根据每个采样值与前一个值之间的差来决定输出 1 还是 0</li>
<li>编码速度可能无法跟上变化较快的模拟信号</li>
</ul></li>
</ul></li>
</ul>
<h2 id="背诵-9-多路复用技术">【背诵 9 】多路复用技术</h2>
<ul>
<li>使得多路信号同时使用一条物理线路的技术,允许用户使用一个共享信道进行通信，避免相互干扰，降低成本，提高利用率</li>
<li>多路复用技术分类
<ul>
<li>时分复用（TDM）
<ul>
<li>T1 载波电话系统分为 24 个信道，每个 <span class="math inline">\(64({\rm Kbps})\)</span>，一共 <span class="math inline">\(1.544({\rm Mbps})\)</span>，控制信息带内传输</li>
</ul></li>
<li>频分复用（FDM）
<ul>
<li>频率分割为频段，多用于手机通信</li>
</ul></li>
<li>波分复用（WDM）
<ul>
<li>光传输使用，对波长分段，是特殊的频分复用</li>
</ul></li>
</ul></li>
</ul>
<h2 id="背诵-10-交换技术">【背诵 10 】交换技术</h2>
<ul>
<li>计算机网络通信分为交换式和广播式</li>
<li>交换是在多结点通信网络中，为有效利用通信设备和线路，动态接通、断开、切换通信线路</li>
<li>交换技术分类
<ul>
<li>电路交换
<ul>
<li>直接利用可以切换的物理电路动态调整通信线路</li>
<li>分为建立电路、传输数据、拆除电路三个阶段</li>
<li>在发送数据前，必须建立起点到点的物理通路。建立物理通路时间较长，数据传送延迟较短</li>
<li>电话网和 ISDN 采用电路交换</li>
<li>电路交换一般采用时分复用
<ul>
<li>时间被分为帧（Frame），帧被分为时槽（Slot）</li>
<li>时槽在帧内的相对位置决定这个槽所传输数据所属的会话</li>
<li>发送方和接收方间需要同步</li>
<li>非永久会话需要动态绑定时槽到一个会话</li>
</ul></li>
</ul></li>
<li>报文交换（存储转发方式）
<ul>
<li>信息以报文（逻辑上完整的信息段）为单位进行存储转发</li>
<li>线路利用率高、要求中间结点（网络通信设备）缓冲大、延迟时间长</li>
</ul></li>
<li>分组交换（包交换）
<ul>
<li>分组是一种报文还小的信息段，可定长也可变长。分组交换中信息以分组为单位进行存储转发。源结点把报文分为分组，在中间结点存储转发，目的结点把分组合成报文。用附加的分组头来区分数据</li>
<li>特点
<ul>
<li>每个分组头包括源地址和目的地址，独立进行路由选择
<ul>
<li>所以不保证到达顺序</li>
</ul></li>
<li>网络结点设备中不预先分配资源，使用统计复用，线路利用率高
<ul>
<li>相比于电路交换最明显的优势</li>
</ul></li>
<li>易于重传，可靠性高</li>
<li>易于开始新的传输，让紧急信息优先通过</li>
<li>开销增加</li>
<li>需要处理拥塞问题
<ul>
<li>需要复杂的路由器，难以保证端到端的服务质量</li>
</ul></li>
</ul></li>
<li>分组交换分为虚电路分组交换和数据报分组交换
<ul>
<li>数据报分组交换（如 IP Networks）
<ul>
<li>每个分组均带有网络地址（源、目的），可走不同的路径</li>
</ul></li>
<li>虚电路分组交换（如 ATM Networks）
<ul>
<li>其是电路交换和分组交换的结合
<ul>
<li>数据以分组形式传输，来自同一流的分组通过一个预先建立的路径（虚电路）传输</li>
<li>确保分组的顺序，但是来自不同虚电路的分组可能会交错在一起</li>
</ul></li>
<li>分三个阶段
<ul>
<li>建立：发带有全称网络地址的呼叫分组，建立虚电路</li>
<li>传输：沿建立好的虚电路传输数据</li>
<li>拆除：拆除虚电路</li>
</ul></li>
<li>分组头不需要包含完整的地址信息，路由器需要维护虚电路的状态信息</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li>电路交换、报文交换、分组交换的时序图如下。其中电路交换要逐层申请预留占用资源，这段申请时间用于<strong>寻找出境中继线</strong>，申请完毕后节点会占用这段传输线</li>
</ul>
<p><img src="/uploads/note-of-net/1.png" /></p>
<ul>
<li>三类交换技术的特点
<ul>
<li>电路交换适用于实时信息和模拟信号传送，在线路带宽比较低的情况下使用比较经济</li>
<li>报文交换适用于线路带宽比较高的情况，可靠灵活，但延迟大</li>
<li>分组交换缩短了延迟，也能满足一般的实时信息传送。在高带宽的通信中更为经济、合理、可靠。是目前公认较好的一种交换技术</li>
<li>电路交换和分组交换可以结合，如 IP over SONET 以及 IP over Frame Relay</li>
</ul></li>
</ul>
<h2 id="背诵-11-交换结构">【背诵 11 】交换结构</h2>
<ul>
<li>Crossbar 交换结构：无阻塞内部交换</li>
<li>空分交换：多个 Crossbar 互联，有无阻塞均可</li>
<li>时分交换：高效处理</li>
</ul>
<h2 id="杂项-3-未分类知识点">【杂项 3 】未分类知识点</h2>
<ul>
<li>数据通信技术由编码技术、多路复用和交换技术构成</li>
</ul>
<h1 id="物理层接口及其协议">物理层接口及其协议</h1>
<h2 id="背诵-12-物理层的定义与功能">【背诵 12 】物理层的定义与功能</h2>
<ul>
<li>物理层提供机械的、电气的、功能的和规程的特性，目的是启动、维护和关闭<strong>数据链路实体</strong>之间进行<strong>比特传输</strong>的<strong>物理连接</strong>。这种连接可能通过中继系统，在中继系统内的传输也是在物理层</li>
<li>物理层的功能是在两个网络设备之间提供透明的比特流传输</li>
<li>物理层的传输方式
<ul>
<li>连接方式（点到点，点到多点）</li>
<li>通信方式（单工，半双工，全双工）</li>
<li>位传输方式（串行，并行）</li>
</ul></li>
<li>物理层的重要特性
<ul>
<li>机械特性（Mechanical characteristics）
<ul>
<li>定义物理连接的边界点，即接插装置</li>
<li>规定物理连接时所采用的规格、引脚的数量和排列情况</li>
</ul></li>
<li>电气特性（Electrical characteristics）
<ul>
<li>规定传输二进制位时，线路上信号的电压高低、阻抗匹配、传输速率和距离限制</li>
</ul></li>
<li>功能特性（Functional characteristics）
<ul>
<li>主要定义各条物理线路的功能，比如数据、控制、定时、地线</li>
</ul></li>
<li>规程特性（Procedural characteristics）
<ul>
<li>主要定义各条物理线路的工作规程和时序关系</li>
</ul></li>
</ul></li>
</ul>
<h2 id="背诵-13-物理层传输介质">【背诵 13 】物理层传输介质</h2>
<ul>
<li>双绞线。既可以用于模拟传输，也可以用于数字传输，带宽依赖于线的类型和传输距离</li>
<li>同轴电缆
<ul>
<li>基带同轴电缆，用于数字传输（数字数据数字传输用基带传输）</li>
<li>宽带同轴电缆，用于模拟传输（模拟数据数字传输用频带传输）</li>
</ul></li>
<li>光纤
<ul>
<li>分为单模光纤和多模光纤，两者都支持波分复用，使用的波长越长衰减越小，但成本也越高
<ul>
<li>单模光纤只有一个入射角度，半径小，适合<strong>长距离传输</strong></li>
<li>多模光纤有多个入射角度，半径大，适合短距离传输</li>
</ul></li>
<li>光纤组网
<ul>
<li>点到点，使用四根线，两根用于保护倒换</li>
<li>环，使用两根线，一根用于保护倒换</li>
</ul></li>
<li>光纤中继器。分为光电光式和全光式
<ul>
<li>全光网具有光因特网论坛 OIF</li>
</ul></li>
</ul></li>
</ul>
<h2 id="背诵-14-sonet-sdh-网络传输技术">【背诵 14 】 SONET / SDH 网络传输技术</h2>
<ul>
<li>80 年代提出，应用<strong>时分复用</strong>技术，同步传输，有主时钟控制</li>
<li>SONET 路径为：路径（Path）、线路（Line）、段（Section）</li>
<li>基于<strong>字节</strong>的复用。但是 OC-3c 中的 c 表示<strong>级联</strong>而非复用</li>
</ul>
<h2 id="背诵-15-移动电话网络传输技术">【背诵 15 】移动电话网络传输技术</h2>
<ul>
<li>单方向的寻呼系统
<ul>
<li>寻呼过程
<ul>
<li>打电话给寻呼公司，输入寻呼机号码</li>
<li>寻呼公司的计算机收到请求，通过线路传到高处的天线</li>
<li>天线直接广播信号（本地寻呼），或传递给卫星（异地寻呼），卫星再广播</li>
</ul></li>
<li>单向系统</li>
<li>需要很小的带宽</li>
</ul></li>
<li>蜂窝电话
<ul>
<li>1G：模拟蜂窝电话，只能传送话音</li>
<li>2G：数字蜂窝电话，主要传送话音，相关概念有 GSM 和 CDMA</li>
<li>3G / 4G：可以传送话音和数据</li>
</ul></li>
<li>模拟蜂窝电话
<ul>
<li>Push-to-talk system。早期用于军事通信，单信道，半双工系统</li>
<li>IMTS。双频，全双工系统</li>
<li>AMPS。使用小蜂窝，蜂窝中心有基站，不相邻且相近的蜂窝中<strong>重用频率</strong></li>
</ul></li>
</ul>
<div class="note warning"><p>网原实在是看不会了，这个笔记也就到此为止吧。</p>
</div>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统课程大实验摸索实录</title>
    <url>/2022/02/28/os-exp/</url>
    <content><![CDATA[<p>本来就是为了躲避考试来做的大实验，感觉也会是挺有意思的一段经历，不妨记录一下。</p>
<span id="more"></span>
<h1 id="配置-rcore-环境2022.02.28">配置 rCore 环境【2022.02.28】</h1>
<p>在做大实验之前，需要先把五次小实验做完，那么第一件事就是去配置 rCore 环境。Rust 之前就配置好了，所以主要是配置 qemu。按照正常的流程，就是下载打包的 5.0.0 版本的 qemu 源码，并编译，但是很快就炸了个错：</p>
<figure class="highlight bash"><figcaption><span>Bash</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># ashitemaru @ LAPTOP-VQNVF4EV in ~/qemu-5.0.0 [17:38:32]</span></span><br><span class="line">$ make -j$(nproc)</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/home/ashitemaru/qemu-5.0.0/slirp&#x27;</span></span><br><span class="line">make[1]: Nothing to be <span class="keyword">done</span> <span class="keyword">for</span> <span class="string">&#x27;all&#x27;</span>.</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/ashitemaru/qemu-5.0.0/slirp&#x27;</span></span><br><span class="line">        CHK version_gen.h</span><br><span class="line">  LINK    riscv32-softmmu/qemu-system-riscv32</span><br><span class="line">  LINK    riscv64-softmmu/qemu-system-riscv64</span><br><span class="line">/usr/bin/ld: /home/ashitemaru/qemu-5.0.0/slirp/libslirp.a(misc.o): <span class="keyword">in</span> <span class="keyword">function</span> `g_spawn_async_with_fds_slirp<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">/home/ashitemaru/qemu-5.0.0/slirp/src/misc.c:173: undefined reference to `g_spawn_async_with_fds&#x27;</span></span><br><span class="line">/usr/bin/ld: /home/ashitemaru/qemu-5.0.0/slirp/libslirp.a(misc.o): <span class="keyword">in</span> <span class="keyword">function</span> `g_spawn_async_with_fds_slirp<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">/home/ashitemaru/qemu-5.0.0/slirp/src/misc.c:173: undefined reference to `g_spawn_async_with_fds&#x27;</span></span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br><span class="line">make[1]: *** [Makefile:208: qemu-system-riscv64] Error 1</span><br><span class="line">make[1]: *** [Makefile:208: qemu-system-riscv32] Error 1</span><br><span class="line">make: *** [Makefile:527: riscv32-softmmu/all] Error 2</span><br><span class="line">make: *** Waiting <span class="keyword">for</span> unfinished <span class="built_in">jobs</span>....</span><br><span class="line">make: *** [Makefile:527: riscv64-softmmu/all] Error 2</span><br></pre></td></tr></table></figure>
<p>链接器找不到一个函数符号，找了一下各路文档，这个函数是 GNU libc 导出的一个符号。遇到这种 undefined 的问题，第一反应就是去重装一遍这个动态库，于是就去了 GNU libc 的官网，clone 了一份源码，并且开始编译。</p>
<p>但是这里构建的时候又炸了一个错，是找不到 <code>libiconv</code> 符号。</p>
<p>这里就开始感到不对了，因为他不是报找不到动态库，而是找不到符号。而且我当时还特意去 <code>/usr/local/lib</code> 底下用下述命令确认了这个符号确实导出了：</p>
<figure class="highlight bash"><figcaption><span>Bash</span></figcaption><table><tr><td class="code"><pre><span class="line">nm -C libiconv-2.0.so | grep libiconv</span><br></pre></td></tr></table></figure>
<p>这个时候我想起来之前做计组的时候实际上是在 WSL 里装过一个低版本的 qemu 的，当时安装的时候报错找不到 libiconv 的库（不是找不到符号，而是找不到动态库），于是我自己 clone 了一份源码，在 <code>/usr/local/lib</code> 底下装了一份 libiconv。</p>
<p>这个时候我已经差不多反应过来了，因为 libiconv 应该是系统自己有的一个动态库，如果我再装一份的话，很有可能因为冲突出现问题。</p>
<p>随后就去翻 GNU libc 的构建 config 文件，发现其找寻 libiconv 是先搜寻系统自带的动态库目录，随后去 <code>/usr/local/lib</code> 下找。那这样的话，其很有可能是定位到了系统自带的 libiconv 库。然而计组的 qemu 似乎是先寻找他自带的一个动态库目录和 <code>/usr/local/lib</code>，并且不去寻找系统自带的动态库目录。然而这也是合理的，因为当时计组推荐的就是无论在什么系统上，只要下载他的一个压缩包，一切东西都不要配。但是可能是打包失误之类，libiconv 意外没有打包进来。</p>
<p>那这样这个问题就已经差不多明白了，就是系统的 libiconv 出现了问题（我猜测是 C 和 C++ 函数签名的问题，C++ 编译出来的函数签名会有前缀）。而计组当时没有出问题的原因是他在构建的时候就没有去找系统自带的动态库目录，所以缺失了库文件。但是 OS 装 qemu 的时候找到了系统的 libiconv，但是这是有问题的一个动态库，用不了，连带着 GNU libc 没法用，所以最后就炸了。</p>
<p>解决方式，就是重装 WSL。系统出问题还不重装系统？</p>
<p>结果从重装，配置 C 环境，配置 Python 环境，配置终端美化插件，配置 Vim 到最后装完 qemu 跑起来 rCore，一共没有用到两小时。</p>
<h1 id="分时多任务2022.03.07">分时多任务【2022.03.07】</h1>
<p>第一个小作业，目标是实现基于 stride 算法的进程调度。不过在具体工作之前，我们还是需要弄明白框架里一部分功能是如何实现的。</p>
<h2 id="特权级切换">特权级切换</h2>
<p>目前我们只考虑在 U 态下出发 Trap 到 S 态，那么在处理这个 Trap 的时候，硬件需要分别完成：</p>
<ul>
<li>修改相应的 CSR 寄存器相关字段
<ul>
<li><code>sstatus</code> 的 <code>SPP</code> 字段置为 CPU 当前特权级</li>
<li><code>sepc</code> 置为处理完 Trap 后接着要处理的指令位置</li>
<li><code>scause</code> 和 <code>stval</code> 存储 Trap 的原因和相关信息</li>
</ul></li>
<li>CPU 跳转到 <code>stvec</code> 指定的 Trap 处理程序入口地址并切换特权级</li>
<li>切换到内核栈，在此处保存原先上下文
<ul>
<li>上下文一般包括此处所有的通用寄存器以及 <code>sstatus</code> 和 <code>sepc</code> 寄存器</li>
</ul></li>
<li>处理 Trap</li>
<li>恢复上下文，释放分配的内核栈空间并切换到用户栈</li>
<li>执行 <code>sret</code> 命令回到原先环境
<ul>
<li>根据 <code>sstatus</code> 的 <code>SPP</code> 字段重置特权级</li>
<li>跳转到 <code>sepc</code> 指向的地址继续执行</li>
</ul></li>
</ul>
<p>这个实验之中为了简化，<code>stvec</code> 寄存器处于 Direct 模式，该模式下 Trap 处理程序入口地址计算较为简单。</p>
<p>基于这样的处理流程，我们需要在 OS 启动初始化的时候就将标记 Trap 处理程序起始地址的符号 <code>__alltraps</code> 事先引入到 <code>stvec</code> 寄存器中：</p>
<figure class="highlight rust"><figcaption><span>Rust</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// ch2 /trap/mod.rs</span></span><br><span class="line">core::arch::global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;trap.S&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">__alltraps</span></span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        stvec::write(__alltraps <span class="keyword">as</span> <span class="built_in">usize</span>, TrapMode::Direct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__alltrap</code> 使用汇编代码实现，其负责了保存上下文并切换到 Trap 处理程序的任务。这段汇编代码中唯一要注意的是 <code>sscratch</code> 寄存器的含义，该寄存器在 U 态下保存的是内核栈栈顶位置，我们可以利用该寄存器实现换栈。</p>
<hr />
<p><code>__alltrap</code> 的最后会 <code>call trap_handler</code> 触发 Rust 编写的 Trap 处理程序。</p>
<p>Trap 处理程序会分情况处理：</p>
<ul>
<li>如果仅仅是触发了系统调用，那么 Trap 处理程序申请系统调用后返回到 <code>__alltrap</code> 下面一行，即 <code>__restore</code> 对应的代码段</li>
<li>如果是当前用户应用有不可恢复的错误，则打印提示信息，调用 <code>run_next_app</code> 切换到下一个用户应用</li>
<li>如果是未知错误，OS 立刻停止</li>
</ul>
<p>这里 <code>__restore</code> 负责的任务则是恢复上下文，换回用户栈并在最后调用 <code>sret</code> 回到 U 态。</p>
<p>在第一种情况下，Trap 处理程序会直接调用 <code>__restore</code>。第二种情况下，其会调用 <code>run_next_app</code>，该函数会间接调用 <code>__restore</code>：</p>
<figure class="highlight rust"><figcaption><span>Rust</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// ch2 /batch.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">run_next_app</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> app_manager = APP_MANAGER.exclusive_access();</span><br><span class="line">    <span class="keyword">let</span> current_app = app_manager.get_current_app();</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        app_manager.load_app(current_app);</span><br><span class="line">    &#125;</span><br><span class="line">    app_manager.move_to_next_app();</span><br><span class="line">    <span class="built_in">drop</span>(app_manager);</span><br><span class="line">    <span class="comment">// before this we have to drop local variables related to resources manually</span></span><br><span class="line">    <span class="comment">// and release the resources</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">__restore</span></span>(cx_addr: <span class="built_in">usize</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        __restore(KERNEL_STACK.push_context(TrapContext::app_init_context(</span><br><span class="line">            APP_BASE_ADDRESS,</span><br><span class="line">            USER_STACK.get_sp(),</span><br><span class="line">        )) <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="built_in">usize</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Unreachable in batch::run_current_app!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面一段就是加载下一个用户应用的代码，最主要关注其如何调用 <code>__restore</code>。显然其在内核栈中压入了新的 Trap 上下文，并且将压入后的内核栈顶地址交给了 <code>__restore</code>（使用 <code>a0</code> 寄存器传递）。那这样就需要关注 <code>app_init_context</code> 的实现：</p>
<figure class="highlight rust"><figcaption><span>Rust</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// ch2 /trap/context.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">app_init_context</span></span>(entry: <span class="built_in">usize</span>, sp: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> sstatus = sstatus::read();</span><br><span class="line">    sstatus.set_spp(SPP::User);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> cx = <span class="keyword">Self</span> &#123;</span><br><span class="line">        x: [<span class="number">0</span>; <span class="number">32</span>],</span><br><span class="line">        sstatus,</span><br><span class="line">        sepc: entry,</span><br><span class="line">    &#125;;</span><br><span class="line">    cx.set_sp(sp);</span><br><span class="line">    cx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数接受程序入口地址和栈顶指针作为参数，构造了一个用于初始化用户程序运行的 Trap 上下文。</p>
<p>将这个上下文压入内核栈并调用 <code>__restore</code>，就可以完成用户程序的初始化。尽管异常处理后的恢复和用户程序初始化并不是同一种需求，但是其处理逻辑类似，所以完全可以复用同一份代码。</p>
<h2 id="任务间切换">任务间切换</h2>
<p>现在我们需要实现多个用户程序之间的切换。虽然 Trap 处理也会涉及到用户程序间切换，但是一般的任务间切换不涉及到特权级切换，这是与 Trap 处理不同的。</p>
<p>这里使用汇编编写了任务切换需要的代码，入口符号为 <code>__switch</code>。处理逻辑为：</p>
<ul>
<li>保存其实环境运行上下文，不过这里只需要保存 12 个调用者保存寄存器和 <code>ra</code> 及 <code>sp</code> 寄存器即可</li>
<li>恢复目标环境运行上下文，并且调用 <code>ret</code> 以返回到指定的地址运行目标环境</li>
</ul>
<p>这里就可以注意到保存 <code>ra</code> 寄存器的必要性了，其作用就是让 <code>__switch</code> 返回的时候能正确跳转到目标环境的地址。</p>
<h2 id="多任务管理">多任务管理</h2>
<p>我们时常会遇到需要等待外设才能继续执行的任务，这种时候如果保持等待则可能导致资源浪费，因为我们完全可以在等待的时候将 CPU 资源交给其他任务。为了实现灵活的多任务切换，我们需要了解两个系统调用。</p>
<p>在 U 态下触发 <code>sys_yield</code> 系统调用就会将 CPU 运行权限交出，由 OS 授予另外一个应用占用 CPU。而如果触发 <code>sys_exit</code> 系统调用也会交出 CPU 运行权限，但是 <code>sys_yield</code> 表示该任务暂未结束，只不过为了避免浪费暂且停止，<code>sys_exit</code> 则表明任务结束，将来也不会取回运行权限。</p>
<p>同样，OS 有权限将 CPU 运行权限交予一个暂停的任务。</p>
<p>每一个任务都有未初始化、准备运行、运行中和终结四种状态。在上述的管理原则下，这些状态的转移图为：</p>
<p><img src="/uploads/os-exp/1.png" /></p>
<h2 id="初始化运行环境">初始化运行环境</h2>
<p>初始化流程中最重要的就是任务管理器 <code>TASK_MANAGER</code> 的初始化：</p>
<figure class="highlight rust"><figcaption><span>Rust</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// ch3 /task/mod.rs</span></span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> TASK_MANAGER: TaskManager = &#123;</span><br><span class="line">        <span class="keyword">let</span> num_app = get_num_app();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> tasks = [TaskControlBlock &#123;</span><br><span class="line">            task_cx: TaskContext::zero_init(),</span><br><span class="line">            task_status: TaskStatus::UnInit,</span><br><span class="line">        &#125;; MAX_APP_NUM];</span><br><span class="line">        <span class="keyword">for</span> (i, t) <span class="keyword">in</span> tasks.iter_mut().enumerate().take(num_app) &#123;</span><br><span class="line">            t.task_cx = TaskContext::goto_restore(init_app_cx(i));</span><br><span class="line">            t.task_status = TaskStatus::Ready;</span><br><span class="line">        &#125;</span><br><span class="line">        TaskManager &#123;</span><br><span class="line">            num_app,</span><br><span class="line">            inner: <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                UPSafeCell::new(TaskManagerInner &#123;</span><br><span class="line">                    tasks,</span><br><span class="line">                    current_task: <span class="number">0</span>,</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要注意各个 <code>TaskControlBlock</code> 的 <code>task_cx</code> 属性是如何初始化的。首先调用 <code>init_app_cx</code> 来创建用户程序上下文，其作用是在对应用户程序的内核栈内压入一个初始化的 Trap 上下文并返回此时的内核栈栈顶。</p>
<p>之后 <code>goto_restore</code> 构建 Task 上下文，该上下文中 12 个通用寄存器暂时置零，<code>ra</code> 置 <code>__restore</code> 的地址，<code>sp</code> 置刚刚得到的内核栈栈顶地址。</p>
<hr />
<p>这样完成所有的初始化后，OS 通过 <code>run_first_task</code> 开始运行用户程序。其最主要的代码是这样的一段：</p>
<figure class="highlight rust"><figcaption><span>Rust</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// ch3 /task/mod.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> _unused = TaskContext::zero_init();</span><br><span class="line"><span class="comment">// before this, we should drop local variables that must be dropped manually</span></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    __switch(&amp;<span class="keyword">mut</span> _unused <span class="keyword">as</span> *<span class="keyword">mut</span> TaskContext, next_task_cx_ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">panic!</span>(<span class="string">&quot;unreachable in run_first_task!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到我们这里手动调用了 <code>__switch</code>，并且将第一个任务的 Task 上下文作为目标地址传入。由于目前所有任务的 Task 上下文中保存的 <code>ra</code> 均为 <code>__restore</code> 的地址，这样就保证了最后 <code>__switch</code> 返回到 <code>__restore</code> 处，完成任务的初始化后通过 <code>sret</code> 跳转到用户代码处开始执行任务。</p>
<h2 id="时钟中断">时钟中断</h2>
<p>现代的 OS 在面对很少主动触发 <code>sys_yield</code> 的用户程序的时候，往往是强制收回 CPU 使用权以保证硬件利用率。这意味着，在这样的条件下，所有应用随时都有可能被强制停止，这样的调度方式就是<strong>抢占式调度</strong>。</p>
<p>实现 OS 强制收回使用权的方式就是，设置一个计时器，每间隔一个固定的时间（比如 10 毫秒）就强制暂停当前任务并开启下一个任务。</p>
<p>我们可以通过 <code>time::read()</code> 方法来获取 <code>mtime</code> 寄存器的值，该寄存器保存了 OS 从上电到现在一共经过了多少个 <strong>OS 时钟周期</strong>（和 CPU 主频时钟不同）。当其大于 <code>mtimecmp</code> 寄存器的时候触发时钟中断，重置 <code>mtimecmp</code> 开始下一轮计时。</p>
<h2 id="rust-的静态变量">Rust 的静态变量</h2>
<p>大概是在摸索 rCore 里面用户栈实现的时候，将其中一部分代码写了一个简化版，结果无意中触发了段错误。后面大致摸索明白了原因，这里也就写一个简单的记录，见 <a href="/2022/03/09/static-var-in-rust">这篇博客</a>。</p>
]]></content>
      <categories>
        <category>开发杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>《Soft Rasterizer - A Differentiable Renderer for Image-based 3D Reasoning》论文笔记</title>
    <url>/2022/01/18/paper-1/</url>
    <content><![CDATA[<p>进可微渲染项目之后要求阅读的第一篇论文，就当作一种入门论文吧。</p>
<span id="more"></span>
<h2 id="工作概述">工作概述</h2>
<p>主要思想还是想把逆向渲染管线（通过二维图像推理三维模型的参数）和神经网络结合，但是最大的问题是管线中的光栅化是离散化操作，可能导致不可微。一些其他的工作在尝试<strong>近似估算</strong>梯度，但是这个工作提出了一种真正可微的框架，能做到：</p>
<ul>
<li>直接用可微函数渲染染色的网格</li>
<li>能从轮廓、阴影等各种二维图像信息有效反向传递为网格顶点参数</li>
</ul>
<p>这个工作的重点是把渲染过程的部分看作<strong>聚合函数（Aggregation function）</strong>，该函数联系了三维模型的网格三角形的概率分布以及其渲染出来的像素。</p>
<div class="note info no-icon"><p>看起来标题中的 Soft 的含义就是使用概率分布的方式来把离散的光栅化变成可微的，最初始的光栅化一般会涉及到离散采样（即确定每一个离散的像素是否要显示网格上的某一个三角形），这也是不可微性的来源。</p>
</div>
<p>本论文主要讲述了如何通过 Soft rasterization 框架实现可微的光栅化以保证渲染管线的可微性，基于此，该渲染框架即可方便地接入神经网络以将二维图像信息反向传播到三维模型。同时，本论文也会指出近期的近似估算梯度的方式（使用 hand-crafted 的函数近似表示梯度）并不具有泛用性，且可能会降低三维模型信息更新的效率。</p>
<h3 id="softras-与传统光栅化">SoftRas 与传统光栅化</h3>
<p>SoftRas 在将模型投影到平面上的时候，会将模型转换为投影平面上的概率分布。而传统光栅化则是转化为具体某个像素是否染色。</p>
<p>另外，似乎 SoftRas 对遮挡的处理也和传统渲染管线的 z-buffer 不一样。传统光栅化会使用 onehot 的方式处理遮挡（应该指的是处理为完全遮挡），而 SoftRas 也会基于概率分布做出不同处理。</p>
<h2 id="相关工作">相关工作</h2>
<h3 id="可微渲染">可微渲染</h3>
<p>主要关注如何描述二维图像变化和三维模型操作的关系，主要解决如何从二维图像重建三维场景。考虑给定的二维图片 <span class="math inline">\(A\)</span>，首先粗略初始化一个三维场景 <span class="math inline">\(B&#39;\)</span>，然后通过渲染管线渲染得到二维图片 <span class="math inline">\(B\)</span>。计算 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 的 loss，将其梯度反向传播给三维场景 <span class="math inline">\(B&#39;\)</span> 的参数，更新之。这里反向传播就是可微渲染最重要的步骤，即如何计算梯度，因为三维场景参数更新量取决于 loss 对参数的偏导数。</p>
<p>先前提到，这里获取梯度有困难。有些工作使用估计梯度的方式进行，有些工作可以精确计算梯度但是不具有泛用性。</p>
<h3 id="基于图像的三维推理">基于图像的三维推理</h3>
<p>依然考虑从二维图像重建三维场景。传统方法往往要求获得从多个角度观察得到的二维图像，而由于数据集的扩大，基于学习的重建方法可以使用一张或少量二维图像来重建场景。部分工作会将重建三维场景拆分为首先重建 2.5 维的表示（深度表等）。</p>
<p>另外，姿态估计也是三位推理的一个重要的子任务。通过深度学习的方法，预测刚体姿态是较为简单的，而预测人体这类非刚体的姿态则较为困难。</p>
<h2 id="softras-基本原理">SoftRas 基本原理</h2>
<p>大约是这样的一个流程：</p>
<p><img src="/uploads/paper-1/1.png" /></p>
<p>这里外部因素包含相机参数 <span class="math inline">\(\boldsymbol{P}\)</span> 和环境光照 <span class="math inline">\(\boldsymbol{L}\)</span>，内部因素包括网格信息 <span class="math inline">\(\boldsymbol{M}\)</span> 以及各个顶点的信息（如颜色、材质）<span class="math inline">\(\boldsymbol{A}\)</span>。</p>
<p>这里第一步要做的是获取三个中间信息，即网格法向量 <span class="math inline">\(\boldsymbol{N}\)</span>、视图空间（投影后的空间）各点坐标 <span class="math inline">\(\boldsymbol{U}\)</span> 以及 View dependent depths <span class="math inline">\(\boldsymbol{Z}\)</span>。这三个量只需要使用相机参数和网格信息即可得到。</p>
<p>之后可以使用例如 Phong 模型等着色模型计算出颜色 <span class="math inline">\(\boldsymbol{C}\)</span>。</p>
<p>进行到这一步，上述这些操作都是可微的。但是如果按照传统的渲染管线，下一步应该分别确定每一个网格三角形与每一个像素的对应（即光栅化），之后还要用 z-buffer 处理遮挡，这两步都因为离散采样从而是不可微的。</p>
<p>SoftRas 软化光栅化和 z-buffer 的方式是引入 probability maps <span class="math inline">\(\{\mathcal{D}_j\}\)</span> 和聚合函数 <span class="math inline">\(\mathcal{A}(\cdot)\)</span> 分别代替光栅化和 z-buffer。这里 <span class="math inline">\(\mathcal{D}_j\)</span> 表示的是每一个像素在网格三角形 <span class="math inline">\(f_j\)</span> 内部的概率在平面上的分布。而聚合函数 <span class="math inline">\(\mathcal{A}(\cdot)\)</span> 联系起了 probability maps 以及深度信息，作为整个后续渲染流程的代表。</p>
<h3 id="probability-maps-计算">probability maps 计算</h3>
<p>考虑网格三角形在屏幕上的投影 <span class="math inline">\(f_j\)</span> 和屏幕上的像素 <span class="math inline">\(p_i\)</span>，记在屏幕上 <span class="math inline">\(p_i\)</span> 到 <span class="math inline">\(f_j\)</span> 的边最近距离为 <span class="math inline">\(d(i, j)\)</span>。显然，这个距离越小的像素点，出现在内部的概率越大。由于其可以反映三角形对屏幕的影响，并且其可微，所以可以用此作为 probability maps 的代表。随后通过添加控制常数、符号标记并归一化到 <span class="math inline">\((0, 1)\)</span> 内之后，我们得到了 probability maps 的公式：</p>
<p><span class="math display">\[
\mathcal{D}_{i, j} = \mathrm{sigmoid}\left(\delta_{i, j}\cdot\frac{d^2(i, j)}{\sigma}\right)
\]</span></p>
<p>这里 <span class="math inline">\(\sigma\)</span> 是一个正常数，一般默认为 <span class="math inline">\(1\times 10^{-4}\)</span>。而 <span class="math inline">\(\delta_{i, j}\)</span> 标记了 <span class="math inline">\(p_i\)</span> 是否在 <span class="math inline">\(f_j\)</span> 之中。若在，则 <span class="math inline">\(\delta_{i, j} = 1\)</span>，否则 <span class="math inline">\(\delta_{i, j} = -1\)</span>。</p>
<p>下图展示了 <span class="math inline">\(d(i, j)\)</span> 的定义以及 <span class="math inline">\(\sigma\)</span> 常数对概率分布的影响：</p>
<p><img src="/uploads/paper-1/2.png" /></p>
<p>显然看出 <span class="math inline">\(\sigma\)</span> 越大，概率分布就越模糊。</p>
<p>另外一个显然的点是 <span class="math inline">\(\sigma \to 0\)</span> 的时候概率分布中三角形外的点概率密度为 <span class="math inline">\(0\)</span>，而三角形内的点为 <span class="math inline">\(1\)</span>。此时 SoftRas 退化为一般的光栅化。</p>
<h3 id="聚合函数">聚合函数</h3>
<p>我们考虑最后一个阶段，这里我们需要根据深度信息、 probability maps 以及颜色信息计算出最后的渲染结果。</p>
<p>最后渲染结果中，像素 <span class="math inline">\(p_i\)</span> 的渲染结果用聚合函数表示，定义为：</p>
<p><span class="math display">\[
I_i = \mathcal{A}_S(\{C_j\}) := \sum_j w_{i, j}C_{i, j} + w_{i, b}C_b
\]</span></p>
<p>这里渲染结果定义为一系列颜色信息的加权求和，颜色构成的集合为 <span class="math inline">\(\{C_j\}\)</span>，符号 <span class="math inline">\(C_{i, j}\)</span> 表示三角形 <span class="math inline">\(f_j\)</span> 在像素 <span class="math inline">\(p_i\)</span> 处的颜色。而 <span class="math inline">\(C_b\)</span> 表示背景颜色。</p>
<p>权重 <span class="math inline">\(w_{i, j}\)</span> 至少满足归一化条件：</p>
<p><span class="math display">\[
w_{i, b} + \sum_j w_{i, j} = 1
\]</span></p>
<p>而权重的具体值取决于先前得到的 probability maps 以及深度信息。我们将三角形 <span class="math inline">\(f_j\)</span> 中投影到 <span class="math inline">\(p_i\)</span> 像素的点的逆深度记为 <span class="math inline">\(z_{i, j}\)</span>。概率分布沿用先前的符号。定义：</p>
<p><span class="math display">\[
w_{i, j} := \frac{\mathcal{D}_{i, j}\exp(z_{i, j} / \gamma)}{\sum_k \mathcal{D}_{i, k}\exp(z_{i, k} / \gamma) + \exp(\varepsilon / \gamma)}
\]</span></p>
<p>依据归一化条件就有：</p>
<p><span class="math display">\[
w_{i, b} := \frac{\exp(\varepsilon / \gamma)}{\sum_k \mathcal{D}_{i, k}\exp(z_{i, k} / \gamma) + \exp(\varepsilon / \gamma)}
\]</span></p>
<div class="note info no-icon"><p>可以看出权重的计算公式其实是类似 Softmax 函数：</p>
<p><span class="math display">\[
{\rm softmax}(z_1, z_2, \cdots, z_n)_j = \frac{e^{z_j}}{\sum_i e^{z_i}}
\]</span></p>
</div>
<p>这里可以看出 <span class="math inline">\(\varepsilon\)</span> 是一个小正常数，其作用是将背景颜色纳入计算。<span class="math inline">\(\gamma\)</span> 是一个调节清晰度的正常数，与计算 probability maps 的 <span class="math inline">\(\sigma\)</span> 类似，默认值一般是 <span class="math inline">\(1 \times 10^{-4}\)</span>。</p>
<p>可以看出，具有更大概率密度的，且离投影平面更近的（即具有更大逆深度的）三角形会获得更大的权重，这符合直觉。</p>
<hr />
<p>现在考虑退化。针对像素 <span class="math inline">\(p_i\)</span>，假设 <span class="math inline">\(z_{i, 1} &lt; z_{i, 2} &lt; \cdots &lt; z_{i, N}\)</span>，考虑 <span class="math inline">\(\gamma\to 0\)</span>。首先考察 <span class="math inline">\(j = N\)</span>：</p>
<p><span class="math display">\[
\begin{aligned}
w_{i, N} &amp;= \lim_{\gamma\to 0}\frac{\mathcal{D}_{i, N}\exp(z_{i, N} / \gamma)}{\sum_k \mathcal{D}_{i, k}\exp(z_{i, k} / \gamma) + \exp(\varepsilon / \gamma)} \\
&amp;= \lim_{\gamma\to 0}\frac{\mathcal{D}_{i, N}}{\sum_k \mathcal{D}_{i, k}\exp((z_{i, k} - z_{i, N}) / \gamma) + \exp((\varepsilon - z_{i, N}) / \gamma)} \\
&amp;= \lim_{\gamma\to 0}\frac{\mathcal{D}_{i, N}}{\sum_{k = 1}^{N - 1} \mathcal{D}_{i, k}\exp((z_{i, k} - z_{i, N}) / \gamma) + \mathcal{D}_{i, N} + \exp((\varepsilon - z_{i, N}) / \gamma)} \\
&amp;= 1
\end{aligned}
\]</span></p>
<p>最后一步注意到 <span class="math inline">\(z_{i, N}\)</span> 大于任何 <span class="math inline">\(z_{i, k}(k &lt; N)\)</span>，故有这样的结果。而对于 <span class="math inline">\(j &lt; N\)</span>：</p>
<p><span class="math display">\[
\begin{aligned}
w_{i, j} &amp;= \lim_{\gamma\to 0}\frac{\mathcal{D}_{i, j}\exp(z_{i, j} / \gamma)}{\sum_k \mathcal{D}_{i, k}\exp(z_{i, k} / \gamma) + \exp(\varepsilon / \gamma)} \\
&amp;= \lim_{\gamma\to 0}\frac{\mathcal{D}_{i, N}}{\sum_k \mathcal{D}_{i, k}\exp((z_{i, k} - z_{i, j}) / \gamma) + \exp((\varepsilon - z_{i, j}) / \gamma)} \\
&amp;= \lim_{\gamma\to 0}\frac{\mathcal{D}_{i, N}}{\left(\sum_{k = 1}^{j - 1} + \sum_{k = j + 1}^{N}\right) \mathcal{D}_{i, k}\exp((z_{i, k} - z_{i, N}) / \gamma) + \mathcal{D}_{i, N} + \exp((\varepsilon - z_{i, N}) / \gamma)} \\
&amp;= 0
\end{aligned}
\]</span></p>
<p>这里要注意到分母上 <span class="math inline">\(\sum_{k = j + 1}^{N}\)</span> 的部分最终会趋向于正无穷，整体极限为 <span class="math inline">\(0\)</span>。最后根据归一化条件也有 <span class="math inline">\(w_{i, b} = 0\)</span>。</p>
<p>结合这样的推理，可以看出：</p>
<p><span class="math display">\[
I_i = \mathcal{A}_S(\{C_j\}) = C_{i, N}
\]</span></p>
<p>也就是说最后渲染的结果只考虑了最近的网格三角形，这也就是 z-buffer 方法。</p>
<hr />
<p>似乎还有一个和轮廓相关的聚合函数：</p>
<p><span class="math display">\[
I_{i, S} = \mathcal{A}_O(\{\mathcal{D}_j\}) := 1 - \prod_j (1 - \mathcal{D}_{i, j})
\]</span></p>
<p>这里没有出现颜色项，这是因为轮廓的颜色一般设定为常数。这里聚合函数形式上实际上就是计算出了像素 <span class="math inline">\(p_i\)</span> 被至少一个三角形覆盖的概率。</p>
<h2 id="实验内容">实验内容</h2>
<h3 id="single-view-mesh-reconstruction">Single-View Mesh Reconstruction</h3>
<p>使用这样的结构：</p>
<p><img src="/uploads/paper-1/3.png" /></p>
<p>这里固定了渲染管线中的外部变量，即固定了相机位置和环境光照。每一个输入图片都会进入 color generator 和 shape generator 生成三维模型参数 <span class="math inline">\(\boldsymbol{C}\)</span> 和 <span class="math inline">\(\boldsymbol{M}\)</span>。随后后续接入 SoftRas，渲染得到带颜色的图像 <span class="math inline">\(I_C\)</span> 和轮廓 <span class="math inline">\(I_S\)</span>，最后和原先图像比较计算 loss。</p>
<p>最后定义的 loss 分为三部分。在叙述定义之前，我们将原始图像的颜色和轮廓定义为 <span class="math inline">\(\hat I_C\)</span> 以及 <span class="math inline">\(\hat I_S\)</span>：</p>
<ul>
<li>color loss。定义为颜色之差的 1- 范数：</li>
</ul>
<p><span class="math display">\[
\mathcal{L}_C := \|I_C - \hat I_C\|_1
\]</span></p>
<ul>
<li>silhouette loss。定义为，这里使用 <span class="math inline">\(\otimes\)</span> 表示逐元素求积，<span class="math inline">\(\oplus\)</span> 表示逐元素求和：</li>
</ul>
<p><span class="math display">\[
\mathcal{L}_S := 1 - \frac{\|I_S \otimes \hat I_S\|_1}{\|I_S \oplus \hat I_S - I_S \otimes \hat I_S\|_1}
\]</span></p>
<ul>
<li>geometry loss。作用是对 loss 进行 L1 正则化。</li>
</ul>
<p>最后定义的 loss 是这三部分的加权求和：</p>
<p><span class="math display">\[
\mathcal{L} := \mathcal{L}_S + \lambda\mathcal{L}_C + \mu\mathcal{L}_G
\]</span></p>
<p>这里论文主要提了一下 color generator 的结构：</p>
<p><img src="/uploads/paper-1/4.png" /></p>
<p>似乎是提出了一种新结构，让颜色重建变为一个多分类问题，进而降低了时间复杂度。但是论文的描述中有若干的暂且不太清楚的名词，暂且把原文贴在这里以后再来看：</p>
<div class="note info no-icon"><p>Instead of directly regressing the color value, our color generator formulates color reconstruction as a classification problem that learns to reuse the pixel colors in the input image for each sampling point. Let <span class="math inline">\(N_c\)</span> denote the number of sampling points on <span class="math inline">\(\boldsymbol{M}\)</span> and <span class="math inline">\(H, W\)</span> be the height and width of the input image respectively. However, the computational cost of a naive color selection approach is prohibitive, i.e. <span class="math inline">\(O(HWN_c)\)</span>. To address this challenge, we propose a novel approach to colorize mesh using a color palette, as shown in Figure 7. Specifically, after passing input image to a neural network, the extracted features are fed into (1) a sampling network that samples the representative colors for building the palette; and (2) a selection network that combines colors from the palette for texturing the sampling points. The color prediction is obtained by multiplying the color selections with the learned color palette. Our approach reduces the computation complexity to <span class="math inline">\(O(N_d(HW + N_c))\)</span>, where <span class="math inline">\(N_p\)</span> is the size of color palette. With a proper setting of <span class="math inline">\(N_p\)</span>, one can significantly reduce the computational cost while achieving sharp and accurate color recovery.</p>
</div>
<h3 id="image-based-shape-fitting">Image-based Shape Fitting</h3>
<p>似乎依然是从图像重建模型，但是这个重建任务似乎和姿态预测有较为紧密的联系。</p>
<p>传统方法面临的问题依然是梯度不精确的问题，这样就导致反向传播较为困难。另外，传统方法也面临这样的问题：</p>
<ul>
<li><p>遮挡问题。传统方法中，被遮挡的三角形无法调整参数，而 SoftRas 允许被遮挡的三角形参与到运算中，所以这个问题可以解决。</p></li>
<li><p>局部最小值问题。我们希望误差反向传播可以传播到较大范围，即希望一次三维模型参数调整不局限于较小的局部，否则可能会导致模型收敛到局部最小值而非更优的结果。而 SoftRas 使用的概率分布算法允许全局的像素参与到运算中，所以理论上误差可以传播到较大范围，这个问题可以解决。</p></li>
</ul>
<p>所以最后就直接使用这样的方式训练就行了：</p>
<p><span class="math display">\[
\{\rho, \theta, t\} = \mathop{\mathrm{argmin}}_{\rho, \theta, t}\|R(M(\rho, \theta, t)) - I_t\|_2
\]</span></p>
<p>这里 <span class="math inline">\(\rho, \theta, t\)</span> 是三维模型的参数，分别是非刚体形变参数、姿态角度、转换参数（或许就是视图转换的参数），<span class="math inline">\(M(\cdot)\)</span> 将这些参数转换为网格，<span class="math inline">\(R(\cdot)\)</span> 是渲染函数，<span class="math inline">\(I_t\)</span> 则是目标图像。这个训练方式也就是机器学习的通式。</p>
<h2 id="实验结果">实验结果</h2>
<h3 id="single-view-mesh-reconstruction-1">Single-View Mesh Reconstruction</h3>
<p>实验结果看确实挺好的，下面展示的是不带颜色的网格重建：</p>
<p><img src="/uploads/paper-1/5.png" /></p>
<p>颜色似乎也重建得挺好：</p>
<p><img src="/uploads/paper-1/6.png" height="50%" width="50%" /></p>
<p>使用的评价方法是 3D IoU，即 3D Intersection over Union。这是一种物体检测领域的评价函数。二维情况下的 IoU 定义如下图所示。这里的矩形均指代物体的包围盒，分别为实际的包围盒和模型预测的包围盒：</p>
<p><img src="/uploads/paper-1/7.png" height="50%" width="50%" /></p>
<p>SoftRas 的平均 3D IoU 超出了 state-of-art 的 NMR 的 3D IoU 约 4.5 点，从而说明在网格重建任务上 SoftRas 的表现超出了传统方法。</p>
<p>另外似乎还有一项称为 Ablation Study 的后续实验，这里省略。</p>
<h3 id="image-based-shape-fitting-1">Image-based Shape Fitting</h3>
<p>首先实验刚体结构预测，这里采用六面着不同色的正方体。给定渲染后图像，要求给出正方体应当旋转的角度。SoftRas 和 NMR 的实验结果如下：</p>
<p><img src="/uploads/paper-1/8.png" /></p>
<p>可以发现 SoftRas 成功获得了最后的结果，而 NMR 则收敛到了一个局部最小值无法得到正确结果。</p>
<p>论文认为 NMR 失败的原因正是因为六个面的相互遮挡，这导致了 NMR 无法越过局部最小值。</p>
<p>另外其也做了大量实验，表明 SoftRas 预测的旋转角度误差严格优于 NMR，在不优化的情况下，SoftRas 的角度误差平均比 NMR 低 <span class="math inline">\(10.60^\circ\)</span>。</p>
<p>这里似乎涉及到 <span class="math inline">\({\rm SO}(3)\)</span> 旋转群的一些东西，后面再来研究吧。</p>
<hr />
<p>非刚体结构预测则选用了人体结构预测，这里初始化时人的右手位于背后，而目标图像中右手已经移动到前面，实验目标是将手移出来。显然 NMR 依然因为无法处理遮挡，最后没有能够完成任务。而 SoftRas 完成了：</p>
<p><img src="/uploads/paper-1/9.png" /></p>
<h2 id="附录梯度计算">附录：梯度计算</h2>
<p>我们现在研究一下 SoftRas 渲染出来的图像 <span class="math inline">\(\boldsymbol{I}\)</span> 对网格参数 <span class="math inline">\(\boldsymbol{M}\)</span> 的梯度，这个梯度也就是在反向传播的时候要计算的值。首先显然有：</p>
<p><span class="math display">\[
\frac{\partial\boldsymbol{I}}{\partial\boldsymbol{M}} = \frac{\partial\boldsymbol{I}}{\partial\boldsymbol{U}}\frac{\partial\boldsymbol{U}}{\partial\boldsymbol{M}} + \frac{\partial\boldsymbol{I}}{\partial\boldsymbol{Z}}\frac{\partial\boldsymbol{Z}}{\partial\boldsymbol{M}} + \frac{\partial\boldsymbol{I}}{\partial\boldsymbol{N}}\frac{\partial\boldsymbol{N}}{\partial\boldsymbol{M}}
\]</span></p>
<p>这里显然可以看出 <span class="math inline">\(\dfrac{\partial\boldsymbol{U}}{\partial\boldsymbol{M}}, \dfrac{\partial\boldsymbol{Z}}{\partial\boldsymbol{M}}, \dfrac{\partial\boldsymbol{N}}{\partial\boldsymbol{M}}\)</span> 是可以简单计算的，因为 <span class="math inline">\(\boldsymbol{U}, \boldsymbol{Z}, \boldsymbol{N}\)</span> 都可以由 <span class="math inline">\(\boldsymbol{M}\)</span> 通过简单的视图变换得到，由变换矩阵即可推算偏导数。</p>
<p>而根据着色模型，<span class="math inline">\(\dfrac{\partial\boldsymbol{I}}{\partial\boldsymbol{N}}\)</span> 也是可以计算的。</p>
<p>剩余的两个梯度中，<span class="math inline">\(\dfrac{\partial\boldsymbol{I}}{\partial\boldsymbol{Z}}\)</span> 直接和聚合函数相关，而 <span class="math inline">\(\dfrac{\partial\boldsymbol{I}}{\partial\boldsymbol{U}}\)</span> 经过了两层，分别是概率分布计算和聚合函数，所以我们需要拆解：</p>
<p><span class="math display">\[
\dfrac{\partial\boldsymbol{I}}{\partial\boldsymbol{U}} = \dfrac{\partial\boldsymbol{I}}{\partial\mathcal{D}}\dfrac{\partial\mathcal{D}}{\partial\boldsymbol{U}}
\]</span></p>
<h3 id="概率分布对视图空间坐标的梯度">概率分布对视图空间坐标的梯度</h3>
]]></content>
      <categories>
        <category>科研杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>《SMPL - A Skinned Multi-Person Linear Model》论文笔记</title>
    <url>/2022/02/25/paper-2/</url>
    <content><![CDATA[<p>这个论文我打开后，第一眼就是这个非常奇妙而神奇的模型图：</p>
<p><img src="/uploads/paper-2/1.png" /></p>
<span id="more"></span>
]]></content>
      <categories>
        <category>科研杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>《美少女万华镜 5 ——理与迷宫的少女》游戏测评</title>
    <url>/2021/08/18/renge-5/</url>
    <content><![CDATA[<p>Holder 不是一个玩 GAL 的人，能想到的 GAL 除了万华镜就是柚子社这种。但是 Holder 想了想，决定把万华镜 5 这个宣称中的最终章认真通一下，也算对我几乎唯一知晓的 GAL 致以敬意。</p>
<p>离万华镜 5 发售差不多过去一年半了，各路汉化理论上应该充斥互联网，但 Holder 也只找到了生肉，于是也顺便当成了日语阅读练习。</p>
<span id="more"></span>
<h1 id="总的感想">总的感想</h1>
<p>Holder 大概花掉了靠近三十个小时打通了所有的线，由于 H 情节在一年前实际上就已经都看过一遍而且自己也有全 CG，这次的重点就是把当时看来冗杂无比的剧情认真看一下。</p>
<p>当然，一直都说万华镜系列就是单纯的拔作，剧情几乎可有可无，这句话我可以说认同一半。首先，针对万华镜 5，如果不走莲华线，而是没有压住枪走了月丘线，那确实没有任何剧情，平平淡淡地每晚在澡堂触发 H 情节就结束了。而你如果剧情看到一半没忍住走了绿毛线（绿毛名字是もよか，说实话不知道怎么找当て字，倒是“绿毛”这个代号挺深入人心的），那也是很快就 BE 了。而如果你认认真真把莲华线推完，就会发现若干的伏笔被回收，剧情似乎就有了那么一点的道理（Holder 整体上还是觉得这个剧情偏扯，但是莲华线稍微补了一点论述）。其次，万华镜整个系列，确实几乎都是没啥剧情的，除了 5。其他系列都是推一会就开始炮火连天，而 5 我是整整看剧情看了靠近两天之后才解锁了新天地（当然玩的莲华线）。</p>
<p>如果说总的感想的话，就是感觉看了一个很普通的小说。撇去还算优秀的 H 情节不谈，我在玩的时候几乎全程在看底下的文字，因为图像说实话提供不了信息。比如说“ A 把 B 扶起来”，这个动作在番或者剧里面都可以画或者演出来，但是万华镜里面也仅仅是两个人的立绘贴了一下，动作则是文字给出。所以整体我还是一直在看文字，当小说看。</p>
<p>而说它“普通”，是因为贯穿全程的就是“理”或者“命运”或者“轮回转生”，题材不是什么新颖的东西，而且能预料到莲华和男主的一些前世姻缘之类的。然后中心矛盾之一也是普通的，“我能逆天改命”和“我们只能顺应命运”的矛盾，最后认为“我能逆天改命”的人盒饭了，但却让“我们只能顺应命运”的思想少许动摇，但是为时已晚不得不继续投入到命运的轮回之中。</p>
<p>要我说的话，论剧情，万华镜 5 就是很普通的一个小说，人物关系简单，矛盾点简单。但是论 H 情节，首先我认为绿毛连动态情节都没有是很难受的（巫女后辈啊！不配画一点动态的吗！），但是莲华在二次轮回的时候 H 情节确实作画很好，动态也不错，还是稍微给点表扬。</p>
<h1 id="剧情简要分析">剧情简要分析</h1>
<h2 id="莲华-轮回线">莲华-轮回线</h2>
<p>既然核心是“理”（不得不提的就是这个“理”在游戏里面训读成ことわり，而这个读音一般写成“断り”）和“轮回转生”，那么我们应该默认天理和轮回转生的存在。</p>
<p>剧情的主干实际上就是莲华和男主深见夏彦的前世姻缘，他们可以说每一世都会相遇相爱但由于各种不可抗力无法修成正果。先是罗马时代的奴隶主和奴隶，又是中世纪的女王和下臣，之后是猎巫人和女巫。而重点是第四世，他们是古代日本的一对恋人（这时深见夏彦的名字是“彦一”，记住，要考的），而第五世就是莲华和深见夏彦。</p>
<p>说第四世重要，是因为这里狐妖介入了进来。实际上狐妖附身了第四世的莲华，或者在一定程度上，莲华在这个时候已经成为了狐妖。而当彦一（第四世的深见夏彦）死于战火的时候，狐妖则处于对人类的憎恨和爱人亡故的怨念火烧城池。人们最后将狐妖的怨念封印为“杀生石”，并在城中修建相当数量的狐狸雕像望向杀生石的方向以镇压，同时也在杀生石所在的山顶修建了一座规模宏大的神社。但是神社实际上在很多年之后的又一次战火中被烧毁，但是村民并没有重建的计划（多半是已经忘了这段历史）。而杀生石和狐狸雕像却保留了下来，成为了传说。</p>
<p>这里的杀生石、狐狸雕像、神社则是第五世（现代）剧情推进的一条线索。</p>
<p>而这个时候就必须引出绿毛了。在第五世，也就是现代，绿毛先前有一个家境优渥的家庭，但是由于他人嫉妒而故意放出的无端谣言而招致了全村人的厌恶，随后她的家人因他人纵火全部亡故，而纵火者却至今逍遥法外，绿毛也因此有了对人类的憎恨和怨念。孤身一人的她投靠了从兄弟 H（名字不想打了，但是这个人的人设和痴汉别无他样，所以就用 Hentai 的首字母代称。这里 H 是一个女子中学的音乐老师），此时绿毛沉迷于深见夏彦所在的杂志社编辑的灵异杂志，自学了很多通灵方法。最终，她独身一人走上了原来有神社和杀生石的山顶，被满是怨念的狐妖附身，开启了剧情主线。</p>
<p>绿毛有了狐妖的力量，而狐妖的一个信念就是“我是可以逆天改命的”，或者说“我不愿意服从命运的安排”。狐妖因恋人离世而对人类憎恶，绿毛因为家人离世也对人类憎恶，两个怨念叠加，绿毛开始了复仇。她的第一步就是先转学到 H 所在的女子高中并要控制全校，因为女子高中生就是当时散布绿毛家族无端谣言的主力。绿毛看中了这所高中禁止使用手机和通信软件，利用了她们相对闭锁的信息环境，开始通过狐妖的力量诱骗她们迷信自己的占卜，随后再通过狐妖的力量对她们下诅咒。诅咒的内容就是：</p>
<div class="note info no-icon"><p>山顶有神社可以实现你的愿望，但是在前往神社之前，你必须不停地画白狐氏（びゃっこ氏）以表虔诚，否则就会降下惩罚。</p>
</div>
<p>而这座神社在现实中是真的不存在的（早就烧掉了还没重建），但是狐妖的灵力可以在山顶创建一个传送门，传送到若干年前的神社，而这个神社就在狐妖（或者说绿毛）控制之下。白狐氏就是这座神社供奉的神灵（就是狐妖），而所谓的惩罚是各种莫名其妙的伤害事件（突然被钢琴盖子砸断手指，实验的时候突然自燃之类），并且惩罚的共同点就是受伤的地方毛细血管会聚集成青色的蜘蛛网的样子，而且会长一个痣。</p>
<p>这也就是最初的最初，深见夏彦所要调查的“青蜘蛛的诅咒”事件。</p>
<hr />
<p>主角团是四人组，深见夏彦，他的编辑月丘香恋，同期的只相信科学的优秀作家皇公晓，以及实体化的莲华。</p>
<p>莲华在第五世转生的时候，没有获得肉体，成为了阿紫旅馆（也就是万华镜 1-4 开头的那个旅馆，其和神社等位于同一个村子）的座敷童子。所谓座敷童子，第五世的莲华的任务就是“超度”，也就是帮助满是怨念的灵魂安宁地走向死亡，走向轮回。而完成超度的道具就是“万华镜”。</p>
<p>所以说 1-4 里面深见夏彦透过万华镜看到的，就是那些已经被超度的魂灵的生前故事，而往往这些故事都或多或少带着点怨恨（1 是人鬼情恋的越界之恨，2 是沉溺于爱而伤害恋人的愧疚之恨，3 是文明凋亡的孤独之恨，4 则是近亲的禁忌之恨）。</p>
<p>另外，作为灵力的持有者，莲华的能力就是能够读取和修改人的记忆。</p>
<p>由于没有肉体，莲华无法被感知，从而也让她一直孤独一人。但深见夏彦，作为这么多次轮回之中莲华的恋人，自然是唯一一个能感知到她存在的的人。所以深见夏彦对莲华而言，简直就是世界上唯一可以交流的人类。</p>
<p>另一方面，莲华在得知深见夏彦想要来调查“青蜘蛛的诅咒”事件，要在阿紫旅馆住上一星期左右的时候，其花费了很多的灵力为自己构筑了肉体，并且通过修改记忆让主角团和旅馆工作人员都认为莲华是真实存在的一个女高中生，这也就是实体化。这个时候的莲华就可以和正常人一样活动了。</p>
<hr />
<p>先前提到，第四世的莲华和狐妖实际上几乎是一体的，而在第四世到第五世的轮回之中，莲华被拆分成了两部分，狐妖的部分被封印而剩下的部分幻化成了现在的莲华，这莲华是通过触碰了一只小狐狸之后回想起来的。</p>
<p>在主角团调查的时候，绿毛自然早已经觉察到，深见夏彦就是自己前世恋人彦一，所以绿毛对从兄弟 H 不屑一顾而单单对深见夏彦热情，而且在深见夏彦和莲华前往深山随便走走的时候将他们拉入了神社。绿毛自然也早就明白莲华和自己理论上是一体的，所以才有绿毛的“我唯一的朋友是莲华”这一句。</p>
<p>而绿毛为了在他人面前让自己和深见夏彦亲近显得合理，她故意称其为“哥哥”（大家都知道绿毛失去家人的过往，所以因此会把她亲近深见夏彦理解为“绿毛把对哥哥的思念寄托在深见身上”）。而绿毛则不需要对莲华隐藏，所以在澡堂里直接说“深见才不是我哥哥呢”。</p>
<p>绿毛在知道深见夏彦的存在后，除去复仇的主线，自然是尝试再构姻缘。所以她引诱深见夏彦去神社，去看杀生石，去看她舞蹈，去听铜铃的声音，给他托梦，目的就是让深见夏彦回想起自己的前世。深见夏彦在经历了若干天的噩梦和梦游（梦游去神社）之后，终于在某一天晚上回想起来了自己的一切。但是深见夏彦已经沉迷莲华，依然坚称自己是深见夏彦而非彦一。</p>
<p>得知恋人心意的绿毛，自然是相当悲愤。我大费周章为你复仇，你却出轨我自己（莲华理论上和绿毛是一体的，可以理解为绿毛是邪恶的一面，莲华是善良的一面），于是托了一个巨大的噩梦给深见夏彦（就是那个，裂嘴黑眼圈的莲华 CG，这也是游戏发售前就流传出来的梗图），想让他忘记莲华。随后动用了巨大的灵力干趴了学校里所有的学生，尝试吸取她们的灵魂。</p>
<p>而随着调查的深入，莲华也了解了狐妖已经附身到绿毛身上开始复仇，而这个时候绿毛也已经因为深见夏彦的背叛而暴走了。所以为了阻止这些计划，莲华只身一人前往神社和狐妖打灵力战斗去了。</p>
<p>但是莲华毕竟力量并非很充足，最后体力渐渐不支。这个时候深见夏彦突然赶到，给莲华挡下一击。绿毛眼看自己的攻击伤到的是自己的恋人，立马停手了。随后由于巨大的自责，她没有抵挡得住莲华的最后一击而幻化为怨念，被万华镜收纳住了。</p>
<p>绿毛是解脱了，和 H 去过平凡的女高中生生活去了。学校的诅咒也解除了，大家渐渐都回到正轨了。但是深见夏彦的灵魂却因为狐妖的一击变得支离破碎，如果不修复，就等于死亡。莲华这个时候想到了解决方式，就是和深见夏彦一起回到万华镜，让深见夏彦重新回想起来所有的回忆，补全灵魂，最后用莲华的力量让死者复生。这里显然就注意到了，死者复生是违反“理”的，也就是说，莲华最终还是走上了背离天理的路。</p>
<p>莲华和深见夏彦两人在万华镜里遨游，把 1-4 的场景都走了一遍，深见夏彦也渐渐回想起了各种东西，灵魂也渐渐补全。在走完第一圈后，莲华认为已经可以送深见夏彦回去了，但是深见夏彦坚决要和莲华在一起，于是他们又走了第二圈。这之后，莲华并不再是询问语气，而是命令深见夏彦赶快回去。</p>
<p>原因很简单，莲华知道自己也是狐妖的一部分，包括自己的实体化，所动用的灵力的基础都是狐妖赖以生存的力量——人类的悲痛，莲华决定自己超度自己肮脏的灵魂。而这最后的力量就是留给将深见夏彦死者复生的，违反天理的力量。但是深见夏彦最终还是不愿回去，而这个时候他需要经受身边人的各种诘难以确认自己的心意。最后在一通告白之后，两人携手走向又一次轮回。</p>
<p>轮回到第六世的结果，就是深见夏彦成了你（这也就是游戏开头让你输入你的名字的原因），莲华成为了一个知性大姐姐和你相遇，和你相恋。两人最后渐渐回想起了前世，由于狐妖已经消逝，阻碍已经消失，所以两人修成正果，过上了炮火连天的日子。</p>
<h2 id="莲华-非轮回线">莲华-非轮回线</h2>
<p>狐妖的部分都是一致的，第一世到第五世都是一致的，一直到两人走进万华镜都和莲华-轮回线一样。</p>
<p>莲华在第一圈后会询问两次深见夏彦是否愿意回去，第二圈则会再问一次。三次都回答不想回去，才会进入轮回线，只要有一次回答了想回去，就会进入非轮回线。</p>
<p>在这里，最后深见夏彦死者复生，但是他丧失了所有和莲华有关的记忆，“青蜘蛛的诅咒”事件也被科学解释了。苏醒的深见夏彦和月丘以及皇，去和旅馆工作人员、学校老师告别后回到东京过上了平凡的生活。虽然深见夏彦时不时还是觉得自己在搜寻着什么，但是总体而言并没有想起莲华。而莲华的灵魂，也随着狐妖一起被超度，不再和深见夏彦产生任何交集。</p>
<h2 id="绿毛线">绿毛线</h2>
<p>应该说是很单纯的 BE。</p>
<p>绿毛在无数若干次引诱深见夏彦，让他回想前世之后，最终有一天直接冲进澡堂色诱深见夏彦。这个时候如果选择“放任自己”，则会开启第一段绿毛 H，否则则会以绿毛无故消失结束这一天。</p>
<p>最后某一晚，深见夏彦再一次前往神社的时候终于回想起了一切，这个时候会有选项问“你是谁”。如果先前压住了枪，这里就会有两个选项，一个是“深见夏彦”一个是“彦一”。选择深见夏彦就进入莲华线，被绿毛噩梦调戏一番后直接开始和莲华炮火连天。选择彦一则进入第二段绿毛 H。不过在一炮之后，绿毛就会以“我要将你变成我的玩物”为由杀死深见夏彦后自杀。而在现实世界中，消息就是“深见夏彦和绿毛在深山中失踪”。随后两年后，月丘香恋和皇公晓回到这个村子尝试回忆一些什么，误入了深山，看到了杀生石下两人的遗体。</p>
<p>如果先前没有压住枪，那么在问“你是谁”的时候，只有“彦一”一个选项，后面的剧情是一样的。</p>
<h2 id="月丘线">月丘线</h2>
<p>最没有意思的线。</p>
<p>月丘实际上一直喜欢着深见。在主角组前往调查之前，月丘前往深见夏彦的家交代一些工作的事情，这个时候月丘得知深见一直不会做饭，于是她决定给深见做一顿饭。在饭后，带有一点醉意的两人突然趴倒在墙角，男下女上。这个时候月丘向深见表白，会有“接受”和“拒绝”的选项。</p>
<p>拒绝的话就正常开始调查，会调查到很多东西，会有机会进绿毛线、莲华线之类。</p>
<p>接受的话直接开启 H 情节。而因此深见夏彦的心态就变成了“我要尝试融入‘大人’的世界，不能再沉迷于莲华的万华镜了”。而这种心态下，主角组调查的时候，莲华就一直处于很边缘的地位，而月丘和深见则会每晚定时开 H 情节。</p>
<p>这次调查最终无疾而终，莲华在意识到深见的心意之后也只是默默留下一句“那就结束了吧”，便再也不见。主角组回到东京之后，自然是深见和月丘的炮火连天的二人世界。</p>
<h1 id="一些其他地方的想法">一些其他地方的想法</h1>
<p>总体而言还是贯彻了万华镜系列“压住枪的都是好儿郎”的准则，越早压不住枪就只能解锁越少的剧情，然后留下越多的没有起底的伏笔。</p>
<p>虽然说万华镜没啥剧情，但是实际上总体看下来虽然平淡无奇，但还算是叙事完整，能看明白。而且有些伏笔也还算可以，比如说旅馆的“野干（やかん）”面具（“野干”在日语中是狐狸的一种代称），一方面暗示了这里和狐狸有千丝万缕的联系，而最终，绿毛跳舞给深见夏彦看的时候，戴的就是野干面具。另一方面，这个村子叫“薬缶”，和“野干”日语同音，应该是讹传出来的地名。</p>
<p>此外，一定要抨击一下文案，不是说他写的东西多差，是<strong>经常把一些已经约定俗成不写汉字的关联词、虚词写成汉字</strong>，而有的时候又会把<strong>约定俗成写成汉字的词写成假名</strong>。这让我这个现代日语没学好的人读得有那么点难受。举点例子吧：</p>
<div class="note info no-icon"><p>成程 折角 兎に角 沢山 取り敢えず 一寸 丁度 其程 是迄</p>
</div>
<p>他们实际上是：</p>
<div class="note info no-icon"><p>なるほど せっかく とにかく たくさん とりあえず ちょっと ちょうど それほど ここまで</p>
</div>
<p>这些词可以说是，不太懂日语的人只要听到读音都能回想起来点什么的词，结果硬生生给我看不懂了。</p>
<h1 id="最后的最后">最后的最后</h1>
<p>万华镜系列我认为是，中下的剧情，中上的作画，虽然不知道为何如此火，但还是有点为三十个小时感到不值。</p>
<p>但如果闲的话推推也不错，当成一个耗时间的小说吧。不过个人建议先把月丘和绿毛推了，先推莲华会很容易没有推支线的动力，因为莲华线的叙事已经很完备，其他线的逻辑就是误入歧途从而有些事情没发现最后遗憾收场。</p>
<p>知乎上看了一句总结比较好：</p>
<div class="note info no-icon"><p>你以为是你把卖片的上了，谁知道人家是命中注定给你卖片。</p>
</div>
<p>就这样吧，小学期还在等着我。</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
  </entry>
  <entry>
    <title>Rust 中的静态变量</title>
    <url>/2022/03/09/static-var-in-rust/</url>
    <content><![CDATA[<p>摸索 rCore 的用户栈实现的时候发现的一些好玩东西。</p>
<span id="more"></span>
<h1 id="会莫名段错误的内存写入">会莫名段错误的内存写入</h1>
<p>用户栈本身不难实现：</p>
<figure class="highlight rust"><figcaption><span>Rust</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> STACK_SIZE: <span class="built_in">usize</span> = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span> &#123;</span><br><span class="line">    data: [<span class="built_in">usize</span>; STACK_SIZE],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> STACK: Stack = Stack &#123;</span><br><span class="line">    data: [<span class="number">0</span>; STACK_SIZE],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Stack &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_sp</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.data.as_ptr() <span class="keyword">as</span> <span class="built_in">usize</span> + STACK_SIZE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">push_context</span></span>(&amp;<span class="keyword">self</span>, cx: <span class="built_in">usize</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cx_ptr = (<span class="keyword">self</span>.get_sp() - core::mem::size_of::&lt;<span class="built_in">usize</span>&gt;()) <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">usize</span>;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            *cx_ptr = cx;</span><br><span class="line">        &#125;</span><br><span class="line">        cx_ptr <span class="keyword">as</span> <span class="built_in">usize</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;origin sp: &#123;&#125;&quot;</span>, STACK.get_sp());</span><br><span class="line">    <span class="keyword">let</span> cx: <span class="built_in">usize</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;context: &#123;&#125;&quot;</span>, cx);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;returned sp: &#123;&#125;&quot;</span>, STACK.push_context(cx));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;processed sp: &#123;&#125;&quot;</span>, STACK.get_sp());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是会报错的，而且很容易定位到是 <code>push_context</code> 方法中 <code>unsafe</code> 块触发了段错误。</p>
<h1 id="静态变量的不可变性">静态变量的不可变性</h1>
]]></content>
      <categories>
        <category>开发杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>2021 暑假生活记录</title>
    <url>/2021/06/29/summer-record/</url>
    <content><![CDATA[<p>经过 6 月 22 日到 28 日这几天的折腾，大概和高中的老师、驾校教练等人商量了一些后续的安排。现在终于可以安定下来，准备做一些学习、开发、摸鱼的事情了。</p>
<span id="more"></span>
<p>总体而言，这个暑假想要做的事情其实还是很多的。</p>
<ul>
<li><p>学习一些新东西</p>
<ul>
<li><p>Java / Android 开发相关（或许最终的结果是随便看了看 Java 的语法，装好 IDE 就不做事了）</p></li>
<li><p>汇编语言和量子计算（这属于完全不知道干啥，写在这里是因为小学期）</p></li>
<li><p>Verilog 相关（但是这个属于想想而已，因为对这东西没有兴趣，下学期 xge 带我就好）</p></li>
<li><p>编译原理相关（这个也属于想想而已，写这个是因为自动机学得惨不忍睹，要补一点）</p></li>
<li><p>图形学相关（纯纯因为安主席的安利）</p></li>
</ul></li>
<li><p>跟进一些东西</p>
<ul>
<li><p>实验室项目（主要是最近划了，要跟上）</p></li>
<li><p>THUInfo 的 UI 翻新以及培养计划 / 课程表功能翻新</p></li>
<li><p>科协技能引导文档的结构初始化</p></li>
</ul></li>
<li><p>考试相关</p>
<ul>
<li><p>科目二（再不考是来不及了，大三不计划回家）</p></li>
<li><p>GRE（属于想考一下试一下）</p></li>
</ul></li>
</ul>
<p>此外还有一些杂事，包括买一个新电脑、预定 GRE 考试、选大三的课、重办身份证、回高中讲竞赛、和高中东方同好会线下聚会、陪 Sakana 玩等各种。</p>
<p>因为想做的事情很多，所以想着不如就在这里开一个日记贴，就每天写一下想干什么，最后干了什么之类的。没啥价值，目标就是让自己做点事情，别划水了。</p>
<h2 id="section">2021.06.29</h2>
<p><strong>今天想要做的事情：</strong></p>
<ul>
<li><p>去驾校办理科目二入学手续</p></li>
<li><p>公布科协网络部招新结果，准备一下文档初始化</p></li>
<li><p>CRACKER 一日游，就到处看看有什么资料</p></li>
<li><p>准备 THUInfo 主页 UI 翻新</p></li>
<li><p>问一下韩旭下一步可以做什么</p></li>
</ul>
<p>其实想做的多，最后能做完的，凭运气吧。睡大觉去了，祝自己好梦，祝自己暑假顺利。也祝 Sakana 军训平稳度过。</p>
<p><strong>今天汇报：</strong></p>
<p>基本上弄完了网络部招新的通知工作，飞书还没有完全摸完，这个晚上慢慢来。后面应该要去问一下技术顾问团他们的情况，好准备做点事情。不过考虑到零字班的新生估计还要等他们军训完了才能安排工作，所以初始化应该暂且由老人完成。</p>
<p>给韩旭发了微信消息，等他安排吧。</p>
<p>目前下学期应该是四大原理 + 人机交互 + 计算机网络安全 + 台球 / 网球，所以也可以开始做点准备了。</p>
<p>之后就是逛 CRACKER。目前的一个打算是汇编和计组应该就通过 CSAPP 先摸一下。计组可能还需要一些 Verilog 什么的东西，这个以后等买了 Windows 电脑再来搞一搞，造 CPU 的那本书也已经拿到手了，也可以拿 PPT 做一些补充。Java 相关是不打算弄多少，总之和 xge 他们组队搬砖，所以就打算把一些算法代码改成 Java 的，熟悉一下语法算了。</p>
<p>编原那就是纯纯的逆天，因为我自动机学不明白，所以编译原理需要先看一些讲义和 Compiler 那本书。</p>
<p>信号据说是数学课，所以找个课本随便学应该也就应付过去了。网原看起来属于巨大背诵的一门课，找了个《计算机网络：自顶而下》，然后要到了所有的课件，就打算看着玩玩算了。</p>
<p>至于那些限选课，网络安全技术看起来和网原巨大相关，懒得搞。然后就是人机交互没啥经验，就算了。</p>
<p>最后是打算学习图形学，问安主席要到了整本书的电子版，然后找到了网课链接，总之打算干活。</p>
<h2 id="section-1">2021.06.30</h2>
<p><strong>今天想要做的事情：</strong></p>
<ul>
<li><p>去驾校办理科目二入学手续，开始练车</p></li>
<li><p>还有一位网络部新人没有联系上，需要补联系，并且需要搞一下飞书</p></li>
<li><p>推一点点 CSAPP、图形学什么的</p></li>
<li><p>准备 THUInfo 主页 UI 翻新</p></li>
</ul>
<p>其实也没什么好说的，就是学点新知识之后做一点之前就有的锅。明天要早起所以赶快睡大觉吧。</p>
<p><strong>今天汇报：</strong></p>
<p>以为去报名的，结果刚进去就被拉上车开始练了，估计以后就是早上八点下午两点，一整个白天都要在驾校了，所以推活、上课这些事情都得是晚上来做了。</p>
<p>那个还没联系上的新人联系上了，所以招新基本上就结束了，可以开始具体规划下面一步要做的事情了。然后对下面的工作做了一点点的推进。</p>
<p>然后就是 THUInfo 还在消极怠工，不过最近会开工的，会开工的。</p>
<h2 id="section-2">2021.07.01</h2>
<p><strong>今天想要做的事情：</strong></p>
<ul>
<li><p>科目二学侧方停车、倒车入库、坡道起步</p></li>
<li><p>推一点点 CSAPP 之类的</p></li>
<li><p>准备 THUInfo 主页 UI 翻新</p></li>
</ul>
<p>主要是晚上和家里人聊了比较多，所以说实际上今天晚上也没有认真学一些东西。</p>
<p><strong>今天汇报：</strong></p>
<p>学车真的是比较无聊，就开车十分钟等待两小时，于是其实天气热什么的都不是最大的问题，无聊是最需要解决的。</p>
<p>然后，看了一点信号处理原理和编译原理，然后就发现自己的数学全忘完了，还是得回来再学一点点。</p>
<p>没什么好说的，以后估计就是这样的重复的生活了。</p>
<h2 id="section-3">2021.07.02</h2>
<p><strong>今天想要做的事情：</strong></p>
<ul>
<li><p>科目二继续练习，但是要问清楚考试时间这些东西</p></li>
<li><p>推一点点 CSAPP 之类的（这个真的要赶快了）</p></li>
<li><p>准备 THUInfo 主页 UI 翻新（栋栋跑起来 THUInfo 了，工期来了）</p></li>
<li><p>网络部工作规划再稍微写详细一点，准备主席团会议</p></li>
</ul>
<p>这两天除了科目二看起来什么都没有做呢，所以说下面还是要准备开工吧。之前似乎还说过要买新电脑的，似乎也给我搞忘了。</p>
<p>想到一年前的自己还宣称着一个人孤独地走下去反而好，现在却苦于这里找不到人一起做事，莫名有点可笑。</p>
<p>七月份，下半年的开始，要准备拾起自己了。</p>
<p><strong>今天汇报：</strong></p>
<p>很平凡地过了一天，晚上想回姜堰找人吃饭，结果因为下雨没去得了。学习也没学多少，看了一点点 CSAPP，但是也是很肤浅。</p>
<p>话说直到现在才猛然发现自己似乎没有什么兴趣爱好，这个时候又突然想到自己之前小学的时候填兴趣爱好，永远都是大众化的“读书”。思来想去，觉得自己可能不太喜欢一直呆着，自己还是比较喜欢在路上的感觉。于是就有了一个还在萌芽的想法，就是只用公交或者地铁，去很远的地方，比如说从家到北京、到广州。也正如我自己感觉的那样，我自己还算喜欢折磨自己。这个规划算是很远期很远期的了。然后问了一下 Sakana 有没有兴趣，但是她也没有给出明确答复。</p>
<p>学习？那是不可能学习的。在闷热的天气底下随时准备被教练喊去练车，这种情况下那是不可能学习的。于是我是真的把贴吧、知乎刷到推荐都开始循环，然后就开始戳 Sakana 等她回复，要么就是水群。但哪里有闲人像我这样一整天啥事没有呢，或多或少都要去做点什么事，打游戏也算。</p>
<p>自己还是很不擅长应对无聊这个问题啊。其实只要有一个聊得来的人在，但是我能聊得来的都有事情，这就尴尬了。</p>
<h2 id="section-4">2021.07.03</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>想做的事情和之前差不多，觉得也没有必要再写一遍了。</p>
<p>大概还有一些感慨吧，感慨自己怎么很容易变得惆怅起来，会有那种莫名其妙的伤感。</p>
<p><strong>今天汇报：</strong></p>
<p>今天下午和明天都不用去练车了，还算比较开心。但是相应的，我需要在这段时间内，把之前剩下来的事情处理好，包括之前自学内容要整理成文字，网络部的工作规划还是要继续细化一下，韩旭那边还要继续跟进。</p>
<p>下午先写一些工作规划，然后等韩旭那边的回复，然后就是写博客了。</p>
<p>然后目前实验室下一步要做的事情就是先调教好 T5 以保证能够做 prompt。具体的东西会在实验室周报上写，这里就不会写了，毕竟也不是什么太适合公开的东西。</p>
<h2 id="section-5">2021.07.04</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>从驾校休息了一天，计划就是什么事情不做，好好放松一下</p>
<p><strong>今天汇报：</strong></p>
<p>发现自己最大的问题实际上是，闲下来的时候很容易胡思乱想，进而就是情绪容易不稳定。最近身边也没什么了解情况的人可以好好聊聊，所以就比较尴尬了。</p>
<p>今晚似乎喝得有点多，又对 Sakana 说了一堆胡话，大概自己到现在还没学会控制情绪。</p>
<h2 id="section-6">2021.07.05</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>暑期回校的计划最终安定下来了，6 号开始讲课到 22 号，我主要负责答疑。由于 12 号科目二才能考完，所以打算到时候再回去，这前面的一个星期就晚上线上答疑吧。</p>
<p>要做的事情，大概就是继续看看论文，晚上回学校协商一下后面的安排。至于 THUInfo 和科协那边，真的有点过意不去了快要。</p>
<p>本来想今晚找 Sakana 聊聊的，但看来落空了，所以还是自己调节吧。Holder 能做到的，或许吧。</p>
<p><strong>今天汇报：</strong></p>
<p>回高中和 FFF 遇了一下，商量了后面的安排。</p>
<p>当然还有一些和 Sakana 那边的事情，这里不多说，但是至少我现在，真的感到很安心很快乐就是了。</p>
<h2 id="section-7">2021.07.06</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>没有什么很想做的，就是很平凡地看书学习、写写 THUInfo、写写实验室代码、写写科协文档。</p>
<p><strong>今天汇报：</strong></p>
<p>选课掉了康总的计组和人机交互，可能打算去搞 VLSI 来混学分。出乎意料的是台球上了。</p>
<p>自从昨天开始，Holder 就变得似乎没那么难受了，或许也与梅雨渐渐离开有关。今天上午看了一点点 CSAPP，也预约好了 12 号的科目二考试，之后就是每天去练一练就好。</p>
<p>晚上主要在安排暑培和技能引导文档那边，夏老板突然提到了可以和企业 / 实验室 / 其他学生组织做双向链接，这样的话既解决了文档来源比较单一的问题，也一定程度上提高了文档的实用价值。</p>
<p>【和 Sakana 约了见面再聊，默默期待，还有一些误解，需要慢慢解开】</p>
<h2 id="section-8">2021.07.07</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>因为上午不去驾校，所以睡大觉放松一下。晚上的话照常工作，不过比较紧急的事情是编写竞赛习题解答以及和猫猫准备一下文档的部署。</p>
<p><strong>今天汇报：</strong></p>
<p>回学校了，旁听了 FFF 的一节课。</p>
<p>大概是觉得这一届的基础有点问题吧，很基础的解析几何都没有把握很快给出正解，这就比较困难了。</p>
<p>目前老师的意思是想让我带一下几个有机会去清华夏令营的同学，自己也要开始复习一些自主招生题了。</p>
<h2 id="section-9">2021.07.08</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>回家拿一些当时的自主招生参考资料，然后准备码点字吧。自己的事的话，可能就学习一些基本的东西，然后 THUInfo 开一些工。</p>
<p><strong>今天汇报：</strong></p>
<p>出卷子真的是好累啊，到处翻找资料，然后还要想尽办法保证我是站在一个中学生的角度来思考问题。磨了一整天还熬了一夜，基本上把一份数理化的试卷全都出完了，大概准备 10 号来考这一份卷子，以筛选出适合去清北夏令营的同学。</p>
<p>我现在比较担心的是，大家都考得不高，最后还是拉不开差距。</p>
<h2 id="section-10">2021.07.09</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>学车，然后有什么事情就做什么事情。现在是越来越不太想把自己逼得太紧。</p>
<p><strong>今天汇报：</strong></p>
<p>下午把昨天出的卷子的答案给搞出来了，结果发现这份卷子应该是比较困难的，可能会把他们搞得很惨。</p>
<p>THUInfo 说要开工到现在都没有动静，实验室没干活，科协现在还在筹划。总之就是除了正事之外的事情都在做。</p>
<p>今晚回家的时候突然想起来 GRE 还没有报名，可能都快没有考位了，还是赶快把坑填上。身份证也已经做好了，要找个时间去拿。眼镜有点刮花了，其实要去重配，但是也一直在拖。头发也要去剪一下了，现在还是得注意下形象？</p>
<p>明天早上回学校与那些考试的同学见一下面，监考一下之类的。明天下午尽快把卷子批改好成绩公布。</p>
<p>另外，我仔细思考了一下，暑假还是不要预习下学期的内容为好，暑假应该做一些其他的事情。</p>
<p>所以说这个暑假的主线就变成了 THUInfo、科协、实验室、高中竞赛、 GRE。至于新电脑、身份证、眼镜、头发之类的也就是支线任务了，科目二也将会在 12 号迎来终结。</p>
<h2 id="section-11">2021.07.10</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>上午回去监考，下午批改试卷并且和老师交流一下。然后尽可能能开工的东西就得开工，目前比较急的就是实验室和技能引导文档了。</p>
<p><strong>今天汇报：</strong></p>
<p>去监了个考，然后尽快把试卷给批改好了给老师。整体而言学弟们做得还是不错，但是细节上属于是真的需要很大的工夫去训练。</p>
<p>然后就是平凡的学车和练习。</p>
<p>另外就是，盼望 Sakana 回来。</p>
<h2 id="section-12">2021.07.11</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>去高港模考科目二，期间要开始阅读论文，至于能看多少，能领悟多少就是另外一回事情了。</p>
<p>然后就是尽快考虑新电脑的事情，并且尽快制定后面的讲课计划吧。</p>
<p><strong>今天汇报：</strong></p>
<p>高港练车真的是好累好累，一整天就在那里站着看各个考试位的点位，很没意思还很折磨。</p>
<p>当天也没别的什么事情了，出去参加了一个饭局，平平凡凡地结束了一天。</p>
<h2 id="section-13">2021.07.12</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>考科目二，然后回去准备和参加清北夏令营的各位见一个面。顺便安排之后的课程。</p>
<p><strong>今天汇报：</strong></p>
<p>科目二让我整整坐在那里等了六个小时，几乎是最后一个才考的。</p>
<p>于是顺理成章地没有赶得上下午回学校，晚上才和学弟学妹们见了个面，稍微聊了一些没有什么含金量的话题。</p>
<p>Sakana 从上海回来了，但我以后白天就似乎没有什么时间去找她玩了。</p>
<h2 id="section-14">2021.07.13</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>给他们讲一点很简单的东西。</p>
<p>自己也要开始干各种的活了，包括看论文，写 THUInfo。其实最主要的是科协那边似乎真的拖不下去了。</p>
<p><strong>今天汇报：</strong></p>
<p>上课是真的很累，站很长时间会让自己很累很难受，然后还要说很多话，口干舌燥。</p>
<p>其他倒是没有什么特别的感受，总体而言就是觉得过了很平凡的一天。</p>
<h2 id="section-15">2021.07.14</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>做一些平凡的事情，讲讲课。晚上被提前安排了饭局，所以还是得去。</p>
<p><strong>今天汇报：</strong></p>
<p>照样是讲了很平凡的一些课，没有涉及到很深层次的东西。给他们做了一个限时训练，估计效果不会很好吧。</p>
<p>晚上饭局结束，去了一趟宾馆取回东西。和 Sakana 连麦闲聊了一段时间，约了明天出来玩。然后确定买了一个新电脑，联想拯救者 Y7000，显卡只是 RTX3050，处理器是 i5 的。买这个电脑是为了混一下大作业，顺便尝试一下一些只有 Windows 有的小游戏。</p>
<p>也是很平凡地结束了一整天。</p>
<h2 id="section-16">2021.07.15</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>和 Sakana 约了去猫咖看看，然后吃烧烤打电动。</p>
<p>本来上午打算睡懒觉的，结果接到消息说清北夏令营同学不放假，所以还得去一趟。</p>
<p><strong>今天汇报：</strong></p>
<p>玩得算是很开心？撸猫很好玩，但是猫毛真的是很烦人，到现在我背后都是微微发痒。撸完猫吃了甜品之后去找 FFF 吃烧烤。随后就去时代广场打电动了。</p>
<p>Sakana 说大夏天的不想出门，但这也算是没办法吧。我俩的暑假完美错开，相交的时间几乎只有一个星期左右，所以要见面的话也就只有这一点时间。不过我的新电脑到货了，以后可以找 Sakana 连麦打游戏。</p>
<p>明天被家里人安排了，后天和 Sakana 约了晚上看 1921，大后天就得送她走了。于是这个暑假就这样等价于结束了。</p>
<h2 id="section-17">2021.07.16</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>蹲在学校正常讲讲课，晚上已经有了安排所以就没啥了。</p>
<p><strong>今天汇报：</strong></p>
<p>实际情况是，高中突然出现了电力故障导致学校全部停课，但是参与清北夏令营的同学由于在小教室里没有被电力故障波及所以电力一切正常。但是可以想见的是，看见同学们放假了，他们也完全没有心思学习。所以我就和他们玩狼人杀，聊了聊他们现在的焦虑和压力。</p>
<p>他们不是不想学习，但是高中这个体系给他们的限制实在是比较多，我作为学长也只能劝说他们做一些适应和牺牲。其实有的时候，也真的是毫无方法。</p>
<div class="note info no-icon"><p>有时治愈，常常帮助，总是安慰。 To cure sometimes, to relieve often, to comfort always.</p>
</div>
<p>这是特鲁多的名言，本来是形容医生的。但现在看起来我有的时候也像是这样，我帮不了他们实现他们理想中的高中生活，我最多只能做到帮助他们去理解这个可能有些扭曲的体系，让他们稍微以一种平稳的心态度过高中。</p>
<p>高中这边结束之后就去忙自己的事情了。明天去见 Sakana，18 号还有一小波聚会。</p>
<h2 id="section-18">2021.07.17</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>正常地活下去。重要的事情是开工技能引导文档。</p>
<p><strong>今天汇报：</strong></p>
<p>结果上午翘班了，在配置新电脑的 C 语言编译器和装 Python。结果就这两件事硬生生让我一个上午耗费完了。下午平凡地来高中简单讲了些东西，也顺便做了一些小事情。</p>
<p>晚上陪 Sakana 看了 1921，虽然对题材没有特别的兴趣，对演员无感，但感觉看下来还算是一部不错的电影，除了叙事线很多很杂，要不是了解一些历史可能就会错乱吧。</p>
<p>Sakana 不急着 18 号就直接回去了，打算 20 号左右回去，于是就默默约了 19 号再出来玩。</p>
<p>总之就是，一切都在慢慢变好。</p>
<h2 id="section-19">2021.07.18</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>今天约了同学聚会，所以重点会在出去玩上。不过高中这边也应该好好干活。</p>
<p><strong>今天汇报：</strong></p>
<p>和姜东会玩了一个下午一个晚上，先去麦当劳吃饭搓音游，然后星巴克打雀、掼蛋、闲聊，之后定番小菜园聚餐和舞立方手痒打机，最后 KTV。</p>
<p>KTV 上我唱了不少歌，但最满意的还是《太阳系 DISCO》。作为自己很喜欢和大家都能参与（指鼓掌和参与オーオオー以及ナナナナナナナー环节）的一首歌，整体气氛还是很好的，比那些大部分人看不懂歌词也不熟悉的比较冷的 V 曲要好一些。当然唱完这首歌我嗓子就明显不行了，中途的一段几乎就是在纯靠喊。</p>
<div class="note info no-icon"><p>あの一等星のさんざめく光で，あなたとダンスを踊ろうか。 ーー「太陽系ディスコ」</p>
</div>
<p>回来之后就是和 Sakana 闲聊了一会，然后转头就装了个有补丁的 Riddle Joker 开始推。由于之前认真推过没有补丁的七海线，所以这次就很快地过掉了，看了一下 H 情节怎么搞的就睡觉去了。</p>
<h2 id="section-20">2021.07.19</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>今天 Sakana 家里有一些事情不能出门了，所以今天见不了面了。有一些话不如连麦的时候随便扯一下吧，晚上陪她打打游戏什么的也不是不行。</p>
<p>其他事情就正常慢慢推进就好。</p>
<p>【我自己依然在为一些虚无缥缈的东西而伤心，Holder 还是需要花一些时间来恢复理性】</p>
<p><strong>今天汇报：</strong></p>
<p>用了点时间给自己的网站加了个评论系统，本来是想用 Valine 的，结果现在较高版本的 NexT 不支持了，所以退而求其次装了 DisqusJS，他的缺点就是需要翻墙的账号。</p>
<p>之后听从了栋栋的建议换了 <a href="https://twikoo.js.org">Twikoo</a>，发现是真的好用而且还不用翻墙，现在我直接安利这个评论系统。</p>
<h2 id="section-21">2021.07.20</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>今天 Sakana 回上海了，所以估计是不能去找她了。</p>
<p>Holder 一个人要好好地过好自己的生活。</p>
<p><strong>今天汇报：</strong></p>
<p>大概就是接着修了一下评论系统，然后出去吃了个饭，结果又喝多了（Holder 从来没有信守过自己的 flag）。回来之后和 Sakana 连麦闲聊了一点点，似乎一直在说胡话，语无伦次。</p>
<p>之后就是和 LCR 两个人联机打 Minecraft，但说是一起玩，实际上就是两个人在已经建好的一个挡里面骑马。</p>
<div class="note info no-icon"><p>【 LCR 】芜湖，上次骑马出去忘了把第二只马骑回来，Holder 你没马了。</p>
</div>
<p>大概就这样平凡地过去了一整天。</p>
<h2 id="section-22">2021.07.21</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>今天和高中的老师一起吃饭讨论这几天讲课的情况，实际上 Holder 并没有做出什么很突出的贡献。</p>
<p>接着过下去就好了。</p>
<p><strong>今天汇报：</strong></p>
<p>听闻 LCR 那边可以提供他们宿舍给我住，突然有点想要去上海玩一圈，也正好送一下 Sakana。但是南京突如其来的疫情让家里人对此很担心，我自己还算是不太认为会影响到什么，但也因此搞得很不愉快就是了。</p>
<p>上海不去就算了吧，反正也只是去见个面，最多晚上陪 Sakana 在交大转转圈，再陪 LCR 打一白天加一晚上游戏。</p>
<h2 id="section-23">2021.07.22</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>好好生活。</p>
<p><strong>今天汇报：</strong></p>
<p>最近一直比较烦躁，不知道是因为无聊还是因为什么。其实能隐隐约约感到实际上就是因为当下各种事情都不顺遂（科协事情没做，实验室那边也在咕咕咕，高中这边还是感觉自己没做到什么有用的事情）加上后面还要和 Sakana 失联，一下子又没有了倾诉的人，FFF 不久出去旅游，这下子是真的没有谁出来一起玩了。还是那句话，想到一年前的自己甘愿一个人闭锁在黑暗的房间里，独自对着屏幕无论是欢笑还是难过，都不愿意和其他人过多交流，现在的我无疑是对过去的讽刺。</p>
<p>不过稍微好一些的是，我可能解开了一些心结。概括来说大概就是，我以往认为自己伤感的来源是别人变得特立独行而怪异，但是自己认认真真享受过生活之后，我才认识到，以往昏暗的我才是最为特立独行的。</p>
<div class="note info no-icon"><p>从一个本就不合群还自认为合群的人的眼光之中看去，那一切的平凡和正常，反倒是怪异。</p>
</div>
<p>所以 Holder 重新立起 flag，从今开始好好生活。</p>
<p>【箴言：Holder 的 flag 没有不倒的】</p>
<hr />
<p>于是今天上午的 Holder 起床之后就在 Riddle Joker，现在应该只剩下茉优线没有完全结束了（年上系真的不在我的 XP 上，最后推自然没有任何的问题）。</p>
<p>中午的 Holder 开始到处看 V 曲的 live，真的突然想去一次 V 家演唱会。要说现场感比较好的歌的话，<a href="https://www.bilibili.com/video/BV1Nf4y1U7z1?t=279">《Unknown Mother Goose》</a>是首推（众人おおおーおおー的那个场面真的是很震撼的），之后就是<a href="https://www.bilibili.com/video/BV11W411C7io?t=295">《劣等上等》</a>（Giga 的专业炸场子歌），<a href="https://www.bilibili.com/video/BV16s411h7eE">《号哭》</a>和<a href="https://www.bilibili.com/video/BV1As411B7J8">《东京泰迪熊》</a>也算是很有感觉的。然后就似乎沿着推荐来到了几个网络合唱视频，首先是 2017 年的<a href="https://www.bilibili.com/video/BV1Nx411u7YT">《砂之惑星》</a>（八爷 yyds，可惜出道娱乐圈了，当个 P 主不好么），然后是 2011 年的<a href="https://www.bilibili.com/video/BV1Ax411w7Sh">《千本樱》</a>，也算是猛然回忆起高中的一些时光了。</p>
<p>之前在<a href="/about">关于页</a>提到我最喜欢《无梦之梦》，但是这首歌适合一个人在难过的时候自己听，用来做安慰用的。其实春卷饭的歌基本都是这个特征，很温柔，适合一个人独自欣赏，很难在演唱会上表演得好。同理还有新曲<a href="https://www.bilibili.com/video/BV1hA411g7mt?from=search&amp;seid=51222177324975189">《第三心脏》</a>，也是最近很喜欢的。</p>
<hr />
<p>最终通过一番协商，还是决定去上海了。自己的一时冲动把 Sakana 还有家里人的安排搞得一团乱，说实话现在还是有一点愧疚。然后在安排在上海的行程的时候，发现竟然想不到可以去哪里玩。</p>
<p>所以说，Holder 的脑子一热带来的是无数若干的混乱，让 Sakana 落单还拉着她一起不知道干什么，一时间不知道说什么好。</p>
<p>今天 Sakana 应该是和同学们出去玩去了，Holder 一个人默默地去未来极越把卡里的钱给用掉了，之后骑车绕县城转了一圈。</p>
<p>一个人真的很无聊，无聊的时候就喜欢胡思乱想，然后可能就会做出很没有理由的事情。</p>
<p>惋惜我自己的高中没有发展若干的朋友，导致现在回到家乡竟然是四处无人。还不如早点回北京，至少我的舍友可以一起打牌，一起出去找地方看个电影或者是到处找点吃的。或者就是找北大的几个熟人出去转转，要么也可以和迅哥哥等 308 闲聊。</p>
<p>于是 Holder 又开始莫名难过起来，Holder 自以为值得夸耀的，竟然是一片荒芜。</p>
<p>Holder 嫉妒且憎恨着那些现实生活充实的人们，虽然这种无名火显得幼稚且没有道理。Holder 似乎就像是对着并不存在的敌人宣战一般，对着自己幻想中的困境，对着不存在的挫折精神低落而恍惚。</p>
<p>那个好好生活的 flag 突然显得可笑。</p>
<hr />
<p>我一直在思索着，现在的我的生活多么像我先前的追求。和同学彻夜聚会，和 Sakana 看电影、逛街、撸猫，即使一地鸡毛但依然决定去上海，那种自由挥洒情感，自由表达自己，不计成本地为了简单的目标而大闹一番的生活。然而我却似乎不像是之前那样无忧无虑，我每天都被一种不能明状的忧伤所萦绕。即使某天我说我释怀了，我看开了，我似乎找到了生活的乐趣。即使我这么说，我的心中实际上从未解开过这种难过的感情，只不过是因为当下的愉悦而暂且麻痹。</p>
<p>在房间里自说自话地走了几圈，尝试理清楚自己这个情感的来源。结果还是不太弄得明白，所以暂且作罢。</p>
<h2 id="section-24">2021.07.23</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>逃到上海，然后不知道干什么。</p>
<p><strong>今天汇报：</strong></p>
<p>单纯地溜来上海了，Sakana 因为绿格那边的政策一直没有很能确定下来比较低落，于是也就很单纯地一起吃了饭，去了私影玩了一圈而已。</p>
<p>晚上打算玩冬日计划，结果因为网络原因一直没有能够一起玩得了，只能作罢。</p>
<h2 id="section-25">2021.07.24</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>和 LCR 混一天。</p>
<p><strong>今天汇报：</strong></p>
<p>大概就是中午先和 Sakana 吃了一顿饭然后就和 LCR 一起到处瞎跑了。</p>
<p>本来的预定是去外滩，沿着江边随便走走，结果 LCR 在地铁半路上突然提到想要去海边，但是已经出发一段路了，就决定去黄浦江入长江口转一圈。地铁坐了整整两个小时到双江路下，然后就是沿着黄浦江骑车十几公里。本来以为沿着江边能看到什么的，结果全是造船厂，能看到的就是一堆重型机械和工人们。值得一提的是本来今天是台风来的日子，结果雨是真的没有下下来，倒是风是相当的大，大到我骑车下坡不蹬的话，风会把我吹上坡。</p>
<p>然后就是沿着一条路一路骑到了入江口，那里的风已经是相当大了，但依然没有能阻挡钓鱼佬们翻越围墙站到江边的防波堤上钓鱼。自己胆子小，就没翻过去看看，所以也就站在墙外拍了照片，打了个车回去了。</p>
<p>至于今晚发生的一些并不太愉悦的事情，还是暂且不提吧。只能说现在的 Holder 不太振作得起来。</p>
<h2 id="section-26">2021.07.25</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>活着。</p>
<p><strong>今天汇报：</strong></p>
<p>台风终于登陆上海了，整个天都是漆黑的那种，狂风大作暴雨如注。然而我还是和 LCR 两个人出了门在上交里面转了好长一段时间，跑去下院瞎窜，去思源湖边上看台风，去宿舍楼的风口看被吹倒的树。</p>
<p>反正就是两个不要命的人在台风天的无聊之举，和昨天顶着台风去江边上差不多。结果是误了回去的火车，不得不立刻改签第二天的。</p>
<p>Sakana 自然在台风天不愿意出来，所以一整天都没有见到，晚上喊她打游戏也没有理我，说是没有兴致。</p>
<h2 id="section-27">2021.07.26</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>继续活着。</p>
<p><strong>今天汇报：</strong></p>
<p>早上爬起来就接到了火车取消的消息，于是不得不接着留一天。</p>
<p>早上和 LCR 就一直在打 Minecraft 消磨时间，生存档从零开始真的是很耗时间的一种玩法。玩好了之后和 Sakana 说了下午陪她去做核酸，最后是自己任性地拉着她冒着还算不小的雨去了天街。</p>
<p>晚上没事做，于是合计了一下和 LCR 又出门了，结果是一天去了两次天街（这个时候就得说交大旁边真的是没啥玩的，除了两个商场、一个桌游店、一个 KTV、若干小饭馆之外似乎什么都没有了，喊 Sakana 出门最终的归宿永远是找一个吃饭的地方闲聊，最多去看电影）。</p>
<h2 id="section-28">2021.07.27</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>回家，然后活着。</p>
<p><strong>今天汇报：</strong></p>
<p>早上 Sakana 突然说打算送我去火车站，但实际上我知道她出远门的东西还没收拾好，但还是答应了。</p>
<p>然后就没有什么特别的事情了，在火车站拥抱后分别，自己一个人坐火车然后兜兜转转回到了家，冒着雨赶去高中。</p>
<p>一整天都过得比较累，回来之后又不得不通宵清掉了一些任务。</p>
<h2 id="section-29">2021.07.28</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>清闲地活着。</p>
<p><strong>今天汇报：</strong></p>
<p>今天是给高中的学弟学妹们考试的日子，自己是出题人也是监考。监考这个活是真的令人烦躁，无聊至极，甚至愿意出点事情让自己不至于无聊。</p>
<p>Sakana 最终踏上了旅程，坐了十个小时的火车前往兰州，她也在经受着无聊的时光。两个人一起听歌了一个小时，她到达兰州之后需要办理一系列的事务，便暂且失联了。</p>
<hr />
<p>不过 Holder 似乎算是慢慢理清楚自己到底在担忧什么了，异地造成的交流不畅和误解真的是相当折磨。不多说吧，总之就是意识到了我和 Sakana 处境其实类似，而我潜意识里深刻地误解了很多的事情而已。所以现在应该心态平稳很多了，Holder 也已经下定决心要保证自己生活乐趣的多元化了。</p>
<h2 id="section-30">2021.07.29</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>一个人活着。</p>
<p><strong>今天汇报：</strong></p>
<p>今天什么都没有发生，起床吃饭，一个人躺在床上刷手机。就是典型的一个无聊的人应该有的样子。</p>
<p>现在 Sakana 应该到达了最终的目的地，可能以后就会是几乎完全失联了。大概如此。</p>
<h2 id="section-31">2021.07.30</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>把科协暑培好好弄好。</p>
<p><strong>今天汇报：</strong></p>
<p>Sakana 现在彻底处于失联状态了，多半是不到晚上联系不上了。虽然有点消沉，而且为生日怎么办的事情有点烦躁，但是自己的事情还是得好好做下去。</p>
<hr />
<p>就这样吧，这个纪录就此结束，新的生活渐渐就要开始了。</p>
<p>Holder 通过这个暑假，大概是缓慢地将自己的心态平稳下来了，或许还有一些不能言说的不舍、迷惘、辛酸等等，但暂且都埋藏起来吧。不过相较于一个自闭的 Holder，虽然现在的我或许不如以往那样沉稳专注，但可能更像一个正常的人吧。</p>
<div class="note info no-icon"><p>あたしが愛を語るのなら，そのすべてはこの歌だ。 誰も知らないこの物語，また口ずさんでしまったみたいだ。 「 Unknown Mother Goose 」</p>
</div>
<p>总而言之，或许还有许多的困难，还有许多的考验，还有很多我们需要去做的事情，但我依然坚信未来可期。</p>
<p>我是 Holder，我们继续走下去吧。</p>
]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
  </entry>
  <entry>
    <title>2022 年寒假总结</title>
    <url>/2022/02/13/winter-conclusion/</url>
    <content><![CDATA[<p>寒假也快结束了吧。</p>
<p>其实依然是什么事情都没有做的一段时间。</p>
<span id="more"></span>
<h2 id="打牌">打牌</h2>
<p>在放寒假之前雄心壮志地想好了很多想做的事情，从 THUInfo 到技能引导文档，乃至实验室工作甚至是学抽象代数。但实际上我的寒假大约一大半时间在打牌。</p>
<p>在寒假回家的前一天，我打了一个通宵的雀，从那以后就莫名其妙比以往更沉浸在打雀之中。一方面可能和当时刚刚打上玉间有关，更重要的可能是当时我恰好处于绝好调的状态。那段时间我几乎是一四流选手，顺风的时候不需要读牌，不需要防守，牌局前期一般就能通过奇妙的运气和出亲跳和若干亲满奠定靠近五万点的胜局，后续哪怕铳几个子家满贯也不过洒洒水。</p>
<p>所以我从刚进玉间到冲上豪三并未花很长时间，大约两个星期而已。但是随后而来的是恶调，那段时间牌谱屋的数据表明我的起手平均向听数直接飙升。这个时候原先漏洞百出的打法显然完全不能适应，所以掉回了豪二。</p>
<p>在寒假快要结束的时候，接到了你清打算组织参加全高赛的信息，即使当时已经有点觉得自己过于打雀而疏忽要做的事情，但是还是毅然决定参赛。目前的结果呢，即使自己技术拉跨，但还是靠着奇妙的狗运挂边入选了代表队。</p>
<hr />
<p>我之前在 QQ 空间以及朋友圈都发过一个反省自己打雀水平的小短文，一定程度上也和这次选拔赛四位评委对我的评价类似。</p>
<p>我对我自己的一个评价就是过于死板或者直线，不够灵活，这和自己面麻喜欢打快牌以及还有时在家和家里人搓牌有关。快牌的一个显著特点就是几乎没有什么读牌的时间，因为构建自己手牌的方向就足够耗时间，所以我应对快牌的方式就是不顾一切地进攻，烂牌也全牌效，抓到明显的危险张也往往手比脑子快拍出去放大炮。并且，另外一种应对就是尽早立直进入摸切，这样能获得一点休整时间。</p>
<p>过于欠缺的防守和读牌技术使得我这一次在比赛中，即使有意识在防守，也常常会在半途发现自己没有安而侥幸着遵循“没有安就日”的信条重新回到进攻路线，然而心中的不安和紧张又会在摸到模棱两可但安全度还可以的牌的时候转为防守。我猜测这也就是评委认为我不稳定的原因之一。</p>
<p>但其实我说没有安的时候真的没有安么？其实很多时候是可以通过读牌获取一些安度其实还可以的安的。我的防守理论只有筋牌和壁牌，我对手顺的认识是相当低的，比如说连切 64m 时一般而言 58m 铳率低，这一点我很难注意到，我只会认为 58m 是没有通过的筋而完全缩。</p>
<p>还是想找找有无讲防守的一些书籍什么的。</p>
<hr />
<p>不够灵活的另外一个致命体现就是甚至可以看漏听牌，比如说名场面：</p>
<p><img src="/uploads/winter-conclusion/1.png" /></p>
<p>这里吃 1s 后打什么呢？实战我打了 8s，连切 3m 听牌都没有发现，这就是梦游切牌的技术。</p>
<h2 id="技能引导文档">技能引导文档</h2>
<p>这是我在寒假前期一直在做的事情，后期想接着做但是有点懒而且有点缺乏动力。</p>
<p>简单来说技能引导文档的初期还是取得了不错的成绩，推送有不错的浏览量，也有一定的用户反馈，编写者们也算是很有责任心。但“这个文档是不是一个造轮子的项目？”，这个问题还一直萦绕着我。目前来看文档确实是走入了一些困境，我们编写了一些编程语言的入门指导，编写了一些简单的算法入门文档，但是我们发现我们真正需要人手来编写的 advanced topics 却恰恰没有人来写。</p>
<p>我一开始设想的核心竞争力，一方面是面对你清这些已经有一定编程基础的学生，没有必要讲解那些相当基础的内容，也就是说，我们简洁。另外一个，就是我们有一些更为 advanced 的知识，比如图形学、人机交互、操作系统等一系列的入门指导，无论是简单的介绍还是课程、资料推荐，都是不错的。</p>
<p>然而现在的困境就是没有人来编写这些 advanced topics。现在也渐渐有点沉默下去，不太想打理这一份文档了。</p>
<h2 id="thuinfo-以及其他">THUInfo 以及其他</h2>
<p>目前绝赞咕咕咕 THUInfo 的开发工作，我希望下学期开头不太忙碌的时候能做一些事情。</p>
<p>当然，现在有点希望去做一些实习，这样的话能稍微了解一下业界和真实的软件开发环境。目前规划问问有没有去微软的实习机会吧。</p>
<h2 id="其他的一些">其他的一些</h2>
<p>整个寒假过得其实挺快乐，前期虽然和社区的沙雕书记起了不少摩擦，但隔离的时候也算是最认真的时候，发布了文档第一版本还确确实实提升了一些雀力。</p>
<p>回家过年则很一般，过年也就是在各处亲戚串门，闲工夫出去看电影。初三往后去了姜堰见了同学，和 Sakana 玩了两三天，和我弟交流了不少高中相关的事务。最后回家，打牌。</p>
<p>总而言之就是一种完全放松而不想做事情的态度。</p>
<hr />
<p>下学期，我打算把培养方案直接全部完成，虽然可能中途会退缩。然后 V+ 那边也会时常参加线下活动，雀的话应该也会经常约训练赛。THUInfo 那边就只能慢慢磨，实验室只能说徐老师暂且还没找我麻烦而已，但后续肯定是不能再咕咕咕了（毕竟关系到自己的后路）。</p>
<p>总之每一个学期或者假期结束的时候都会有一种下一学期（这个假期）好好干什么什么事这样的想法，但最后往往漂亮地事与愿违，这一切最后，还是归根于 Holder 这个人的惰性和摸鱼，先给那些被我摸鱼耽误事情的人道个歉。</p>
<p>但不管怎么说，生活还要继续过。下一步，应该是主要先应付实验室，不能真的一点事情不做了。然而在此之前，今天约了人出去吃饭，生活嘛，就是这样。</p>
]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
  </entry>
</search>
