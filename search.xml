<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>安卓前端开发杂谈</title>
    <url>/2021/09/01/android-dev-exp-1/</url>
    <content><![CDATA[<p>安卓的移动端开发，属实让我血压高了一小段时间。毕竟已经接触过类似于 React Native 那种基于 TypeScript 语言的、优秀的跨平台移动端框架，再去尝试用繁琐的 Java 语言写安卓前端自然是不适应且感到烦躁。</p>
<p>但是毕竟是 Java 程序设计训练课程，安卓前端开发作为其最大的特色，不得不消受。</p>
<span id="more"></span>
<h1 id="关于数据绑定">关于数据绑定</h1>
<p>如果要我说最大的不适应的地方，首先就是数据和图形界面的完全分离。在 React Native 框架之中，数据和图形界面的管理大概是这样的：</p>
<figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">(<span class="params">props: AppProps</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Set states &amp; initialize</span></span><br><span class="line">    <span class="keyword">const</span> [bar, setBar] = useState&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some functions to update or rewrite data</span></span><br><span class="line">    <span class="keyword">const</span> update = <span class="function">() =&gt;</span> setBar(<span class="function">(<span class="params">o</span>) =&gt;</span> o + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write UI with TSX, use data freely</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Text</span>&gt;</span> Hello world! <span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Text</span>&gt;</span> &#123;`The val of bar is $&#123;bar&#125;`&#125; <span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Text</span>&gt;</span> &#123;`Property foo is $&#123;props.foo&#125;`&#125; <span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;update&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在安卓之中，图形界面完全定义在 <code>.xml</code> 文件之中，而且一定程度上其定义各个组件摆放方式的语法细节的繁杂程度不低于 HTML 。而如果需要将数据载入图形界面，则首先要根据组件的 ID 获取组件，之后才能调用各种方法设定具体属性。</p>
<figure class="highlight java"><figcaption><span>Java</span></figcaption><table><tr><td class="code"><pre><span class="line">((TextView) view.findViewById(R.id.entity_name)).setText(data.name);</span><br></pre></td></tr></table></figure>
<p>这里出现的 <code>R</code> 类据说是相当厉害的。但是我第一次接触安卓的时候，这个符号给我带来的感觉就是不安，因为我再也不能像写 React Native 一样至少自认为自己掌握了程序之中的数据流。换一种说法，即使 React Native 可能做了很多背后工作，但它至少做到了让开发者在很多时候能直观引导数据流。</p>
<p>对于按钮等组件， React Native 框架下可以直接传入回调函数。而众所周知 Java 是纯净的面向对象语言，怎么会有 lambda 这种异端呢（新版本的 Java 已经离经叛道了！）。</p>
<p>所以你需要写监听器对象，重写其中的方法等等。</p>
<hr />
<p>并不是说这样不好，我还记得之前大一小学期的时候写 Qt 很多时候就是各种指针到处乱飞然后到处乱 <code>set</code> 这个那个的，最后一个 <code>draw</code> 函数里面上百行的，成块的各种格式设定、字体设定、内容设定、排列设定，然后这次写安卓让我回忆起了那一段黑暗时光。</p>
<h1 id="并不适应的适配器模式">并不适应的适配器模式</h1>
<p>如果只是想给一个 <code>TextView</code> 载入文字，直接几个 <code>set</code> 函数就结束了。但是给一个格式复杂的列表载入数据，则相当繁琐。比如说现在主流的 <code>RecyclerView</code> ，其载入数据，就需要你自己编写一个数据适配器。</p>
<p>我首先是上网找轮子，随后想了一下，干脆自己包装了个简单的 <code>RecyclerViewAdapter</code> 先勉强用用。</p>
<p>将数据塞到图形界面上，最重要的三个东西是上下文、使用什么 <code>layout</code> 和数据本身，那么适配器的构造函数就需要接受这三项。然后就是平凡地重写 <code>RecyclerView.Adapter</code> 所要求的三个函数。不过这里我在重写 <code>onBindViewHolder</code> 的时候留了空，因为这里就是定义适配器最重要部分——数据如何映射到 UI 的函数。我将这一个函数设为虚函数，让子类继承重写就可以实现各种映射方式。最后的成果大致这样：</p>
<figure class="highlight java"><figcaption><span>Java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RecyclerViewAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">RecyclerViewAdapter</span>.<span class="title">ViewHolder</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Context mContext;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> mLayoutId;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;T&gt; mData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecyclerViewAdapter</span><span class="params">(Context context, <span class="keyword">int</span> layoutId, List&lt;T&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = context;</span><br><span class="line">        <span class="keyword">this</span>.mLayoutId = layoutId;</span><br><span class="line">        <span class="keyword">this</span>.mData = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ViewHolder(</span><br><span class="line">                LayoutInflater.from(mContext).inflate(mLayoutId, parent, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(<span class="meta">@NonNull</span> ViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> What is this?</span></span><br><span class="line">        <span class="comment">// holder.updatePosition(position);</span></span><br><span class="line">        <span class="keyword">this</span>.convert(holder, mData.get(position));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">convert</span><span class="params">(ViewHolder holder, T data)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mData.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">private</span> View mConvertView;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ViewHolder</span><span class="params">(View itemView)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(itemView);</span><br><span class="line">            <span class="keyword">this</span>.mConvertView = itemView;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> &lt;K extends View&gt; <span class="function">K <span class="title">getViewById</span><span class="params">(<span class="keyword">int</span> viewId)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (K) mConvertView.findViewById(viewId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用起来也简单，传入三个要素，之后重写 <code>convert</code> 方法定义一下数据到 UI 的映射就好了：</p>
<figure class="highlight java"><figcaption><span>Java</span></figcaption><table><tr><td class="code"><pre><span class="line">binding.entityList.setAdapter(<span class="keyword">new</span> RecyclerViewAdapter&lt;Entity&gt;(</span><br><span class="line">    HomeFragment.<span class="keyword">this</span>.getActivity(), R.layout.home_entity_item, baseEntities</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">convert</span><span class="params">(RecyclerViewAdapter.ViewHolder holder, Entity data)</span> </span>&#123;</span><br><span class="line">        ((TextView) holder.getViewById(R.id.entity_name)).setText(data.getLabel());</span><br><span class="line">        ((TextView) holder.getViewById(R.id.entity_category)).setText(data.getCategory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>你会发现，这比 React Native 要写的东西多太多了。上面这么多需要折腾的， React Native 只需要这样写：</p>
<figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;View&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        baseEntities.map(<span class="function">(<span class="params">val, ind</span>) =&gt;</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">key</span>=<span class="string">&#123;ind&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Text</span>&gt;</span> &#123;val.name&#125; <span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Text</span>&gt;</span> &#123;val.category&#125; <span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">        ))</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/View&gt;</span><br></pre></td></tr></table></figure>
<p>就可以实现一个列表了。</p>
<p>Java 我写了一整个类，光数据转成 UI 也写了好几行长代码，这还没有算 <code>.xml</code> 文件。</p>
]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
  </entry>
  <entry>
    <title>大二春季学期学期总结</title>
    <url>/2021/06/19/grade-2-conclusion/</url>
    <content><![CDATA[<p>魔幻的大二春季学期最终还是随着自动机考试的结束而落幕了，随意写一点东西来总结一下吧。</p>
<span id="more"></span>
<p>虽然还没有出分，但我能够预料到这一学期如果按照绩点来评判，可以说过得十分坎坷。但是，这一学期还有更多的比绩点更值得重视的一些东西。</p>
<h2 id="课内学习">课内学习</h2>
<p>课内总体而言过得很不平凡，即使这一学期只有 24 学分的课程。与一年前那种 OOP 作业一发下来就赶快刷榜完成，高代选讲还愿意在课外学习很多内容的热情相比，我这一学期对课内显然是淡薄了很多。标志性的事件可以罗列出来：</p>
<ul>
<li><p>人智导 PA2 是在黄浦江上遥控卫爷写的， PA3 是在上海桌游店里打山屋惊魂的间隙交的；</p></li>
<li><p>在各种情况下写过数电实验报告，包括在人大门口醉酒的时候、在去上海的火车上、在轰趴的自动麻将机上（除了考试，我每一次实验的代码都是抄的）；</p></li>
<li><p>一个学期没有见过数电、自动机、人智导的老师，这三门课均让我在考试周通了宵（一个大二学生用 24 小时创造一个奇迹）；</p></li>
<li><p>软件工程大作业不到最后一周都没有认真写 UI ；</p></li>
<li><p>高性能一气之下决定退课，虽然从未后悔过这个决定；</p></li>
<li><p>英语课一个学期就做了一份作业，占比最大的 Task C （团队 pre ）只花了三四天准备；</p></li>
<li><p>物理实验报告分数为 9, 8.5, 8.7, 8, 8.7 ，上学期则是 9, 9, 9, 9.3, 9 。</p></li>
</ul>
<p>总之就是这学期浪了一些，或许是认清楚你清贵系的教学水平甚至还不如高中之后的一些合理举动。如果要我来评价大二下学期这些课程的话，我只能说除了《不朽的艺术》这一门课，其他的课程我丝毫没有觉得学习到了什么有用的东西。再加上期末四门专业课考试两门可以说出事故的情况，我更是愿意给这一学期以低评价。</p>
<p>我大概算了一下，反正现在绩点的浮动不会多大，还不如抓紧时间，做一些我觉得有意义的事情。</p>
<h2 id="thuinfo">THUInfo</h2>
<p>我也说过，这是我唯一拿得出来的作品。虽然之前有写过一些小型项目，它们虽然也是我探索的足迹，但总体没有 THUInfo 给我带来的成就感大。</p>
<p>但比较愧疚的是这一学期没有给 THUInfo 作出很大的贡献。寒假的时候翻新了“计划”功能，修了几个小 bug 之后，学期中除了加了比如说“今日高亮”这种小功能之外，我也就没有作出什么贡献了。</p>
<p>但是，暑假确实是想要做很大的事情的。一方面是和校内 iOS Club 搭上了关系，对方也恰好想要找到一个重点支持的项目，双方互相需要，何乐而不为呢。通过它我们找到了美工，目前也有了一个较为简单的 UI 效果图（不得不说，做设计的就是做设计的）。另外一方面是<a href="https://www.zhihu.com/question/63407413">栋栋</a>加入了团队，总之多一个技能熟练的人手是很不错的。</p>
<p>敬请期待暑假过后的 THUInfo 3 系列版本。</p>
<h2 id="社工">社工</h2>
<p>大一下学期一番折腾之后，一个学期没有加入任何学生组织。但是一个转变的契机就是 xge 和我说他和栋栋准备开发日麻，随后将我纳入了 308 （科协 &amp; 算协活动室）常驻人员之中。在 308 蹲守的过程中，我也认识了科协的许多同学（再次点名“表扬”大恶人安頔）。最后决定加入科协，大概是那天去出去散心醉酒，隔天回校的时候恰好赶上 C 楼门口的智能体嘉年华。本来是不打算去的，想着去看看也没啥问题，就突然发现科协办的东西还挺有意思。随后又去蹭了智能体决赛，还坑了 Omega Fantasy 一顿饭。</p>
<p>随后大约是某晚和安頔夜谈，经过一番交流，决定去混一个科协副主席。</p>
<p>怎么说呢，或许真的是如同之前一些人的评价——“你大一下学期的那种情况实属罕见，哪有人开局社工就是王炸的”一般，社工并不是我想的那么不堪。现在大概是发现，有一群志同道合的人一起做事情是多么愉悦。</p>
<h2 id="sakana">Sakana</h2>
<p>这一段没有什么特别想说的，总之揭开了一些过往，给一些问题作出了解答，这应该也是这个学期我应该可以说最为重视的一件事。虽然有很多的小细节，有很多的瞬间，但还是就留下我之前发在空间里的一段话吧：</p>
<blockquote class="blockquote-center">
<p>虽然我真的不会挑时间，不会好好规划安排行程，或许会因为冲动把事情做得很离谱。 但真的感谢包容我的愚拙。</p>

</blockquote>
<h2 id="一些总结与闲话">一些总结与闲话</h2>
<p>这一学期的 Holder 发生了相当大的改变，应该是真的去思考过我的大学应该如何度过这个问题了。之后就确立了“<strong>我要帮助后辈们尽可能少走弯路</strong>”这样的一个简单的目标，于是和改制的科协网络部不谋而合，于是和高中班主任谈好了回高中给学弟学妹讲数学竞赛。在确立好自己的真正想做的事情之后，便是卸下一些伪装。先前的我大概因为完全不能找到我自己的目标，而将自己浸没在无意义的内卷之中，也不敢面对自己的一些感情。这一切的一切，都在稍微通透之后被瓦解了。</p>
<p>当然我感觉需要警惕的，就是我暂且需要约束一下自己无限膨胀的野心，不能给自己捞太多的锅，接太多的任务，应该让自己慢慢达到一种平衡。</p>
<p>不如现在，来说说之后想要做的事情吧：</p>
<ul>
<li><p>接着跟进在刘知远实验室的任务，努力发篇文章，发完就撤退；</p></li>
<li><p>翻新 THUInfo 的 UI ，开发一些新功能；</p></li>
<li><p>在科协把“技能引导文档”这件事做好，做到宣讲会上的“为了创建一个 user-friendly 的计算机系而奋斗”；</p></li>
<li><p>好好地生活，让自己的大学不仅仅是绩点和社工。</p></li>
</ul>
<p>还有就是一些暑假要做的事情，比如说 GRE ，比如说科目二，比如说回高中讲竞赛，比如尝试一下图形学。</p>
<p>写这篇潦草的总结的时候，我应该还因为昨晚通宵复习自动机而头晕目眩，但是我的神志却异常清醒，因为我的大学似乎是真的开始了。</p>
<p>我有分享歌词的习惯，这里也来一句吧。但不同于之前我喜欢分享那种长长的，哲学家写散文式的歌词，这个歌词很朴素：</p>
<blockquote class="blockquote-center">
<p>ケーキも大好き，君も大好き。 ーー「とある一家の御茶会議」</p>

</blockquote>
<p>祝愿我余下的一半本科时光，能过得有意义。这里是 Holder ，我们一起接着走下去吧。</p>
]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
  </entry>
  <entry>
    <title>大三秋季学期前的一些碎话</title>
    <url>/2021/09/12/grade-3-preview/</url>
    <content><![CDATA[<p>自己似乎就这样莫名其妙成为了一个大三学生，其实还隐隐约约记得一年前刚进实验室的时候刘知远的一句“没想到这么快八字班也要造机了啊”。现在想来，九字班这个词语从原先的代指新生，渐渐地变成了代指一群大三老油条，而自己的一字班学弟也正在憧憬着四年的本科时光，一时间竟觉得大学原来也快结束了。</p>
<p>今夜突然接到 Sakana 的一句“我还是好焦虑”，唐突地自己也开始陷入了一种窘迫的心理。自己，真的准备好去迎接之后的生活了么。</p>
<span id="more"></span>
<h1 id="学业和大三的渡劫">学业和大三的渡劫</h1>
<p>清华大学的计算机系向来会把大三上学期称为渡劫，原因是计算机核心专业课四大原理一大工程（计算机组成原理、计算机网络原理、编译原理、信号处理原理、软件工程）将会在一个学期内学习完成。虽然自己已经提前把软件工程这门课草草了结，但是作为一个对硬件和计算机系统没有感觉的人，四大原理就足以让我恐惧。已经能够预见到，将来的 Holder 或许会被造计算机、造路由器、造编译器、写 Matlab 处理信号等各种困难的作业包围，然后还要抽出时间应付掉 VLSI 和网安两门限选课的平时学习。</p>
<p>其实也正如一些人对我的评价所说，我不是一个害怕困难或者折磨的人，但是我在受折磨的时候会习惯性一个人顶着。我只是默默地担心着自己的心理健康情况，自己这近几个月来时不时的情绪崩溃足以让我感到害怕。</p>
<p>但实际上，我还是在安慰着自己没有问题，劝慰着自己造机造路由器会顺利，或许还会有点乐趣。也或许会安慰自己，信号处理原理全是微积分，自己微积分学得挺明白不用担心。然而即便如此，还是抵挡不住现在的焦虑和不安。</p>
<h1 id="科研的不顺和前途的迷茫">科研的不顺和前途的迷茫</h1>
<p>我大一就跑到组里去了，是一个进组挺早的人，家里人一直比较关心我这么早进组会怎么样，当时还不以为意，但现在看来还是有点不大行。过早的进组让我缺少时间去打基础而过快地投入到实际工作之中，我对人工智能的理解本身就是几乎为零，和同组的那些曾经 C++ 手搓神经网络的大神相比自然不可相提并论。想到自己每周二的组会都会想尽办法编造一个自己没认真做完事情的理由的时候，那种窘迫和尴尬又涌了上来。</p>
<p>至今还记忆犹新的一个场景就是，中期汇报的时候刘知远老师在场，到我上去汇报的时候，应该是说出了大量幼稚或者说根本不合理的想法。那个时候刘知远说了这样一句：“现在 Holder 这个样子，我们需要反思一下我们的指导方式”。</p>
<p>这种看似自责的说法实则，看得出来他们的意见。</p>
<p>或许从那以后，我投入了大量的精力弥补我的基础，我开始看人工智能相关网课，从全联接层开始看到 CNN / RNN ，再到 Encoder-decoder 或者 Transformer ，然后开始使用 HuggingFace 的 BERT 和 T5 轮子，钻研 API 设计和源码。这一定程度上牵扯了我大量本应该用于课内的时间，但收获也是不错的，我 finetune 的 BERT 模型做出了被学长们称为“ promising ”的成果。</p>
<p>但是后续是无休无止的挫败，我 T5 相关的工作至今都处于停滞状态。在那段时间，我经历了第一次情绪崩溃，一时间万念俱灰，每天醒来只有想睡回去的想法。那段时间，身体也一直不是很好，时不时就会有心脏疼的感觉。这种情况下的我，选择了实质上的彻底放弃，虽然一直没有和带我的学长提出我要退出。</p>
<p>现在我也不想继续学习人工智能了，每每看到那些曾经熟悉且能熟练运用的数学公式、轮子、模型，只会让我想起那段折磨至极的时光。但大三上学期的我，早就已经浪费了一年的时光，现在的 Holder 的后路究竟如何，完全还是未知的，我该如何面临毕业，也还是未知的。</p>
<h1 id="或许还是有些好消息的">或许还是有些好消息的</h1>
<p>稍微能够宽慰我的，就是我现在过得还不错。至少我身边的一切，我的学业成绩、我的感情、我的朋友们、我的家人们都处于稳定的状态上，除了我自己的出路，其余暂且不需要我过多担心。</p>
<p>这已经足够了，如果不去太担忧未来的不确定，活在当下自然是自由而快乐的。中厅的麻将还能用，新笔记本上还有若干没有玩的游戏， Sakana 还在身边，我还是有一群能聊得来的朋友，这一切的一切，暂且能够让我不再过分担忧今后。</p>
<h1 id="holder-的一些自述">Holder 的一些自述</h1>
<p>在别人眼中，特别是我高中的老师眼中，我是一个特别会规划的人。然而实际上， Holder 永远是一个走到哪里算哪里的人，只不过总是喜欢回忆，总是喜欢和过去的自己斤斤计较，懊恼于一时的失误。</p>
<p>Holder 是一个喜欢沉浸在回忆中的人，我对过去的记忆可能过于清晰。我的一个习惯性动作是，无聊的时候将记忆中的场景构建出来，比如说尝试构建出：</p>
<blockquote class="blockquote-center">
<p>2018 年的 8 月份，在高中的三层小楼中， Holder 和同学们正在为升入高三做准备。除去我们升高三的理科实验班同学，其他人早已放假。那座小楼已经老旧不堪，空调毫无用处，电风扇没有力气。外面是炽热的阳光和扭曲的蝉鸣。</p>
<p>Holder 趁着下课偷偷跑出小楼，听着下课铃在早已空荡的学校中回响。</p>

</blockquote>
<p>我或许会把这个场景构建得和刚经历差不多，然后自己沉浸在这个场景里回忆当时自己的所思所想。这个习惯来源于初中睡午觉，当时为了让自己快速入睡，就会使用这种方法——在脑海中完全重建回忆的场景，这种方法消耗脑力很多，有的时候没有构建完成就慢慢睡着了。</p>
<p>这个习惯一般会让我很难忘记一些事情，但是坏处就是：</p>
<blockquote class="blockquote-center">
<p>我忘不掉一些应该忘却的事情。</p>

</blockquote>
<p>所以至今我的思维包袱是很重的，回忆构建的数据库足够庞大，能够支撑我思维的快速切换跳转和联想。但是一旦联想到一些本应该忘却的场景，比如说曾经的尴尬场面、自己伤害别人的行为，那 Holder 可能就会沉溺在这里，然后一遍一遍鞭尸自己。</p>
<p>这还是挺折磨的，这让我很难聚焦于当下应该做的事。</p>
<h1 id="所以说">所以说？</h1>
<p>这些文字其实没有任何意义，可能明天起来就会觉得幼稚和不成熟，但是确实是现在困困的 Holder 想要记录下来的。</p>
<p>Holder 就要成为大三的学生了，在此之前， 12 号先要去北大吃一顿烤串，这足以让我暂且安静地睡去。</p>
<p>晚安。</p>
]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
  </entry>
  <entry>
    <title>Hello world</title>
    <url>/2021/06/16/hello-world/</url>
    <content><![CDATA[<p>刚刚建立好这个地方，暂且也没什么特别想说的，不如就来玩一下 hexo 的各个语法吧。</p>
<span id="more"></span>
<p>首先玩玩代码块，自然首先试试 cpp 。</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello world!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来试一下 Python 。</p>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello world!&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>不如玩一下 JavaScript 。</p>
<figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>然后玩一下数学公式。</p>
<p>我们可以把机器学习抽象描述为以下过程，这里<span class="math inline">\(X\)</span>表示输入集合，<span class="math inline">\(Y\)</span>表示输出集合，<span class="math inline">\(L\)</span>表示损失函数，<span class="math inline">\(\boldsymbol{w}\)</span>表示模型参数，<span class="math inline">\(f_\boldsymbol{w}\)</span>表示在某一系列参数之下的模型函数。</p>
<p><span class="math display">\[
\boldsymbol{w}^*=\mathop{\arg\min}_{\boldsymbol{w} \in \Omega}\sum_{x_i \in X, y_i \in Y} L(f_\boldsymbol{w}(x_i), y_i)
\]</span></p>
<p>再来试一下它自带的一些引用块。</p>
<blockquote><p>你成功建好了自己的第一个 hexo 站点！</p>
</blockquote>
<p>hexo 文档里面还提到了一种奇怪的东西，来试一下。</p>
<blockquote class="pullquote"><p>这个东西被称为 Pull Quote 。</p>
</blockquote>
<p>似乎还有奇怪的东西。</p>
<div class="note success"><p>这个是提示成功的引用块。</p>
</div>
<p>下面是一个居中引用。</p>
<blockquote class="blockquote-center">
<p>这里我们居中一定的文本。</p>

</blockquote>
<p>这里还似乎提供了用于查询浏览器支持方法的插件。</p>
<iframe data-feature="fetch" src="https://caniuse.bitsofco.de/embed/index.html?feat=fetch&periods=current&accessible-colours=false" frameborder="0" width="100%" height="400px"></iframe>
<p>暂且玩到这里吧，目前的话想要做的一些事情包括：</p>
<ul>
<li><p>写（搬运）点有点价值的东西</p></li>
<li><p>有没有可能做一些类似于管理员才可访问的东西呢</p></li>
<li><p>搞一下评论系统、浏览计数之类的</p></li>
</ul>
<p>当然我们知道明天下午就考数电了，所以 Holder 该滚去复习了。</p>
]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
  </entry>
  <entry>
    <title>日语单词变形手册（ 2021 年）</title>
    <url>/2021/11/01/ja-0/</url>
    <content><![CDATA[<p>了解 Holder 的人都明白，我几乎没有按照任何成体系的教材学过日语，所以我对日语语法的理解的变动是很快的，甚至有时会出现整个体系的重构。</p>
<p>这个手册基本基于原先的单词变形手册。但是考虑到 Holder 这段时间又从各处获取到了一些古日语知识、日语历史和一些浅薄的语言学知识，与其在原先的手册上修订，不如重新编写。</p>
<span id="more"></span>
<h2 id="编写准则">编写准则</h2>
<p>本手册会首先介绍现代日语采用的动词、形容词、形容动词等用言的活用规则，随后会介绍若干助词和助动词的词性和活用规则，最后会讲解这些用言各种活用的应用场景。</p>
<p>本手册的编写依据是我自己对日语语法的理解，并不能作为严谨的语法教材使用。</p>
<h2 id="用言活用规则">用言活用规则</h2>
<p>日语中用言的活用一般分为七种，即：</p>
<ul>
<li><p><strong>未然形</strong>。主要用于表述未发生的形态，用言的否定和被动常常使用未然形接续相关助动词表示。</p></li>
<li><p><strong>连用形</strong>。主要用于接续其他用言，部分动词的连用形用于将动词名词化。</p></li>
<li><p><strong>终止形</strong>。一般认为是用言的基础形态，用于接续终止助词表现句子终结。</p></li>
<li><p><strong>连体形</strong>。主要用于接续体言。</p></li>
<li><p><strong>假定性</strong>。古日语中称<strong>已然形</strong>。现代日语中常用于接续表示假定的助动词。</p></li>
<li><p><strong>命令形</strong>。不接续或接续终止助词表示命令。</p></li>
<li><p><strong>意志形</strong>。主要用于表达意志。</p></li>
</ul>
<div class="note info"><p>意志形是现代日语新产生的一种活用类型，部分语法书认为意志形也是未然形的一种。</p>
</div>
<h3 id="动词活用规则">动词活用规则</h3>
<p>现代日语的动词按照活用规则的不同分类为：</p>
<ul>
<li><p><strong>五段动词</strong>。形式为词干加上某一个ウ段假名构成，现代日语中合法的五段动词词尾有「く、ぐ、う、つ、る、ぶ、む、ぬ、す」，比如「書く、読む、話す」。</p></li>
<li><p><strong>一段动词</strong>。形式一般为一个イ段假名或者エ段假名结尾的词干加上「る」构成，比如「食べる、教える、起きる」。有一些细化为<strong>上一段动词</strong>和<strong>下一段动词</strong>的说法，这里可以简单理解为以イ段假名接续的是上一段动词，以エ段假名接续的是下一段动词。</p></li>
<li><p><strong>サ变动词</strong>。形式为「する」或者某一个词干加上「する」，同时也有一些以「ずる」结尾的动词也是サ变动词。比如「する、勉強する、散歩する、感ずる、禁ずる」。</p></li>
<li><p><strong>カ变动词</strong>。只有「来る」是カ变动词。</p></li>
</ul>
<div class="note info"><p>现代日语中，动词「得る（うる）」被归类为一段动词，但在实际使用中，可能出现其在古日语中的二段动词活用规则。</p>
</div>
<p>下面将给出动词六种活用的变形规则。这里额外说明，动词的连用形分成两类，即第一连用形和第二连用形。动词的第二连用形是第一连用形接续某些特殊助动词时发生音便产生的。此外，还有部分动词是不规则的，会在表后的注释中给出。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">動詞類型</th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">第一連用形</th>
<th style="text-align: center;">第二連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">仮定形</th>
<th style="text-align: center;">命令形</th>
<th style="text-align: center;">意志形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">五段動詞「か行」</td>
<td style="text-align: center;">書く</td>
<td style="text-align: center;">書か</td>
<td style="text-align: center;">書き</td>
<td style="text-align: center;">書い</td>
<td style="text-align: center;">書く</td>
<td style="text-align: center;">書け</td>
<td style="text-align: center;">書け</td>
<td style="text-align: center;">書こ</td>
</tr>
<tr class="even">
<td style="text-align: center;">五段動詞「が行」</td>
<td style="text-align: center;">泳ぐ</td>
<td style="text-align: center;">泳が</td>
<td style="text-align: center;">泳ぎ</td>
<td style="text-align: center;">泳い</td>
<td style="text-align: center;">泳ぐ</td>
<td style="text-align: center;">泳げ</td>
<td style="text-align: center;">泳げ</td>
<td style="text-align: center;">泳ご</td>
</tr>
<tr class="odd">
<td style="text-align: center;">五段動詞「ば行」</td>
<td style="text-align: center;">飛ぶ</td>
<td style="text-align: center;">飛ば</td>
<td style="text-align: center;">飛び</td>
<td style="text-align: center;">飛ん</td>
<td style="text-align: center;">飛ぶ</td>
<td style="text-align: center;">飛べ</td>
<td style="text-align: center;">飛べ</td>
<td style="text-align: center;">飛ぼ</td>
</tr>
<tr class="even">
<td style="text-align: center;">五段動詞「ま行」</td>
<td style="text-align: center;">読む</td>
<td style="text-align: center;">読ま</td>
<td style="text-align: center;">読み</td>
<td style="text-align: center;">読ん</td>
<td style="text-align: center;">読む</td>
<td style="text-align: center;">読め</td>
<td style="text-align: center;">読め</td>
<td style="text-align: center;">読も</td>
</tr>
<tr class="odd">
<td style="text-align: center;">五段動詞「な行」</td>
<td style="text-align: center;">死ぬ</td>
<td style="text-align: center;">死な</td>
<td style="text-align: center;">死に</td>
<td style="text-align: center;">死ん</td>
<td style="text-align: center;">死ぬ</td>
<td style="text-align: center;">死ね</td>
<td style="text-align: center;">死ね</td>
<td style="text-align: center;">死の</td>
</tr>
<tr class="even">
<td style="text-align: center;">五段動詞「あ行」</td>
<td style="text-align: center;">歌う</td>
<td style="text-align: center;"><strong>歌わ</strong></td>
<td style="text-align: center;">歌い</td>
<td style="text-align: center;">歌っ</td>
<td style="text-align: center;">歌う</td>
<td style="text-align: center;">歌え</td>
<td style="text-align: center;">歌え</td>
<td style="text-align: center;">歌お</td>
</tr>
<tr class="odd">
<td style="text-align: center;">五段動詞「た行」</td>
<td style="text-align: center;">立つ</td>
<td style="text-align: center;">立た</td>
<td style="text-align: center;">立ち</td>
<td style="text-align: center;">立っ</td>
<td style="text-align: center;">立つ</td>
<td style="text-align: center;">立て</td>
<td style="text-align: center;">立て</td>
<td style="text-align: center;">立と</td>
</tr>
<tr class="even">
<td style="text-align: center;">五段動詞「ら行」</td>
<td style="text-align: center;">降る</td>
<td style="text-align: center;">降ら</td>
<td style="text-align: center;">降り</td>
<td style="text-align: center;">降っ</td>
<td style="text-align: center;">降る</td>
<td style="text-align: center;">降れ</td>
<td style="text-align: center;">降れ</td>
<td style="text-align: center;">降ろ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">五段動詞「さ行」</td>
<td style="text-align: center;">話す</td>
<td style="text-align: center;">話さ</td>
<td style="text-align: center;">話し</td>
<td style="text-align: center;">話し</td>
<td style="text-align: center;">話す</td>
<td style="text-align: center;">話せ</td>
<td style="text-align: center;">話せ</td>
<td style="text-align: center;">話そ</td>
</tr>
<tr class="even">
<td style="text-align: center;">上一段動詞</td>
<td style="text-align: center;">起きる</td>
<td style="text-align: center;">起き</td>
<td style="text-align: center;">起き</td>
<td style="text-align: center;">起き</td>
<td style="text-align: center;">起きる</td>
<td style="text-align: center;">起きれ</td>
<td style="text-align: center;">起きろ</td>
<td style="text-align: center;">起きよ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">下一段動詞</td>
<td style="text-align: center;">教える</td>
<td style="text-align: center;">教え</td>
<td style="text-align: center;">教え</td>
<td style="text-align: center;">教え</td>
<td style="text-align: center;">教える</td>
<td style="text-align: center;">教えれ</td>
<td style="text-align: center;">教えろ</td>
<td style="text-align: center;">教えよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">サ変動詞</td>
<td style="text-align: center;">する</td>
<td style="text-align: center;">し／せ</td>
<td style="text-align: center;">し</td>
<td style="text-align: center;">し</td>
<td style="text-align: center;">する</td>
<td style="text-align: center;">すれ</td>
<td style="text-align: center;">しろ／せよ</td>
<td style="text-align: center;">しよ</td>
</tr>
<tr class="odd">
<td style="text-align: center;">カ変動詞</td>
<td style="text-align: center;">くる</td>
<td style="text-align: center;">こ</td>
<td style="text-align: center;">き</td>
<td style="text-align: center;">き</td>
<td style="text-align: center;">くる</td>
<td style="text-align: center;">くれ</td>
<td style="text-align: center;">こい</td>
<td style="text-align: center;">こよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">下二段動詞</td>
<td style="text-align: center;">う</td>
<td style="text-align: center;">え</td>
<td style="text-align: center;">え</td>
<td style="text-align: center;">え</td>
<td style="text-align: center;">うる</td>
<td style="text-align: center;">うれ</td>
<td style="text-align: center;">えよ</td>
<td style="text-align: center;">×</td>
</tr>
</tbody>
</table>
<p>上述规则的例外包括：</p>
<ul>
<li>五段动词「行く」的第二连用形发生促音便而非イ音变。</li>
</ul>
<div class="note info no-icon"><p>横浜に<strong>行っ</strong>たことがある。</p>
</div>
<ul>
<li>五段动词「問う、乞う」的第二连用形发生罕见的ウ音便而非促音变。</li>
</ul>
<div class="note info no-icon"><p>この大事な件，ぜひ<strong>問う</strong>てください。</p>
</div>
<ul>
<li>一段动词「くれる」的命令形为「くれ」而非「くれろ」。</li>
</ul>
<div class="note info no-icon"><p>あの新聞を取って<strong>くれ</strong>。</p>
</div>
<ul>
<li>五大敬语动词「いらっしゃる、くださる、なさる、おっしゃる、ござる」为五段动词，但是其第一连用形接续助动词「ます」的时候词尾变为「い」而非「り」。</li>
</ul>
<div class="note info no-icon"><p>嫌だから近づかないで<strong>ください</strong>ませんか？</p>
</div>
<p>但是这些动词的第一连用形在其他场景下词尾依然为「り」。</p>
<div class="note info no-icon"><p>先生はそのように<strong>おっしゃり</strong>たかったようですが，結局口に出されなかったです。</p>
</div>
<p>并且除去「ござる」之外的四个动词的命令形词尾为「い」而非「れ」。</p>
<div class="note info no-icon"><p>鉛筆一本を<strong>ください</strong>。</p>
<p>なんでも<strong>ござれ</strong>。</p>
</div>
<ul>
<li>口语中允许以「する」结尾的サ变动词按照类似五段动词的方式活用，如下表所示。</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">動詞類型</th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">第一連用形</th>
<th style="text-align: center;">第二連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">仮定形</th>
<th style="text-align: center;">命令形</th>
<th style="text-align: center;">意志形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">サ変動詞「規則」</td>
<td style="text-align: center;">愛する</td>
<td style="text-align: center;">愛し／愛せ</td>
<td style="text-align: center;">愛し</td>
<td style="text-align: center;">愛し</td>
<td style="text-align: center;">愛する</td>
<td style="text-align: center;">愛すれ</td>
<td style="text-align: center;">愛しろ／愛せよ</td>
<td style="text-align: center;">愛しよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">サ変動詞「五段」</td>
<td style="text-align: center;">愛する</td>
<td style="text-align: center;"><strong>愛さ</strong></td>
<td style="text-align: center;">愛し</td>
<td style="text-align: center;">愛し</td>
<td style="text-align: center;"><strong>愛す</strong></td>
<td style="text-align: center;"><strong>愛せ</strong></td>
<td style="text-align: center;"><strong>愛せ</strong></td>
<td style="text-align: center;">×</td>
</tr>
</tbody>
</table>
<p>而以「ずる」结尾的サ变动词可以按照类似一段动词的方式活用，如下表所示。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">動詞類型</th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">第一連用形</th>
<th style="text-align: center;">第二連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">仮定形</th>
<th style="text-align: center;">命令形</th>
<th style="text-align: center;">意志形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">サ変動詞「規則」</td>
<td style="text-align: center;">信ずる</td>
<td style="text-align: center;">信じ／信ぜ</td>
<td style="text-align: center;">信じ</td>
<td style="text-align: center;">信じ</td>
<td style="text-align: center;">信ずる</td>
<td style="text-align: center;">信ずれ</td>
<td style="text-align: center;">信じろ／信ぜよ</td>
<td style="text-align: center;">信じよ</td>
</tr>
<tr class="even">
<td style="text-align: center;">サ変動詞「一段」</td>
<td style="text-align: center;">信ずる</td>
<td style="text-align: center;"><strong>信じ</strong></td>
<td style="text-align: center;">信じ</td>
<td style="text-align: center;">信じ</td>
<td style="text-align: center;"><strong>信じる</strong></td>
<td style="text-align: center;"><strong>信じれ</strong></td>
<td style="text-align: center;"><strong>信じろ</strong></td>
<td style="text-align: center;">信じよ</td>
</tr>
</tbody>
</table>
<ul>
<li>サ变动词有两种未然形和两种命令形。其两种命令形不具有差别，但两种未然形能够接续的助动词有差别。比如说接续「ざる」的时候使用「せ」结尾的未然形，而接续「ない」的时候使用「し」结尾的未然形。</li>
</ul>
<div class="note info no-icon"><p>そんなことを<strong>し</strong>ないでください。</p>
<p>すでに騙されたことを気づいた，通報<strong>せ</strong>ざるを得ないんだ。</p>
</div>
<h3 id="形容词活用规则">形容词活用规则</h3>
<p>现代日语的形容词缺少命令形和意志形，这两种活用具有其他的替代表达。形容词依然具有两种连用形，其区别在于接续的助动词的不同。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">類型</th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">第一連用形</th>
<th style="text-align: center;">第二連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">仮定形</th>
<th style="text-align: center;">命令形</th>
<th style="text-align: center;">意志形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">形容詞</td>
<td style="text-align: center;">高い</td>
<td style="text-align: center;">高かろ</td>
<td style="text-align: center;">高く</td>
<td style="text-align: center;">高かっ</td>
<td style="text-align: center;">高い／高き</td>
<td style="text-align: center;">高け</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
</tbody>
</table>
<p>形容词的命令形一般可以用第一连用形接续动词命令形来完成。</p>
<div class="note info no-icon"><p>もう遅刻から，<strong>はやく</strong>しろう。</p>
</div>
<p>而意志形可以使用助动词「です」的活用表达。</p>
<div class="note info no-icon"><p>この服はデザインが良くて値段が安い，買って<strong>いい</strong>でしょう？</p>
</div>
<p>现代日语中仅有一个不规则形容词，即「いい」。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">類型</th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">第一連用形</th>
<th style="text-align: center;">第二連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">仮定形</th>
<th style="text-align: center;">命令形</th>
<th style="text-align: center;">意志形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">形容詞「特別」</td>
<td style="text-align: center;">いい</td>
<td style="text-align: center;">よかろ</td>
<td style="text-align: center;">よく</td>
<td style="text-align: center;">よかっ</td>
<td style="text-align: center;">いい</td>
<td style="text-align: center;">よけ</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
</tbody>
</table>
<h3 id="形容动词活用规则">形容动词活用规则</h3>
<p>现代日语的形容动词缺少命令形和意志形，这两种活用具有其他的替代表达。另外，形容动词有三种连用形，用于不同的场景。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">類型</th>
<th style="text-align: center;">終止形</th>
<th style="text-align: center;">未然形</th>
<th style="text-align: center;">第一連用形</th>
<th style="text-align: center;">第二連用形</th>
<th style="text-align: center;">第三連用形</th>
<th style="text-align: center;">連体形</th>
<th style="text-align: center;">仮定形</th>
<th style="text-align: center;">命令形</th>
<th style="text-align: center;">意志形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">形容動詞</td>
<td style="text-align: center;">静かだ</td>
<td style="text-align: center;">静かだろ</td>
<td style="text-align: center;">静かで</td>
<td style="text-align: center;">静かだっ</td>
<td style="text-align: center;">静かに</td>
<td style="text-align: center;">静かな</td>
<td style="text-align: center;">静かなら</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
</tbody>
</table>
<p>形容动词还有一种特殊的终止形，即「静かです」。这并不是严格的形容动词终止形，因为其中包含了助动词「です」，该助动词还可以继续活用表达更多的含义。可以理解为形容动词的某一种终止形必须借助给定的助动词完成，但是后续在这个助动词上的活用并不是形容动词的活用。</p>
<p>形容动词命令形的替代表达类似形容词，即连用形接续动词的命令形。</p>
<div class="note info no-icon"><p>うるさ過ぎて，<strong>静かに</strong>しろう。</p>
</div>
<p>形容动词意志形的替代表达有两种，一种类似于形容词，即使用助动词「です」的活用表达，一种是使用未然形。</p>
<div class="note info no-icon"><p>この街は<strong>にぎやか</strong>でしょう。</p>
<p>この街は<strong>にぎやかだろ</strong>う。</p>
</div>
]]></content>
      <categories>
        <category>日语</category>
      </categories>
  </entry>
  <entry>
    <title>日语单词变形手册</title>
    <url>/2021/06/18/ja-1/</url>
    <content><![CDATA[<p>这是一个相当长的文档，几乎可以说记录了我对日语单词变形能想到的一切。即使日语有的时候和中文很相似，但是它作为黏着语还是让它的语法成为了汉语母语者学习的巨大障碍。</p>
<p>这个文档随时更新，欢迎大家关注。</p>
<span id="more"></span>
<p>首先说一下这个文档整理的原则。由于日语的词汇可以很灵活地变形，比如「書く」先变成第一连用形后接续「たい」形成类似形容词的「書きたい」，之后再按照形容词过去否定的规则变为「書きたくなかった」后，在按照连体形规则接上助动词「ので」变成「書きたくなかったので」。在这样的背景下，本文档不可能穷尽所有的变形以及这种变形的所有应用方式，不过本文档会这样表述：“这样变形之后，词汇将类似于形容词”。这样的话后续进行第二次变形的时候就可以在形容词栏目之下进行寻找。</p>
<h1 id="日语动词的变形">日语动词的变形</h1>
<p>在介绍变形之前，我们要首先介绍日语动词的分类。日语动词按照活用类型可以分为四类：</p>
<ul>
<li>五段动词</li>
</ul>
<p>形式为词干加上某一个ウ段假名构成，比如「書く、読む、話す」。</p>
<ul>
<li>一段动词</li>
</ul>
<p>形式一般为一个イ段假名或者エ段假名结尾的词干加上「る」构成，比如「食べる、教える、起きる」。</p>
<p>有一些细化为上一段动词和下一段动词的说法，这里可以简单理解为以イ段假名接续的是上一段动词，以エ段假名接续的是下一段动词。</p>
<ul>
<li>サ变动词</li>
</ul>
<p>形式为「する」或者某一个词干加上「する」，同时也有一些以「ずる」结尾的动词也是サ变动词。比如「する、勉強する、散歩する、感ずる、禁ずる」。</p>
<ul>
<li>カ变动词</li>
</ul>
<p>只有「来る」是カ变动词。</p>
<h2 id="原形辞书形连体形">原形/辞书形/连体形</h2>
<p>这种形式就是字典上表示动词的形式，所以称为“原形”或者“辞书形”。其用途也是较为多的。</p>
<h3 id="用于终结一句话">用于终结一句话</h3>
<p>动词原形可以直接用于终结一个句子，提示动作：</p>
<div class="note info no-icon"><p>今朝，朝ごはんを<strong>食べる</strong>。 そこで<strong>立つ</strong>。</p>
</div>
<p>但是用原形终结一句话有的时候会给人一种语气直接了当的感觉，现实对话之中也较少使用原形直接终结句子。</p>
<h3 id="用于修饰体言">用于修饰体言</h3>
<p>实际上，动词原形同时也是连体形。连体形顾名思义是接续体言的，其用途就是具体修饰一个名词具有的性质：</p>
<div class="note info no-icon"><p>明日の会議に<strong>使う書類</strong>。 <strong>勉強する時</strong>に。</p>
</div>
<p>这个可以说是相当常用的一种用法了，不过这里要介绍几个东西，也就是<strong>形式体言</strong>，这种体言没有实际含义，但是可以辅助作为句子成分。</p>
<h4 id="形式体言事ことの">形式体言：事「こと」／の</h4>
<p>这是相当常见的形式体言，其汉字表示为「事」，常常用来接在连体后表达一种抽象的概念，常常构成类似「ことがある」「ことになる」「ことにする」「と言うことだ」这样的短语存在。</p>
<p>「の」也是相当常见的形式体言，但显然比较“轻量级”。</p>
<p>一般情况下，只是单纯完成动词名词化的时候，这两个形式体言是可以互换的：</p>
<div class="note info no-icon"><p>日本語を<strong>勉強すること</strong>は楽しいです。 日本語を<strong>勉強するの</strong>は楽しいです。</p>
</div>
<p>不过这两者之间存在一些小区别，这里首先说一下一般用「の」的情况。比如说如果名词化的动词是「みる」「聞こえる」等表示感知的动词的宾语的时候，或者比如说名词化的动词比较具像化的时候。</p>
<div class="note info no-icon"><p>あいつが本を<strong>読むの</strong>を聞こえます。 山田さんが<strong>来るの</strong>を待っています。</p>
</div>
<p>常常用「こと」的情况可能是接续的动词是「言う」「話す」「考える」「決める」等发言动词或决定性动词，也可以是直接接续「です」「だ」等动词，或者是构成了常用短语：</p>
<div class="note info no-icon"><p>アメリカに<strong>留学すること</strong>を考えている。 日本語を<strong>勉強し続くこと</strong>を決めました。 団長の仕事は団員を<strong>守ること</strong>だ。 今日からタバコを<strong>止めること</strong>にしました。</p>
</div>
<p>额外说明一点，有的时候「のです／のだ」也可以使用，但是在口语之中常常简化为「んです／んだ」。</p>
<p>这里可能需要进一步说明的是包含有「こと」的一些常用短语，这些短语一般已经具有了独特的含义了。</p>
<p>「ことがある」表示“这样的事件可能存在”：</p>
<div class="note info no-icon"><p>自分で料理を<strong>作ることがある</strong>。</p>
</div>
<p>「ことになる」表示“事态发展到了某一种状况，这种发展不是主观可控的”：</p>
<div class="note info no-icon"><p>学校のプールは六月一日から<strong>始まることになっ</strong>ている。</p>
</div>
<p>「ことにする」表示“下决心做什么事”：</p>
<div class="note info no-icon"><p>最後，彼はアメリカに<strong>留学することにし</strong>ました。</p>
</div>
<p>「ことには」有的时候用于表达一种强烈的情感和强调：</p>
<div class="note info no-icon"><p><strong>困「こま」ることには</strong>，今お金がないんです。</p>
</div>
<p>「ことができる」表示“有能力做到”：</p>
<div class="note info no-icon"><p>彼はこの歌を<strong>歌うことができ</strong>ます。</p>
</div>
<p>这里我们发现接续「こと」的全都是原形，但很多时候还可以使用第二连用形加「た／だ」之后接续「こと」，或者使用未然形加上「ない」之后接续「こと」，并且这些时候意思会产生一些微妙的变化。</p>
<div class="note default"><p><strong>注解：</strong>从这里开始，形式体言部分会涉及到许多不是原形进行接续的场合，但这些东西不会拆分到对应的条目（比如第二连用形加「た／だ」之后接续就不会放到第二连用形部分），这是因为形容词或者第二连用形加「た／だ」之后接续体言是相当自然的事情，故不如只设定一个条目统一管理。在第二连用形部分以及形容词部分会设置跳转提示，提示形式体言均放在此处记录。</p>
</div>
<p>「ないことには」表示“如果不...就...”：</p>
<div class="note info no-icon"><p>やって<strong>みないことには</strong>，何もわからないです。</p>
</div>
<p>这句话就可以翻译为“不试试看的话，就什么都不知道了”。</p>
<p>「たことにする」表示“知道这件事，但是主观上不想重视”的意思：</p>
<div class="note info no-icon"><p>そんな話を<strong>聞こえなかったことにし</strong>よう。</p>
</div>
<p>这句话就可以翻译为“就当作没听见这样的话吧”。</p>
<p>「たことがある」表示“曾经有过这个经验”：</p>
<div class="note info no-icon"><p>横浜へ<strong>行ったことがある</strong>よ。</p>
</div>
<p>这句话就可以翻译为“我曾去过横滨”。</p>
<h4 id="形式体言物もの">形式体言：物「もの」</h4>
<p>这种形式体言最为重要的应用就是表示“情理之中的行为”或者“真理”。补充说明一下，这里也可以使用未然形加上「ない」之后接续：</p>
<div class="note info no-icon"><p>太陽は東方から<strong>登るもの</strong>です。 そんなことを<strong>言わないもの</strong>です。</p>
</div>
<p>与「こと」类似，「もの」这个词的灵魂在于大量的短语以及固定表达，这里直接介绍。</p>
<p>「たいものだ」表示“相当强的欲望”：</p>
<div class="note info no-icon"><p>世界各地を<strong>旅行したいものだ</strong>。</p>
</div>
<p>「ものがある」表示相当强调的语气：</p>
<div class="note info no-icon"><p>あいつがやったことには，目に<strong>余るものがある</strong>。</p>
</div>
<p>「目に余る」表示“看不下去”，所以这句话就是说“那家伙所做的事根本看不下去”。</p>
<p>「たものだ」表示“对过去经历的怀念”：</p>
<div class="note info no-icon"><p>これで君とよく遊びに<strong>来たものだ</strong>。</p>
</div>
<p>「もの／もので／ものだから」这三个词应用于表达原因，其语气是一个比一个强烈。第一个含有一种轻微的因果感觉，而第三个就是相当强的因果关系：</p>
<div class="note info no-icon"><p><strong>子供というもの</strong>，仕方ないですね。 あまり天気が<strong>いいもので</strong>，どこかへ遊びに行きたくなった。 雨が<strong>酷いものだから</strong>，どうしても出掛けたくない。</p>
</div>
<p>「ものなら」表示一种假设。如果接续在表示可能的动词原形后面，就表示“如果...的话，就...”，如果接续在助动词「よう／う」后面就表示“万一...的话，就...”：</p>
<div class="note info no-icon"><p><strong>できるものなら</strong>，やってみなさい。 <strong>失敗しようものなら</strong>，大目玉を食う。</p>
</div>
<p>「大目玉を食う」表示“受到严厉训斥”。这两句话分别表示“如果能做到的话，做做试试看吧”以及“万一失败了的话，就会被骂得很惨”。</p>
<p>「ものの」表示“虽然...但是...”：</p>
<div class="note info no-icon"><p>苦しいことは<strong>苦しいものの</strong>，楽しいこともあるんだ。</p>
</div>
<p>「ものを」是一个逆接的助词，表达转折含义：</p>
<div class="note info no-icon"><p>そんな上手に<strong>歌えるものを</strong>，なぜ歌わなかったのですか？</p>
</div>
<h4 id="形式体言所ところ">形式体言：所「ところ」</h4>
<p>这个体言最基本的含义就是“地点”或者“场所”，所以也可以表示虚化的“场合”：</p>
<div class="note info no-icon"><p>お<strong>忙しいところ</strong>をおいでくださいましてありがとうございました。</p>
</div>
<p>这里「おいで」是「来ること」等的尊敬语格式，这里可以理解为“出席”。这句话直译就是“能从繁忙的事务之中抽身出席，非常感谢”，也就是“感谢您百忙之中出席”。</p>
<p>这个体言也可以被引申后用来表示“某一点”或者“某一方面”：</p>
<div class="note info no-icon"><p>あなただって足りて<strong>いないところ</strong>だらけ。 あなたの<strong>悪いところ</strong>はすぐ怒ることです。</p>
</div>
<p>同时也可以被引申为“范围”：</p>
<div class="note info no-icon"><p>私が知っているのは大体<strong>こんなところ</strong>です。</p>
</div>
<p>之后就是一些更为抽象的引申义。首先是表示程度，可以理解为“已经到了这个地步了”这样的意思：</p>
<div class="note info no-icon"><p>もう少しで車に引かれて<strong>しまうところ</strong>だった。</p>
</div>
<h4 id="形式体言訳わけ">形式体言：訳「わけ」</h4>
<h4 id="形式体言筈はず">形式体言：筈「はず」</h4>
<h4 id="形式体言為ため">形式体言：為「ため」</h4>
<h4 id="形式体言つもり">形式体言：つもり</h4>
<p>这个体言最基本的意义就是“计划、打算”。</p>
<div class="note info no-icon"><p>僕もタバコを<strong>やめるつもり</strong>だ。</p>
</div>
<p>另一方面，这个词语就可以表示主观意愿上的“估算、评价”（下述第一句），但有的时候会翻译为“自以为”（下述第二句），带有一定的贬义色彩：</p>
<div class="note info no-icon"><p><strong>君のつもり</strong>では，どれほど費用がかかるんだか？ あの人は自分が<strong>有能なつもり</strong>だが，彼の仕事ぶりに対する周囲の評価は低い。</p>
</div>
<p>另外一种是表示假设，翻译为“就当作”。但一般形成短语「たつもり」：</p>
<div class="note info no-icon"><p>先生に<strong>なったつもり</strong>で，みんなに説明しよう。</p>
</div>
<p>另外说一下这个体言的否定，「〜ないつもり」表示“不打算这么做”，「〜つもりはない」则根本上否定，表示“完全不打算”：</p>
<div class="note info no-icon"><p><strong>進学しないつもり</strong>だ。 率直的「そっちょくてき」にいう，俺は<strong>進学するつもりはない</strong>んだ。</p>
</div>
<h4 id="形式体言方ほう">形式体言：方「ほう」</h4>
<p>这个词一般被运用在比较句之中，用来形成比较的语气：</p>
<div class="note info no-icon"><p><strong>あちらの方</strong>はデザインがいいんだ。</p>
</div>
<h4 id="形式体言儘まま">形式体言：儘「まま」</h4>
<p>这个词核心意思就是“保持某一种状态不变”：</p>
<div class="note info no-icon"><p><strong>そのまま</strong>でいいでしょう？ 前に<strong>向こうまま</strong>歩いている。 自分の<strong>意のまま</strong>にいこう。</p>
</div>
<p>第一句表示“就这样下去也不错吧？”，而第二句意思为“一直向前走”，第三句意思为“随着自己的意思行动”。这三句话都蕴含着“保持一种状态不变”或者“跟随某一种状态不变”的含义。而如果表明的是“跟随自己的意见”，这个词可以酌情翻译为“任性”，并且这个时候常常带有些许贬义。比如说常见的形容动词「わがままだ」。</p>
<h4 id="形式体言通とおり">形式体言：通「とお」り</h4>
<p>这个词核心意思为“按照”或者“正如”：</p>
<div class="note info no-icon"><p><strong>教えた通り</strong>にやってみよう。 <strong>ご覧の通り</strong>なんでもない。</p>
</div>
<p>这两句话的意思就是“按着刚刚教的做做试试看吧”以及“正如您所见，什么都没有”。</p>
<h4 id="形式体言上うえ">形式体言：上「うえ」</h4>
<p>首先这个词有个非常直观的意思，就是“...上”，用来表示一个方面：</p>
<div class="note info no-icon"><p><strong>仕事の上</strong>で問題はない。</p>
</div>
<p>这句话很简单的翻译为“工作上没有问题”。</p>
<p>另外，这个词还可以表示“添加评注”，也就是添加一段对某个人或物性质的描述：</p>
<div class="note info no-icon"><p>このカメラはよく<strong>映る上</strong>に，値段がやすいです。</p>
</div>
<p>这句话直接翻译的话就是“这个照相机除了拍照片很好，还很便宜”。</p>
<p>另外，如果用「た」接续，就表明“在...之后再...”：</p>
<div class="note info no-icon"><p>お目に<strong>かかった上</strong>で決めましょう。</p>
</div>
<p>这里「お目にかかる」表示“会面”，所以这句话意思为“见面之后再决定吧”。</p>
<p>还有一种意思表示“既然...那么...”：</p>
<div class="note info no-icon"><p>事実はそうで<strong>あった上</strong>で，仕方はないでしょう？</p>
</div>
<h4 id="形式体言うち">形式体言：うち</h4>
<p>这个词的核心意思就是“范围”：</p>
<div class="note info no-icon"><p><strong>三人のうち</strong>で誰が一番年長ですか？</p>
</div>
<p>这句话可以简单翻译为“这三个人（的范围）里面，谁年龄最大？”</p>
<h4 id="形式体言元もと">形式体言：元「もと」</h4>
<p>这个词核心的意思就是“范围”，进而引申出“在...之下”的含义：</p>
<div class="note info no-icon"><p><strong>親のもと</strong>を離れる。 先生の<strong>指導のもと</strong>で研究を続ける。</p>
</div>
<p>第一句话直接翻译就是“离开了父母的范围”，意思就是“与父母分离”。第二句话使用了引申义，意思是“在老师的指导之下，研究得以继续”。</p>
<h4 id="形式体言限かぎり">形式体言：限「かぎ」り</h4>
<p>这个词最简单的含义就是表示“极限”。但是作为形式体言，其可以构成“只要...就...”的句式：</p>
<div class="note info no-icon"><p>このうるさい音が<strong>続く限り</strong>，私は眠れない。</p>
</div>
<p>这句话就表示“只要那烦人的声音还在响，我就睡不着”。</p>
<p>当然，这个词如果接续在否定的「ない」后面，就表达“除非...就不...”，这实际上就是上面的“只要...就...”的否定：</p>
<div class="note info no-icon"><p>病気が<strong>ない限り</strong>学校を休まない。</p>
</div>
<p>这句话就可以翻译为“只要没生病就不能请假”。</p>
<h4 id="形式体言代かわりに">形式体言：代「か」わりに</h4>
<p>这个词可以作为实际含义的词，表示“代替”：</p>
<div class="note info no-icon"><p>私の<strong>母の代わりに</strong>，ご挨拶します。</p>
</div>
<p>但是其作为形式体言，有一个作用就是构成“虽然...但也...”的句式：</p>
<div class="note info no-icon"><p>スポーツがあまり上手では<strong>ない代わりに</strong>，大病もしたことがない。</p>
</div>
<p>这句话就被翻译为“虽然我运动不是很好，但是也从未生过大病”。</p>
<p>同时，这个形式体言也可以表示两者之间的一个交换条件：</p>
<div class="note info no-icon"><p>英語を教えて<strong>もらう代わりに</strong>，日本語を教えてあげます。</p>
</div>
<p>这句话可以形象翻译为“你来教我英语，作为交换，我教你日语”，实际上就是表明两个行为是一种交换的行为。</p>
<h4 id="形式体言次第しだい">形式体言：次第「しだい」</h4>
<p>这个词本质上也是一个实质体言，意思为“次序”，但是其作为形式体言有两种意思。如果接在连用形后面，就表示“全凭，全靠”的意思，如果接在第一连用形后面，就表示“一...就...”的意思：</p>
<div class="note info no-icon"><p>全ては君の<strong>決心の次第</strong>です。 <strong>出来次第</strong>，お届けいたします。</p>
</div>
<p>这里「出来次第」可能一下子看不出来，实际上就是动词「できる」的第一连用形「出来」加上「次第」的形式。这两句话意为“这全靠你的决心”以及“一旦做出来就给您送过去”。</p>
<h4 id="形式体言癖くせに">形式体言：癖「くせ」に</h4>
<p>这个词附加在动词上往往表达一种不满的、责备的语气，一般含有“明明怎么样，却怎么样”的感觉：</p>
<div class="note info no-icon"><p>お前は知って<strong>いるくせに</strong>，なんで私に教えてくれなかったの？ あいつはバスケットボールが<strong>下手なくせに</strong>，選手になりたいなんて夢を見ている。</p>
</div>
<p>这两句话可以根据语气分别翻译为“你明明知道，为什么不告诉我”以及“他篮球明明打得不好，却还想做当运动员的梦”。</p>
<h3 id="接续助词辅助表意">接续助词辅助表意</h3>
<p>另外，还可以接续一些助词，比如说表达客观原因的「ので」。</p>
<div class="note info no-icon"><p>横浜へ行ったことがあるよ。</p>
</div>
<h2 id="第一连用形">第一连用形</h2>
<p>首先我们给出第一连用形的变形规则：</p>
<ul>
<li><p>五段动词将词尾ウ段假名改为イ段假名</p></li>
<li><p>一段动词将词尾「る」删去</p></li>
<li><p>サ变动词删去词尾「する／ずる」加上「し／じ」</p></li>
<li><p>カ变动词变为「き」</p></li>
</ul>
<p>这里直接给出变形例子：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">動詞類型</th>
<th style="text-align: center;">原形／辞書形</th>
<th style="text-align: center;">語幹／第一連用形</th>
<th style="text-align: center;">第一連用形＋ます</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">五段動詞「く」</td>
<td style="text-align: center;">書く</td>
<td style="text-align: center;">書き</td>
<td style="text-align: center;">書きます</td>
</tr>
<tr class="even">
<td style="text-align: center;">五段動詞「ぐ」</td>
<td style="text-align: center;">泳ぐ</td>
<td style="text-align: center;">泳ぎ</td>
<td style="text-align: center;">泳ぎます</td>
</tr>
<tr class="odd">
<td style="text-align: center;">五段動詞「す」</td>
<td style="text-align: center;">話す</td>
<td style="text-align: center;">話し</td>
<td style="text-align: center;">話します</td>
</tr>
<tr class="even">
<td style="text-align: center;">五段動詞「つ」</td>
<td style="text-align: center;">立つ</td>
<td style="text-align: center;">立ち</td>
<td style="text-align: center;">立ちます</td>
</tr>
<tr class="odd">
<td style="text-align: center;">五段動詞「ぬ」</td>
<td style="text-align: center;">死ぬ</td>
<td style="text-align: center;">死に</td>
<td style="text-align: center;">死にます</td>
</tr>
<tr class="even">
<td style="text-align: center;">五段動詞「ぶ」</td>
<td style="text-align: center;">飛ぶ</td>
<td style="text-align: center;">飛び</td>
<td style="text-align: center;">飛びます</td>
</tr>
<tr class="odd">
<td style="text-align: center;">五段動詞「む」</td>
<td style="text-align: center;">読む</td>
<td style="text-align: center;">読み</td>
<td style="text-align: center;">読みます</td>
</tr>
<tr class="even">
<td style="text-align: center;">五段動詞「る」</td>
<td style="text-align: center;">降る</td>
<td style="text-align: center;">降り</td>
<td style="text-align: center;">降ります</td>
</tr>
<tr class="odd">
<td style="text-align: center;">五段動詞「う」</td>
<td style="text-align: center;">歌う</td>
<td style="text-align: center;">歌い</td>
<td style="text-align: center;">歌います</td>
</tr>
<tr class="even">
<td style="text-align: center;">上一段動詞</td>
<td style="text-align: center;">起きる</td>
<td style="text-align: center;">起き</td>
<td style="text-align: center;">起きます</td>
</tr>
<tr class="odd">
<td style="text-align: center;">下一段動詞</td>
<td style="text-align: center;">教える</td>
<td style="text-align: center;">教え</td>
<td style="text-align: center;">教えます</td>
</tr>
<tr class="even">
<td style="text-align: center;">サ変動詞「基本」</td>
<td style="text-align: center;">する</td>
<td style="text-align: center;">し</td>
<td style="text-align: center;">します</td>
</tr>
<tr class="odd">
<td style="text-align: center;">サ変動詞「語幹ある」</td>
<td style="text-align: center;">勉強する</td>
<td style="text-align: center;">勉強し</td>
<td style="text-align: center;">勉強します</td>
</tr>
<tr class="even">
<td style="text-align: center;">サ変動詞「濁点ある」</td>
<td style="text-align: center;">感ずる</td>
<td style="text-align: center;">感じ</td>
<td style="text-align: center;">感じます</td>
</tr>
<tr class="odd">
<td style="text-align: center;">カ変動詞</td>
<td style="text-align: center;">くる</td>
<td style="text-align: center;">き</td>
<td style="text-align: center;">きます</td>
</tr>
</tbody>
</table>
<p>之后我们就可以介绍第一连用形的用途了。</p>
<h3 id="接续助词辅助表意-1">接续助词辅助表意</h3>
<h4 id="助动词ます">助动词ます</h4>
<p>「ます」在一定程度上是一种很常用的助动词，常常用来表示一种稍稍表敬意的语气。</p>
<p>「ます」在一定意义上也具有各种的变形来表达各种含义（毕竟原本的动词为了接续「ます」只能变为第一连用形，从而就不能再变形来表达含义了）。</p>
<ul>
<li>基本形「ます」</li>
</ul>
<p>最为基本的用法，不做介绍。</p>
<ul>
<li>未然形「ませ」</li>
</ul>
<p>接续「ん／ぬ」表示否定。不过要注意，接续「ぬ」已经是比较古老的用法，现今基本不使用。</p>
<div class="note info no-icon"><p>私はお茶を飲み<strong>ません</strong>。 そんなことを知り<strong>ませぬ</strong>。</p>
</div>
<ul>
<li>连用形「まし」</li>
</ul>
<p>接续「て」表示停顿或者接续「た」表达过去。</p>
<div class="note info no-icon"><p>昨日は新聞を読み<strong>ました</strong>。 昨日は雑誌を読み<strong>ませんでした</strong>。 初め<strong>まして</strong>。</p>
</div>
<p>这里稍微说说「ませんでした」这样的形式是怎么样构成的。因为日语构建过去否定都是先否定再过去，在形容词上面就已经有较多体现：</p>
<p>暑い　<span class="math inline">\(\Rightarrow\)</span>　暑くない　<span class="math inline">\(\Rightarrow\)</span>　暑くなかった</p>
<p>那么我们对「ます」的否定形式「ません」该如何处理呢？它不是用言，我们必须用助动词修饰之后才能进行过去化：</p>
<p>ません　<span class="math inline">\(\Rightarrow\)</span>　ませんです　<span class="math inline">\(\Rightarrow\)</span>　ませんでした</p>
<p>这里的「ませんです」只是一个变形中间体，不具有任何语言用途，不能在实际用语中出现。</p>
<ul>
<li>终止形「ます」</li>
</ul>
<p>终结句子用，没有实际含义。</p>
<ul>
<li>推量形「ましょ」</li>
</ul>
<p>接续「う」表示劝说、意见或者推论。</p>
<div class="note info no-icon"><p>今夜，一緒に食事をし<strong>ましょう</strong>。</p>
</div>
<h4 id="助动词たいたがる">助动词たい／たがる</h4>
<p>「たい／たがる」是表达欲望的助动词，其中第一人称常用「たい」，而其他人称常用「たがる」。不过要注意的是使用「たい」之后，其行为类似于形容词，而「たがる」行为类似于动词。</p>
<div class="note info no-icon"><p>私はお菓子を<strong>食べたい</strong>です。 今何も<strong>したくない</strong>です。 昨日は買い物<strong>したかった</strong>。 昨夜は宿題を<strong>やりたくなかった</strong>。 <strong>遊びたければ</strong>，一緒にいこう。 うちの子は，いつもケーキを<strong>食べたがる</strong>のよ。</p>
</div>
<p>不过要注意的一点是，「たがる」是用来推测别人的愿望的，是蕴涵着自上而下审视的语气的。比如说上面的例句，实际上有一种“孩子爱吃蛋糕，别给吃胖了”或者“吃这么多，多费钱啊”这样的隐含负面语气，所以尽量少使用。</p>
<h4 id="助动词ながらつつ">助动词ながら／つつ</h4>
<p>「ながら」最为基本的意思是“一边”或者“同时”。如果要描述某个人一边如何一边如何，就可以用这个助词：</p>
<div class="note info no-icon"><p>山を<strong>登りながら</strong>，こう思った。</p>
</div>
<p>但是这个词有的时候会表达一种很轻微的转折，在一定程度上可以酌情表达为“但是”：</p>
<div class="note info no-icon"><p>我が国の労働者は仕事を<strong>しながら</strong>，勉強もできる。</p>
</div>
<p>这句话可以理解为“劳动者一边工作一边学习”，但是实际上如果语气适当，会表现出一种“我国劳动者会工作，但是也可以一边学习”种种带有转折含义的语气。</p>
<p>「つつ」有的时候也可以表达这种“一边”或者“同时”的含义，比如说：</p>
<div class="note info no-icon"><p>帰りのバスで外の景色を<strong>眺めつつ</strong>，明日の仕事を考えていた。</p>
</div>
<p>但是这个词似乎在更多的场合会被用来强调“言行不一”的转折含义，并且常常和主观动词「言う」「思う」「考える」「悩む」「知る」「嫌う」等连接使用，并且常常形成「つつも」的形式：</p>
<div class="note info no-icon"><p>今日は勉強しようと<strong>思いつつも</strong>，テレビを見てしまった。</p>
</div>
<p>这个助词还可以构成「つつある」的形式在口语中表示动作的持续，一定程度上类似后面要说到的「ている」形式：</p>
<div class="note info no-icon"><p>彼は今自分が<strong>死につつある</strong>ことを意識していた。</p>
</div>
<h3 id="接续辅助动词构成复合动词">接续辅助动词构成复合动词</h3>
<p>复合动词是日语中常用的一种动词，常常是动词后面接续辅助动词或者形容动词接续辅助动词构成的，前面的动词或者形容动词构成主要意思，后面的辅助动词提供补充含义。当然，也有一些复合动词演化出了较为独特的含义。这里简单举出一些例子。</p>
<ul>
<li>辅助动词「合う」</li>
</ul>
<p>这个辅助动词的含义一般是“互相”，所以经常用来表达一些双方之间互相进行的行为，比如“互相帮助”或者“互相理解”。但是有的时候这个动词也可以表达出“汇合”的感觉。这类复合动词有：</p>
<div class="note info no-icon"><p>愛し合う、巡り合う、話し合う、語り合う、助け合う、理解し合う、分かり合う</p>
</div>
<ul>
<li>辅助动词「込む」</li>
</ul>
<p>这个辅助动词的含义一般是“程度深”，所以一般用来表示前面的动词进行的较为深入。所以可以接在“申请”后面表示“申请进入”或者接在“饮用”后面表示“吞噬”等含义。这种这类复合动词有：</p>
<div class="note info no-icon"><p>申し込む、読み込む、落ち込む、飲み込む、飛び込む</p>
</div>
<ul>
<li>辅助动词「出す」</li>
</ul>
<p>这个辅助动词的含义一般是“...出来”，这样的表述在汉语里也很多，类似“说出来”或者“飞出来”等等，所以这种复合动词很好理解。这类复合动词有：</p>
<div class="note info no-icon"><p>言い出す、思い出す、呼び出す、飛び出す、逃げ出す、考え出す</p>
</div>
<ul>
<li>辅助动词「上がる／上げる」</li>
</ul>
<p>这个辅助动词的含义一般是“完成”，但是会根据前面的动词是自动词还是他动词进行区分使用。如果是自动词就使用「上がる」，如果是他动词就使用「上げる」。这类复合动词有：</p>
<div class="note info no-icon"><p>飛び上がる、打ち上げる、晴れ上がる</p>
</div>
<p>实际上复合动词接续的辅助动词绝对不限于这些，比如说「始める」「続ける」「終わる」「残す」「返す」「かける」「切る」「兼ねる」都可以作为辅助动词使用。</p>
<h3 id="接续辅助形容词构成复合形容词">接续辅助形容词构成复合形容词</h3>
<p>这里着重介绍「やすい」「にくい」这两个形容词。这两个形容词常常接续在第一连用形之后，分别表示“这个动作容易做”以及“这个动作不好做”的意思。由于不是重点，这里简单写两个例句表明用法：</p>
<div class="note info no-icon"><p>この薬は<strong>飲みやすい</strong>です。 冬の日に食べ物は悪く<strong>なりにくい</strong>です。</p>
</div>
]]></content>
      <categories>
        <category>日语</category>
      </categories>
  </entry>
  <entry>
    <title>日本高中课程《漢文》学习笔记</title>
    <url>/2021/08/16/ja-2/</url>
    <content><![CDATA[<p>这门课大致就是讲日本人是如何阅读中文文言文的。学这个纯属是觉得日语这门语言真的很有意思，借鉴中文的文字，却采用了和中文几乎完全不一样的语法。另一方面也是因为好奇中国的典籍传到日本是如何被翻译的。</p>
<p>虽然自己现代日语都还没学明白，但作为随缘学习人，不如再开新坑。</p>
<span id="more"></span>
<h1 id="基本语序">基本语序</h1>
<p>首先我们需要知道，汉语之中的语序是“主谓宾”，而日语却是“主宾谓”。</p>
<p>所以说日本人在阅读文言文的时候，第一件事就是要把各种词语的顺序调节成日本人能够用日语思维理解的样子。这个时候，日本人发明了<strong>返点（返り点）</strong>和<strong>送假名（送り仮名）</strong>，将其标注在文言文原文旁，用于辅助阅读。</p>
<h2 id="送假名">送假名</h2>
<p>日本人阅读文言文的时候，为了标记出宾语（日本一般称为“目的语”）的位置，常常在表示宾语的汉字右下侧标记「ヲ／ニ／ト」三个假名之一，这就是送假名。这三个假名也是现代日语之中相当重要的三个助词，其表明了三种不同的语法关系。比如说（按理应该使用竖排文字，但是考虑到排版问题，就使用横排文字了。角标位置相应逆时针旋转九十度）：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \text{陳康粛公善}_{\text{レ}}^{\text{クス}} \text{射}^{\text{ヲ}}。 \\
&amp; \text{項梁乃}^{\text{チ}}\text{教}^{\text{フ}}_{\text{一}}\text{籍}^{\text{ニ}}\text{兵法}^{\text{ヲ}}_{\text{二}}。　\\
\end{aligned}
\]</span></p>
<p>这里“射”“籍”以及“兵法”右上方（由于改为横排，故旋转到右上方）标注的「ヲ／ニ／ト」就是送假名了，其作用就是标注出宾语的位置。</p>
<p>除去这三个假名，还有一些送假名的目的是将汉语汉字添加上黏性词尾转化为日语词。比如说这里的“教”标注了「フ」假名，实际上代表了「教ふ」这个日语词（注意这里使用古代假名用法而非现代用法）。</p>
<h2 id="返点">返点</h2>
<p>返点指的是用于提示读者调换文字阅读顺序的提示文字，常常标记在汉字左下角（横排的时候位于右下角）。返点常用的三种为「レ点」「一二点」「上下点」，写法就是汉字左下角的「レ」假名、汉字数字「一二三」和汉字「上下」。</p>
<p>「レ点」的作用是<strong>标记此处返回一个文字</strong>，也就是说位于「レ点」两侧的汉字实际的阅读顺序是反过来的。比如说此句：</p>
<p><span class="math display">\[
\text{行}^{\text{ク}}_{\text{レ}}\text{海}^{\text{ニ}}。
\]</span></p>
<p>这里「レ点」表明“行”和“海”两个汉字的阅读顺序恰好和印刷顺序是相反的，也就是先读“海”，再读“行”。</p>
<p>如果返回汉字的数量超过一个，则使用「一二点」标记。阅读顺序是从标有「一」的位置跳转到标有「二」的位置。比如说此句：</p>
<p><span class="math display">\[
\text{思}^{\text{フ}}_{\text{二}}\text{君}^{\text{ノ}}\text{事}^{\text{ヲ}}_{\text{一}}。
\]</span></p>
<p>此时的阅读顺序是首先跳过“思”，先阅读“君”和“事”，之后跳转去阅读“思”。</p>
<p>「上下点」用于标记嵌套的跳转。在两个「一二点」嵌套的时候，为了消歧义，将外层的「一二点」变为「上下点」。比如说此句：</p>
<p><span class="math display">\[
\text{有}^{\text{リ}}_{\text{下}} \text{観}^{\text{ル}}_{\text{二}} {}^{\text{ばい}}\text{梅} {}^{\text{か}}\text{花}^{\text{ヲ}}_{\text{一}} \text{者}_{\text{上}}。
\]</span></p>
<p><strong>注解：</strong>这里在右上方（横排的时候在左上方）标注的平假名是这个汉字的注音。</p>
<p>此时的阅读顺序是从“梅花”开始，从“花”跳转到“観”，之后向下阅读到“者”，再跳转到“有”。</p>
<p>如果涉及到更为深层的跳转嵌套，可能会使用到天干地支。但对于大部分的转读，这三类就已经够用了。</p>
<hr />
<p>综合这三种返点的话，可以看这一个例句（只保留返点）：</p>
<p><span class="math display">\[
\text{無}_{\text{下}} \text{不}_{\text{レ}} \text{知}_{\text{レ}} \text{愛}_{\text{二}} \text{其} \text{親}_{\text{一}} \text{者}_{\text{上}}。
\]</span></p>
<p>这一句话首先阅读“其親”，之后根据「一二点」跳转到“愛”，遇到「レ点」则逐个倒着读“知不”，之后向下读到“者”，最后根据「上下点」读到“無”。所以最后的汉字阅读顺序是“其親愛知不者無”，当然这和真正的日语还有距离，但至少汉字顺序已经符合日语思维了，之后就是需要利用送假名填充各种助词和词尾。</p>
<h2 id="其他的一些概念">其他的一些概念</h2>
<p>首先需要介绍<strong>置字（置き字）</strong>，其含义是在转读为日语的时候不需要读出的汉字。其不会直接在文章中标出来，基本靠读者自身的文言能力来判定。比如说：</p>
<p><span class="math display">\[
\text{念} \text{莫}_{\text{下}} \text{可}_{\text{レ}} \text{使}_{\text{レ}} \text{用}_{\text{二}} \text{於} \text{秦}_{\text{一}} \text{者}_{\text{上}}。
\]</span></p>
<p>这里的“於”实际上是不会读出来的，所以说阅读顺序是“念秦用使可者莫”，并不包含汉字“於”。</p>
<p>置字常常是古汉语之中常见的一些助词，比如说“而”“於”“乎”“矣”“焉”之类的。</p>
<p>另外，有的时候「レ点」「一二点」或者「レ点」「上下点」会出现在同一个汉字的左下角，这个时候就会发生<strong>合写</strong>。这种合写形式的返点是有专门的 Unicode 字符的，但是这里无法打出来，所以直接分立写出：</p>
<p><span class="math display">\[
\text{勿}^{\text{カレ}}_{\text{下}} \text{以}^{\text{テ}}_{\text{二}} \text{悪}^{\text{ノ}} \text{小}^{\text{ナルヲ}}_{\text{一}} \text{為}^{\text{ス}}_{\text{上レ}} \text{之}^{\text{ヲ}}。
\]</span></p>
<p>这个时候「レ点」「上下点」虽然合写，但发挥各自作用。</p>
<p>此外，有些时候文言之中有部分双字或者四字熟语不能拆分理解，这些熟语的汉字之间会用短横连接，表示作为整体处理（这里由于短横渲染问题，使用左右括号标志）。比如：</p>
<p><span class="math display">\[
\text{欲}^{\text{ス}}_{\text{三}} (\text{学}_{\text{二}} \text{習}^{\text{セント}}) \text{漢} \text{文}^{\text{ヲ}}_{\text{一}}。
\]</span></p>
<h1 id="书下文">书下文</h1>
<p>书下文（書き下し文）指的是通过返点和送假名，将文言文直接转化成的，符合日语语法习惯但不一定完全通顺的文句。其转写方式是，首先通过返点调转汉字阅读顺序，最后通过送假名填入日语助词和词尾。</p>
<p>比如说这一句：</p>
<p><span class="math display">\[
\text{有}^{\text{リ}}_{\text{下}} \text{観}^{\text{ル}}_{\text{二}} {}^{\text{ばい}}\text{梅} {}^{\text{か}}\text{花}^{\text{ヲ}}_{\text{一}} \text{者}_{\text{上}}。
\]</span></p>
<p>首先通过返点得到汉字顺序为“梅花観者有”，之后在各个汉字后补上送假名之后就得到这句话的书下文：</p>
<p><span class="math display">\[
\text{梅花を観る者有り。}
\]</span></p>
<p>不过在转写书下文的时候，要注意三点：</p>
<ul>
<li><p>注意日语助词和助动词不写作汉字。</p></li>
<li><p>注意置字不写入书下文。</p></li>
<li><p>注意再读汉字的转写（具体转写方式见后续）。</p></li>
</ul>
<p>比如说这一句：</p>
<p><span class="math display">\[
\text{子} \text{曰}^{\text{ク}} \text{温}^{\text{メテ}}_{\text{レ}} \text{故}^{\text{キヲ}} \text{而} \text{知}^{\text{ラバ}}_{\text{レ}} \text{新}^{\text{シキヲ}} \text{可}^{\text{シ}}_{\text{二}} \text{以}^{\text{テ}} \text{為}^{\text{ル}}_{\text{一レ}} \text{師} \text{矣}。
\]</span></p>
<p>首先得到汉字的阅读顺序为“子曰故温新知以師為可”，这里“而”和“矣”是置字，不需要写入书下文。之后填充假名得到书下文：</p>
<p><span class="math display">\[
\text{子曰く故きを温めて新しきを知らば以て師為るべし。}
\]</span></p>
<p>这里注意，「可し（べし）」是一个助动词，不应当写为汉字。</p>
<p>常见的助词包括：</p>
<div class="note info no-icon"><p>の，か，や，より，と，かな，のみ</p>
</div>
<p>这里，「の」常写作“之”，「のみ」常写作“耳”。</p>
<p>常见的助动词包括：</p>
<div class="note info no-icon"><p>ず，しむ，る，らる，なり，べし，ごとし</p>
</div>
<p>这里，「べし」常写作“可”，「ごとし」常写作“若”，「なり」常写作“也”。</p>
<h1 id="再读汉字">再读汉字</h1>
<p>再读汉字指的就是在转写的时候需要读两次的汉字，其往往代表了日语之中的一些固定句式。再读汉字的第一次读的注音用平假名标在汉字右上角（横排的时候在左上方），第二次读的注音用平假名标在汉字左上角（横排的时候在左下方），而第二次的送假名则和返点一样在左下角（横排的时候在右下方），以表区分，这里用空格隔开。</p>
<p>另外注意，<strong>一般而言，再读汉字第一遍读的时候作实词写成汉字，而第二遍读的时候作虚词不写成汉字</strong>。比如说这样的例句：</p>
<p><span class="math display">\[
{}^{\text{まさ}}_{\text{べ}}\text{当}^{\text{ニ}}_{\text{二 シ}} \text{勉} \text{強}^{\text{ス}}_{\text{一}}。
\]</span></p>
<p>注意到再读汉字“当”读两次，这句话汉字的阅读顺序应该为“当勉强当”，第二遍读“当”的时候不写为汉字。则书下文为：</p>
<p><span class="math display">\[
\text{当に勉強すべし。}
\]</span></p>
<p>日本高中要求掌握的再读汉字包括：</p>
<div class="note info no-icon"><p>宜，当，未，猶，応，将，盍，須，且</p>
</div>
<p>这些汉字的读法为（这里平假名标注的是汉字本身的读音，片假名标注的是相应的送假名。而在「」之中标注的，则是紧接在再读汉字第二次读之前的汉字的送假名。「動詞形式」指的是紧接在再读汉字第二次读之前的动词应当采取的变形）：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">再読漢字</th>
<th style="text-align: center;">読み方</th>
<th style="text-align: center;">意味</th>
<th style="text-align: center;">動詞形式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">未</td>
<td style="text-align: center;">　いまダ〜ず　</td>
<td style="text-align: center;">まだ〜ない</td>
<td style="text-align: center;">未然形</td>
</tr>
<tr class="even">
<td style="text-align: center;">且 &amp; 将</td>
<td style="text-align: center;">　まさニ〜「ント」す　</td>
<td style="text-align: center;">これから〜しようとする</td>
<td style="text-align: center;">未然形</td>
</tr>
<tr class="odd">
<td style="text-align: center;">当 &amp; 応</td>
<td style="text-align: center;">　まさニ〜べシ　</td>
<td style="text-align: center;">当然〜すべきだ</td>
<td style="text-align: center;">終止形／ラ変連体形</td>
</tr>
<tr class="even">
<td style="text-align: center;">須</td>
<td style="text-align: center;">　すべかラク〜べシ　</td>
<td style="text-align: center;">ぜひとも〜する必要がある</td>
<td style="text-align: center;">終止形／ラ変連体形</td>
</tr>
<tr class="odd">
<td style="text-align: center;">宜</td>
<td style="text-align: center;">　よろシク〜べシ　</td>
<td style="text-align: center;">〜するのがよい</td>
<td style="text-align: center;">終止形／ラ変連体形</td>
</tr>
<tr class="even">
<td style="text-align: center;">猶</td>
<td style="text-align: center;">　なホ〜ごとシ　</td>
<td style="text-align: center;">ちょうど〜のようだ</td>
<td style="text-align: center;">名詞＋「の」／動詞連体形＋「が」</td>
</tr>
<tr class="odd">
<td style="text-align: center;">盍</td>
<td style="text-align: center;">　なんゾ〜ざル　</td>
<td style="text-align: center;">どうして〜しないのか</td>
<td style="text-align: center;">未然形</td>
</tr>
</tbody>
</table>
<h1 id="使役动词">使役动词</h1>
]]></content>
      <categories>
        <category>日语</category>
      </categories>
  </entry>
  <entry>
    <title>回忆一下我的大学</title>
    <url>/2021/06/16/look-back/</url>
    <content><![CDATA[<p>在搭好这个网站之前，我也已经上了两年大学，走过了一半的本科时光。</p>
<span id="more"></span>
<p>我总是愿意将自己的身份定位为数学竞赛失败的高考生，从初三开始学习一些基本的数竞，高中数竞奋斗两年，结果是化竞考出所有竞赛中最好成绩然后高考混进了你清计算机系。估计你也看出来了，我在学什么上面一直是迷茫的，高中纠结主攻哪一门竞赛，于是数理化三面都搞。高考出分选专业，甚至是选清北也让我着实过了一个折磨的七月初。最后，还是随着大流，进了计算机系。</p>
<p>我的大一，刚开始的时候野心很大，想着好好搞成绩然后还毅然决然选上了班长。但是大学这片地方的宽阔程度完全超越了我作为一个县高学生的想象，再加上本身就有些不敢与生人交流的个性，所以大一的时候实则还是比较畏畏缩缩的。当时的话，几乎所有课程都靠着自己单打独斗，当时不知道计算机系的 <a href="https://github.com/PKUanonym/REKCARC-TSC-UHT">CRACKER</a> ，不知道大学的考试很屑，所以第一学期下来成绩就很一般般。</p>
<p>大一上学期刚结束的我还是有点高考生的“追求”的，于是下定决心下学期认真卷绩点。这种除了绩点什么都不管的心态大概持续了半年，直到加入了 <a href="https://www.unidy.cn">xge</a> 的 <a href="https://github.com/UNIDY2002/THUInfo">THUInfo</a> 项目。或许就是从那个时候开始，才感觉大学不是像高中那样仅仅是为了成绩学习，而是有一些其他的路径的。</p>
<p>大一另外一个印象深刻的事情就是，学年末的甲团评比活动我们班的团支书居然缺席了，最后我不得不顶替他。当时离我们班展示还有不到半小时，而我还在边听着 91 班的展示边做 PPT 。这件事之后，我对社工算是很寒心，随后决定不再干社工。</p>
<p>大二的上学期过得很平凡，也没有给我留下很深刻的印象。但是这个学期，尤其是五月份，我明显感觉到自己的心态发生了很大的转变。首先就是自己突然感觉到对前三个学期的生活有种厌恶感，不想让自己继续在 GPA 主导之下生活。其次是突然重燃了对社工的一些热情，主要的缘故是跟着 xge 在科协里面参加了一些活动，比如嘉年华以及智能体决赛，在这期间也算是认识了不少人（比如大恶人安頔）。最后就是敢于正面自己对 Sakana 的一些感情了，大概这里不会太详细展开说。</p>
<p>2021 年 5 月，这一个月完全是值得铭记的。</p>
<p>所以这一篇流水账一般的记录就差不多该结束了。我记得刚刚进入大学的时候有人和我说，适应大学生活是需要很长时间的。我现在在想，或许我现在才算是真的找到了自己想要的生活。回忆着前两年自己近乎碌碌无为的生活，还是暂且从“内卷”“竞争”这些话题之中脱身，想象一下之后的我的大学。</p>
]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
  </entry>
  <entry>
    <title>小学期深夜的废话</title>
    <url>/2021/08/17/nonsense-at-night/</url>
    <content><![CDATA[<p>突然有点想随便写点东西说点感受而已，写完就该睡大觉了。</p>
<span id="more"></span>
<p>现在是 2021 年 8 月 17 日的深夜 03:44 ，这个叫 Holder 的大二学生还没有睡。</p>
<p>小学期选了整整 8 学分的课，从第二周开始每周周一到周五都是全天满课。汇编每周有作业，还有一个大作业和考试。 Java 每堂课有一个小作业，还有一个看起来不是很小的大作业。量子计算作为一门新课，上来就是全英文 PPT ，讲着虚张声势的线性代数，倒也真的把 Holder 愉悦送走了。</p>
<p>但值得庆幸的是，只要不去听老师上课，自己在空调房里和 Sakana 连着麦看 PPT / CSAPP / 各路文档自学，累了就开瓶快乐水刷两眼手机或者打一小会 Project Sekai ，然后慢慢写自己学习的时候的笔记和一时的感悟，这种体验简直不要太好。就是那种感觉，那种感受到了学习愉悦之处的感觉。</p>
<p>我也不知道什么时候我变成了厌恶上课的一个人，烦躁于古板沉闷的 PPT reader 式的课堂。我宁愿自己一个人琢磨，不懂的时候就去各种翻资料或者问问同学，然后在个人网站上写下万字之多的笔记。特别是一时间想通一个很困难的问题的时候，我习惯把当时所有的思路都复盘下来写下来。</p>
<p>这个小学期，我突然觉得自己找到了一种玄妙的乐趣，那种像想要抓住什么的一样的冲动。虽然每天都累得不成样子，到处抱怨，但是内心是充实的。</p>
<p>虽然不知道学的东西会不会派上用场，但是就是享受到了学习这一过程之中的乐趣。</p>
<hr />
<p>也不知道这种斗志昂扬的状态会持续到什么时候，也不知道 Holder 未来会不会又一次陷入像今年 5 月那样沉闷的时光，但无论如何，现在的 Holder 是快乐的。</p>
<p>Holder 或许得睡大觉了，虽然现在才睡，翘汇编是不可避免的了。</p>
]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
  </entry>
  <entry>
    <title>课内学习笔记导航</title>
    <url>/2021/09/17/note-navigation/</url>
    <content><![CDATA[<p>似乎这个站点里面的学习笔记是越来越多了，其他的一些东西几乎都被隐埋了。所以我手动将所有的课内学习笔记的发表时间减去了一千年，让它们位于时间轴末尾，并使用这个置顶的导航贴方便大家查看。这里面应该还会写一些简单的课程测评。</p>
<span id="more"></span>
<h2 id="大二春季学期">大二春季学期</h2>
<ul>
<li><a href="/1021/06/16/note-of-iai">人工智能导论</a>。课程主要内容是传统 AI 相关，深度学习和神经网络几乎浅尝辄止，想要炼丹看起来还是去学习深度学习概论、人工神经网络这些课程。</li>
</ul>
<h2 id="大二夏季学期">大二夏季学期</h2>
<ul>
<li><a href="/1021/08/09/note-of-asm">汇编语言程序设计</a>。学得还算明白的课程，但是我是靠 CSAPP 和网上文档自学的，张老师讲课水平我还真没体验，毕竟只去了第一堂课。</li>
</ul>
<h2 id="大三秋季学期">大三秋季学期</h2>
<p>四大原理还是比较难受。</p>
<ul>
<li><p><a href="/1021/09/13/note-of-net">计算机网络原理</a>。上课坐牢的课，是我大学到现在第一个第一节课都没听完就绷不住回去睡大觉的课。</p></li>
<li><p><a href="/1021/09/14/note-of-pcc">计算机组成原理</a>。没选上康总，只能去另外一个老师那边了，不过反正不听课的我，在这种允许跨班大作业且考试统一的课程上，选哪个老师都一样吧。</p></li>
<li><p><a href="/1021/09/14/note-of-dc">编译原理</a>。今年大作业似乎被削弱了，终于对得起它 2 学分的事实了。</p></li>
<li><p><a href="/1021/09/14/note-of-dsp">信号处理原理</a>。纯数学课，偶尔写写 Matlab 。</p></li>
</ul>
<p>还有两门专业限选课，似乎全是网络相关。</p>
<ul>
<li><p><a href="/1021/09/17/note-of-nst">计算机网络安全技术</a>。一个纯 PPT 学习的课，内容不算无聊但也不算有趣。</p></li>
<li><p><a href="/1021/09/17/note-of-mnt">无线移动网络技术</a>。目前看下来比较有意思，愿意跟进。</p></li>
</ul>
]]></content>
      <categories>
        <category>导航</category>
      </categories>
  </entry>
  <entry>
    <title>《汇编语言程序设计》学习笔记</title>
    <url>/1021/08/09/note-of-asm/</url>
    <content><![CDATA[<p>这门课是 2021 年暑期学期开设的计算机系专业课，应该也算是为下学期的《计算机组成原理》课程做预备，所以还打算好好学一下。</p>
<span id="more"></span>
<h1 id="课程基本介绍">课程基本介绍</h1>
<h2 id="汇编语言介绍">汇编语言介绍</h2>
<p>汇编语言可以认为是机器指令的一种表记方式，其表述了计算机硬件系统对外开放的主要接口和规格，是计算机系统之中的软硬件的分界。所以说要了解汇编语言，就首先需要了解机器指令。</p>
<p>机器指令系统一般分为两类：</p>
<ul>
<li><p>CLSC ，即<strong>复杂指令系统</strong>。一般而言具有多种指令，寻址方式复杂，单条指令的功能较为复杂。较为经典的代表是 X86 。</p></li>
<li><p>RISC ，即<strong>精简指令系统</strong>。考虑到实际使用的指令大多都是简要指令，故该系统只具有常用的精简指令。在这样的条件下，该指令系统依赖于编译器产生高效的代码（依赖编译器优化）。较为经典的代表为 MIPS 。</p></li>
</ul>
<p>目前， CLSC 和 RISC 之间的差别渐渐缩小。但是还是具有明显的区分方式的，即：</p>
<div class="note info no-icon"><p>It loads / stores [with / without] other operations.</p>
</div>
<p>借助于连接软硬件的机器指令集，计算机系统实现了软硬件解耦合。这样软硬件可以独立编写，从而促进了计算机的发展。</p>
<p><strong>注解：</strong>软硬件的分离的一个重要基石是<strong>图灵完备性</strong>。也就是说软件使用的高级语言是图灵完备的，硬件的指令序列也是图灵完备的，这两者完全等价。这样才保证了分离的可行性。</p>
<h2 id="x86-指令集介绍">X86 指令集介绍</h2>
<p>X86 指令集具有以下的基本特征：</p>
<ul>
<li><p>向下兼容、变长指令、多种寻址方式</p></li>
<li><p>通用寄存器个数有限（ X86-32 具有 8 个通用寄存器， X86-64 具有 16 个通用寄存器）</p></li>
<li><p>至多允许一个操作数在内存中，另外一个操作数需要在寄存器中或者是立即数</p></li>
</ul>
<div class="note info no-icon"><p>这里提到了寄存器。 X86 之中的寄存器命名为：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">寄存器名称【 X86-64 名称】</th>
<th style="text-align: center;">X86-32 名称</th>
<th style="text-align: center;">寄存器名称【 X86-64 名称】</th>
<th style="text-align: center;">X86-32 名称</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>%rax</code></td>
<td style="text-align: center;"><code>%eax</code></td>
<td style="text-align: center;"><code>%r8</code></td>
<td style="text-align: center;"><code>%r8d</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>%rdx</code></td>
<td style="text-align: center;"><code>%edx</code></td>
<td style="text-align: center;"><code>%r9</code></td>
<td style="text-align: center;"><code>%r9d</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>%rcx</code></td>
<td style="text-align: center;"><code>%ecx</code></td>
<td style="text-align: center;"><code>%r10</code></td>
<td style="text-align: center;"><code>%r10d</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>%rbx</code></td>
<td style="text-align: center;"><code>%ebx</code></td>
<td style="text-align: center;"><code>%r11</code></td>
<td style="text-align: center;"><code>%r11d</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>%rsi</code></td>
<td style="text-align: center;"><code>%esi</code></td>
<td style="text-align: center;"><code>%r12</code></td>
<td style="text-align: center;"><code>%r12d</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>%rdi</code></td>
<td style="text-align: center;"><code>%edi</code></td>
<td style="text-align: center;"><code>%r13</code></td>
<td style="text-align: center;"><code>%r13d</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>%rsp</code></td>
<td style="text-align: center;"><code>%esp</code></td>
<td style="text-align: center;"><code>%r14</code></td>
<td style="text-align: center;"><code>%r14d</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>%rbp</code></td>
<td style="text-align: center;"><code>%ebp</code></td>
<td style="text-align: center;"><code>%r15</code></td>
<td style="text-align: center;"><code>%r15d</code></td>
</tr>
</tbody>
</table>
</div>
<p>由于 X86 重视向下兼容，所以其指令集越来越趋向于庞杂，所以其一个缺点就是资源利用率低。</p>
<h2 id="mips-指令集介绍">MIPS 指令集介绍</h2>
<p>MIPS 的设计思想是充分利用处理器的流水线结构，目标是让流水线各段负载均匀，这样可以让处理器频率得到提高。其特征包括：</p>
<ul>
<li><p>以寄存器为中心，只有 Load 以及 Store 命令可以访问内存</p></li>
<li><p>所有计算操作均是从寄存器堆之中读取数据并将结果保存到寄存器堆，一共具有 32 个通用寄存器</p></li>
<li><p>指令格式规整、定长，且操作码位置固定，指令类型少（ MIPS32 的指令只有 register / immediate / jump 三类）</p></li>
<li><p>寻址方式简单，每一条指令的操作过程简单</p></li>
</ul>
<p>当然， MIPS 也具有一些被扩展过的扩展指令集，如 MIPS16e 等等。</p>
<p>此外， RISC-V 也是一种常用指令集。但其几乎和 MIPS 同源，故这里不作详细介绍。</p>
<h1 id="整数的表示与计算">整数的表示与计算</h1>
<p>首先我们介绍一些简要表记，即 K / M / G / T / P / E 。符号 K 表示 <span class="math inline">\(2^{10}\)</span> ，之后有 <span class="math inline">\({\rm M} = 2^{10} \cdot {\rm K}\)</span> 以及 <span class="math inline">\({\rm G} = 2^{10} \cdot {\rm M}\)</span> ，依此类推。</p>
<p>同时我们将一个二进制位称为<strong>比特（ bit ）</strong>，将八个比特称为<strong>字节（ byte ）</strong>。在 X86 架构下，两个字节称为一个<strong>字（ word ）</strong>，而在 MIPS 架构下则是四个字节。</p>
<p>对于数的进制、二进制数的逻辑运算，这里不进行介绍。</p>
<h2 id="机器字和字节序">机器字和字节序</h2>
<p>首先引入<strong>机器字</strong>的概念，机器字指的是计算机进行一次整数运算所能处理的二进制数据组，也可以是一个数据地址。相应的，<strong>机器字长</strong>指的就是一个机器字的位数。对于 32 位字长的计算机，其地址能够表示的空间大小为 4GB 左右。机器字长越大的计算机，其地址的表示空间就越大。</p>
<p>机器字的定位为这个机器字第一个字节的地址，所以说相邻机器字的地址之差在 32 位系统之中为 4 ，而在 64 位系统之中为 8 。</p>
<p><strong>字节序</strong>指的就是一个机器字所包含的字节在机器字之中的排列的顺序，分为<strong>大端序（ Big endian ）</strong>以及<strong>小端序（ Little endian ）</strong>。大端序指的是低位字节占据高地址，小端序则相反。</p>
<p>比如说十六进制数据 <code>0x01234567</code> ，如果这个机器字地址为 <code>0x100</code> 。那么在大端序之下， <code>0x100, 0x101, 0x102, 0x103</code> 的字节内容分别为 <code>01, 23, 45, 67</code>。而在小端序下则是 <code>67, 45, 23, 01</code> 。</p>
<h2 id="整数的二进制编码">整数的二进制编码</h2>
<p>我们首先复习一下 C 语言之中各个数据类型的大小，这里以字节作为单位：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">数据类型</th>
<th style="text-align: center;">经典 32 位系统</th>
<th style="text-align: center;">X86-32</th>
<th style="text-align: center;">X86-64</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>char</code></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>short</code></td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>int</code></td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>long</code></td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">8</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>long long</code></td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">8</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>float</code></td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>double</code></td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">8</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>long double</code></td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">10 / 12</td>
<td style="text-align: center;">10 / 16</td>
</tr>
<tr class="odd">
<td style="text-align: center;">指针</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">8</td>
</tr>
</tbody>
</table>
<p>这里我们为了简便，使用 16 位系统来演示整数的编码方式，也就是说机器字长为 16 位，一个整数使用 2 个字节表示。</p>
<h3 id="有符号数的编码">有符号数的编码</h3>
<p>对于非负的整数，显然可以直接使用其二进制表示作为其编码。比如说十进制数 <code>12345</code> ，其二进制表示为 <code>00110000 00111001</code> ，那么其编码就是 <code>00110000 00111001</code> 。</p>
<p>对于负数，一种解决方式是使用最高位表记符号，最高位为 <code>1</code> 的数为负数，为 <code>0</code> 的数为非负数。然而这样会导致加法器在运算的时候需要首先验证符号位，计算出结果后还需要计算符号为，比较繁杂。所以说这里引入了<strong>补码（ two's complement ）</strong>，用补码表示的整数可以简化有符号整数的计算。</p>
<p>非负数的补码就是其二进制表示，负数的补码是其绝对值的二进制表示按位取反之后加一。</p>
<p>比如说十进制数 <code>-12345</code> ，由于 <code>12345</code> 的二进制表示为 <code>00110000 00111001</code> ，首先按位取反得到 <code>11001111 11000110</code> ，最后加一得到其补码为 <code>11001111 11000111</code> 。</p>
<p>这个时候符号位依然存在，也就是说补码表示下负数最高位为 <code>1</code> ，非负数最高位为 <code>0</code> 。</p>
<div class="note info no-icon"><p>补码的优越性在于简化了有符号整数的加法计算。如果我们使用 <span class="math inline">\({\rm TC}_w(x)\)</span> 表示字长为 <span class="math inline">\(w\)</span> 的系统下整数 <span class="math inline">\(x\)</span> 的补码（比如 <code>-12345</code> 的补码为 <code>11001111 11000111</code> ，后者直接转换为十进制表示的是 <code>53191</code> ，那么定义 <span class="math inline">\({\rm TC}_w(-12345) = 53191\)</span> ）。实际上可以发现对于非负数 <span class="math inline">\({\rm TC}_w(x)=x\)</span> ，而对于负数：</p>
<p><span class="math display">\[
{\rm TC}_w(x) = 1 + \mathop{\sim}(-x)
\]</span></p>
<p>而对于字长为 <span class="math inline">\(w\)</span> 的系统， <span class="math inline">\(x + (\mathop{\sim}x) = 2^w - 1\)</span> ，所以说对于负数 <span class="math inline">\(x\)</span> 有：</p>
<p><span class="math display">\[
{\rm TC}_w(x) = 1 + 2^w - 1 - (-x) = 2^w + x
\]</span></p>
<p>所以无论如何我们都可以断定：</p>
<p><span class="math display">\[
{\rm TC}_w(x) \equiv x\ ({\rm mod}\ 2^w)
\]</span></p>
<p>在这样的条件下做加法是简单的，因为一个整数和其补码在模 <span class="math inline">\(2^w\)</span> 意义下等价。后面讨论补码条件下的加法的时候，即使出现截断，由于所截断的 <code>1</code> 必然位于不低于 <span class="math inline">\(2^w\)</span> 的位上，所以截断还是不会影响模的结果。</p>
</div>
<p>对于字长为 <span class="math inline">\(w\)</span> 的系统，按照补码表示的有符号数系统之中，最大的数为 <span class="math inline">\(2^{w - 1} - 1\)</span> ，而最小的数为 <span class="math inline">\(-2^{w - 1}\)</span> 。</p>
<h3 id="无符号数的编码">无符号数的编码</h3>
<p>无符号数的编码是简单的，因为其只需要考虑非负数，所以直接使用二进制表示作为编码就可以了。</p>
<p>这种系统之下，最大的数为 <span class="math inline">\(2^w - 1\)</span> ，而最小的数为 <span class="math inline">\(0\)</span> 。</p>
<h3 id="有符号数和无符号数的关系和转换">有符号数和无符号数的关系和转换</h3>
<p>现在我们已经给出了有符号和无符号整数的表示方式了。现在考虑将一个有符号整数强制类型转换为无符号整数，比如说在机器字长为 4 的时候， <code>-4</code> 的补码为 <code>1010</code> ，而强转为无符号整数的时候， <code>1010</code> 则表示 <code>12</code> 。其实不难证明对于字长为 <span class="math inline">\(w\)</span> 的系统，有这样的关系：</p>
<p><span class="math display">\[
(\text{unsigned})x = \begin{cases}
x &amp; x \geq 0 \\
x + 2^w &amp; x &lt; 0
\end{cases}
\]</span></p>
<p>这里提一下，在 C 语言的比较运算之中如果同时出现有符号数和无符号数，则会将有符号数强制转换为无符号数。当然，如果两边都是有符号数，则按照有符号数的比较规则进行。</p>
<p>事实上，由于这样的隐式转换，如果我们给声明为无符号整数的变量赋予一个负数值，就有可能被强制转换为一个大整数，从而导致违反直觉的结果，甚至导致错误。所以说我们应当谨慎使用无符号整数，一般而言，只有涉及到<strong>模运算</strong>或者单纯使用<strong>位运算</strong>的时候无符号整数比较适合。</p>
<h2 id="整数的计算">整数的计算</h2>
<h3 id="无符号整数的加法">无符号整数的加法</h3>
<p>对于字长为 <span class="math inline">\(w\)</span> 的系统，两个整数的加法可能会需要 <span class="math inline">\(w + 1\)</span> 位才能表示，这个时候就会发生<strong>溢出</strong>。计算机的一般处理方式是舍去最高位，强制仅用 <span class="math inline">\(w\)</span> 位表达计算结果，其实相当于对 <span class="math inline">\(2^w\)</span> 取了模。也就是说，字长为 <span class="math inline">\(w\)</span> 的、带有截断的无符号整数加法为（这里，符号 <span class="math inline">\(+^{\text u}_w\)</span> 表示的是字长为 <span class="math inline">\(w\)</span> 的系统下无符号整数的加法）：</p>
<p><span class="math display">\[
x +^{\text{u}}_w y =\begin{cases}
x + y &amp; x + y &lt; 2^w \\
x + y - 2^w &amp; x + y \geq 2^w
\end{cases}
\]</span></p>
<h3 id="有符号整数的加法">有符号整数的加法</h3>
<p>在字长为 <span class="math inline">\(w\)</span> 的、使用补码的系统下，对于有符号整数 <span class="math inline">\(x, y\)</span> ，其加法是有可能溢出的。</p>
<p>一种是两个大正数相加，超越了补码能表示的最大整数。此时补码的符号位承接了较低位溢出的 <code>1</code> ，也就是说补码之和实际上代表一个负数。由于负数 <span class="math inline">\(u\)</span> 的补码 <span class="math inline">\({\rm TC}_w(u) = u + 2^w\)</span> ，这个负数实际上就是 <span class="math inline">\(x + y - 2^w\)</span> 。这种情况被称为<strong>正溢出</strong>。</p>
<p>另外一种是两个绝对值很大的负数相加，超越了补码能表示的最小整数。此时补码符号位两个 <code>1</code> 相加得到 <code>10</code> ，溢出为 <span class="math inline">\(w + 1\)</span> 位数，但是最高位的 <code>1</code> 被截断。另外，较低的 <span class="math inline">\(w - 1\)</span> 位不会向上进位（绝对值很大的负数的补码较低位所表示的数实际上会很小）。此时结果的补码符号位为 <code>0</code> ，代表一个正数。由于负数 <span class="math inline">\(u\)</span> 的补码 <span class="math inline">\({\rm TC}_w(u) = u + 2^w\)</span> ，考虑到截断了一个 <code>1</code> ，所以该正数为：</p>
<p><span class="math display">\[
(x + 2^w) + (y + 2^w) - 2^w = x + y + 2^w
\]</span></p>
<p>这种情况被称为<strong>负溢出</strong>。</p>
<p>对于求和结果在表示范围内的，补码的和（截断为 <span class="math inline">\(w\)</span> 位后）就是和的补码。这是因为 <span class="math inline">\(x, y\)</span> 的补码相加后截断，所代表的数与 <span class="math inline">\(x + y\)</span> 模 <span class="math inline">\(2^w\)</span> 同余，而 <span class="math inline">\(x + y\)</span> 位于补码能表示的范围内，所以 <span class="math inline">\(x, y\)</span> 的补码相加后截断得到的就是 <span class="math inline">\(x + y\)</span> 的补码。</p>
<p>总而言之，字长为 <span class="math inline">\(w\)</span> 的、带有截断的有符号整数加法为（这里，符号 <span class="math inline">\(+^{\text t}_w\)</span> 表示的是字长为 <span class="math inline">\(w\)</span> 的系统下无符号整数的加法）：</p>
<p><span class="math display">\[
x +^{\text{t}}_w y = \begin{cases}
x + y - 2^w &amp; x + y \geq 2^{w - 1} \\
x + y &amp; -2^{w - 1} \leq x + y &lt; 2^{w - 1} \\
x + y + 2^w &amp; x + y &lt; -2^{w - 1}
\end{cases}
\]</span></p>
<h3 id="无符号整数除以-2-的幂">无符号整数除以 2 的幂</h3>
<p>一般而言在计算机中，除法计算消耗的时间是相当长的。但是对于除数是 2 的幂的情况，我们可以使用移位的方式简化计算。</p>
<p>左移是很好理解的，溢出的部分会被截断，低位会用 <code>0</code> 补齐。但是右移的时候，低位截断是自然的，但是高位如何补齐则有两种方式。如果高位用 <code>0</code> 补齐，这种移位称为<strong>逻辑右移</strong>。如果用原数的最高位补齐（这里的最高位可以是 <code>0</code> ，比如 16 位系统之中的 <code>00000000 00000001</code> 的最高位为 <code>0</code> ），这种移位称为<strong>算术右移</strong>。</p>
<p>在字长为 <span class="math inline">\(w\)</span> 的系统下，我们将无符号的逻辑右移标记为 <span class="math inline">\(&gt;^{\text{ul}}_w\)</span> ，无符号的算术右移则标记为 <span class="math inline">\(&gt;^{\text{um}}_w\)</span> 。</p>
<p><strong>注解：</strong>有符号的右移则将上标的 <span class="math inline">\(\text{u}\)</span> 替换为 <span class="math inline">\(\text{t}\)</span> 。</p>
<p>其实对于无符号整数 <span class="math inline">\(x\)</span> 不难得到：</p>
<p><span class="math display">\[
x &gt;^{\text{ul}}_w k = \left\lfloor \frac{x}{2^k} \right\rfloor
\]</span></p>
<h3 id="有符号整数除以-2-的幂">有符号整数除以 2 的幂</h3>
<p>首先说明，我们希望除法的结果<strong>向 0 舍入</strong>，也就是说 <code>23.6</code> 舍为 <code>23</code> ， <code>-24.6</code> 舍为 <code>-24</code> 。</p>
<p>这里我们依然使用右移来简化除法计算。但是我们注意到负数除以 2 的幂之后必然还是负数，所以不能使用逻辑右移，只能使用算数右移。这个时候，对于有符号整数 <span class="math inline">\(x\)</span> 我们可以简单地使用 <span class="math inline">\(x &gt;^{\text{tm}}_w k\)</span> 来计算 <span class="math inline">\(x / 2^k\)</span> 。</p>
<p>对于正数，这样的计算显然是正确的。但是对于负数，比如说 <code>-15213</code> ，其补码为 <code>11000100 10010011</code> 。我们计算其除以 <code>256</code> 的商，按照上面的计算方式即将其补码算术右移 <code>8</code> 位，得到 <code>11111111 11000100</code> ，结果为 <code>-60</code> 。然而我们知道实际的结果应当为 <code>-59.43</code> ，按照舍入应当保留为 <code>-59</code> 。</p>
<div class="note info no-icon"><p>事实上我们可以说明：</p>
<p><span class="math display">\[
x &gt;^{\text{tm}}_w k = \left\lfloor \frac{x}{2^k} \right\rfloor
\]</span></p>
<p>也就是说<strong>使用算术右移计算有符号整数的时候永远得到向下舍入的结果</strong>。我们只要说明负数的情况即可，对于负数 <span class="math inline">\(x\)</span> 的补码 <span class="math inline">\(x_{w - 1}x_{w - 2} \cdots x_0\)</span> ，我们设二进制数 <span class="math inline">\(x_{w - 1}x_{w - 2} \cdots x_k\)</span> 表示数 <span class="math inline">\(x&#39;\)</span> ，二进制数 <span class="math inline">\(x_{k - 1}x_{k - 2} \cdots x_0\)</span> 表示数 <span class="math inline">\(x&#39;&#39; &lt; 2^k\)</span> 。显然：</p>
<p><span class="math display">\[
2^k x&#39; + x&#39;&#39; = {\rm TC}_w(x) = 2^w + x
\]</span></p>
<p>而 <span class="math inline">\(x &gt;^{\text{tm}}_w k\)</span> 得到的是 <span class="math inline">\(x_{w - 1}x_{w - 1} \cdots x_{w - 1}x_{w - 2} \cdots x_k\)</span> ，其表示数：</p>
<p><span class="math display">\[
x&#39; + \sum_{i = w - k}^{w - 1} 2^i = x&#39; + 2^{w - k}(2^k - 1)
\]</span></p>
<p>按照补码去解读这个二进制串的话，其结果为 <span class="math inline">\(x&#39; + 2^{w - k}(2^k - 1) - 2^w = x&#39; - 2^{w - k}\)</span> 。也就能够计算得到：</p>
<p><span class="math display">\[
\left\lfloor \frac{x}{2^k} \right\rfloor = \left\lfloor \frac{2^k x&#39; + x&#39;&#39; - 2^w}{2^k} \right\rfloor = \left\lfloor x&#39; - 2^{w - k} + \frac{x&#39;&#39;}{2^k} \right\rfloor = x&#39; - 2^{w - k} = x &gt;^{\text{tm}}_w k
\]</span></p>
</div>
<p>为了修正这个舍入问题，我们可以尝试使用这样的一个性质：</p>
<p><span class="math display">\[
\left\lceil \frac{x}{y} \right\rceil = \left\lfloor \frac{x + y - 1}{y} \right\rfloor\ (y &gt; 0)
\]</span></p>
<p>也就是说我们只要在计算负数 <span class="math inline">\(x\)</span> 的时候改变为：</p>
<p><span class="math display">\[
\left\lfloor \frac{x + 2^k - 1}{2^k} \right\rfloor = [x +^{\text{t}}_w (2^k - 1)] &gt;^{\text{tm}}_w k
\]</span></p>
<p>即可。</p>
<h1 id="小数的表示">小数的表示</h1>
<h2 id="ieee-浮点数标准">IEEE 浮点数标准</h2>
<p>对于一个有小数部分的数 <span class="math inline">\(B\)</span> ，我们总是能找到唯一的 <span class="math inline">\(s \in \{0, 1\}\)</span> 以及实数 <span class="math inline">\(M \in [1, 2)\)</span> 和整数 <span class="math inline">\(E\)</span> 满足：</p>
<p><span class="math display">\[
B = (-1)^s M \cdot 2^E
\]</span></p>
<p>这里 <span class="math inline">\(s, E, M\)</span> 分别称为<strong>符号</strong>、<strong>阶码</strong>和<strong>尾数</strong>。</p>
<p>基于这样的性质，我们可以给出小数的表示方式。将一片数据区域的最高位用于放置符号位 <span class="math inline">\(s\)</span> ，然后后面分割为两部分，即 <strong>exp 域</strong>和 <strong>frac 域</strong>，分别放置 <span class="math inline">\(E\)</span> 以及 <span class="math inline">\(M\)</span> 。 exp 域和 frac 域的具体大小有两种常见的制式（即<strong>单精度浮点</strong>和<strong>双精度浮点</strong>）。当然还有一些不太常用的分区方式，具体见表：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">标准</th>
<th style="text-align: center;">exp 域长度</th>
<th style="text-align: center;">frac 域长度</th>
<th style="text-align: center;">浮点总长</th>
<th style="text-align: center;">备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">单精度浮点</td>
<td style="text-align: center;">8 bits</td>
<td style="text-align: center;">23 bits</td>
<td style="text-align: center;">4 字节</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">双精度浮点</td>
<td style="text-align: center;">11 bits</td>
<td style="text-align: center;">52 bits</td>
<td style="text-align: center;">8 字节</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">扩展精度浮点</td>
<td style="text-align: center;">15 bits</td>
<td style="text-align: center;">63 bits</td>
<td style="text-align: center;">10 字节</td>
<td style="text-align: center;">空置 1 bit</td>
</tr>
<tr class="even">
<td style="text-align: center;">半精度浮点</td>
<td style="text-align: center;">5 bits</td>
<td style="text-align: center;">10 bits</td>
<td style="text-align: center;">2 字节</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>在具体存储的时候，尾数由于整数部分必然为 <code>1</code> ，所以只需要将小数部分按顺序存储即可，而阶码使用无符号整数方法存储。</p>
<p>这里注意，阶码理应是有可能为负数的，但一般存储的时候会将阶码加上一个固定的偏置变成正数之后存储。如果阶码长度为 <span class="math inline">\(e\)</span> ，那么这个偏置就是 <span class="math inline">\(b = 2^{e - 1} - 1\)</span> 。</p>
<p>比如说按照单精度浮点的方式存储数 <code>15213.0</code> ，其二进制表示为 <span class="math inline">\(1.1101101101101 \times 2^{13}\)</span> 。所以符号位为 <code>0</code> ，尾数取小数部分前 23 位，即 <code>1101101 10110100 00000000</code> 。阶码为 <code>13</code> ，加上偏置 <span class="math inline">\(2^{7} - 1 = 127\)</span> 得到 <code>140</code> ，即 <code>10001100</code> 。所以最后的存储方式为：</p>
<figure class="highlight plaintext"><figcaption><span>Bits</span></figcaption><table><tr><td class="code"><pre><span class="line">01000110 01101101 10110100 00000000</span><br></pre></td></tr></table></figure>
<h2 id="浮点数的非规格化">浮点数的非规格化</h2>
<p>事实上，浮点数标准保留一部分阶码用于表示特殊的数字。一般而言，阶码全 <code>1</code> 和全 <code>0</code> 是被保留的。具体而言，阶码全 <code>1</code> 和全 <code>0</code> 的、表述特殊数字的浮点数被称为<strong>非规格化浮点数（ denormalized float point ）</strong>，其余的被称为<strong>规格化浮点数（ normalized float point ）</strong>。</p>
<p>全 <code>0</code> 的阶码如果按照上述的标准解读的话，表示的是相当接近于零的小数。但是由于默认了尾数的整数部分为 <code>1</code> ，所以说还按照原有解读方式的话，浮点数无法表示 <code>0</code> 。这个时候作出规定，就是<strong>阶码全 <code>0</code> 的时候，尾数的整数部分变为 <code>0</code></strong> 。相应的，为了配合尾数解读方式的调整，<strong>阶码的偏置减去一</strong>。</p>
<p>假设某浮点数标准之中阶码长为 <span class="math inline">\(e\)</span> ，尾数长为 <span class="math inline">\(m\)</span> 。那么规格化的条件下最小的正浮点数应当是阶码为 <code>00...01</code> ，尾数全 <code>0</code> 。此时表示的数为 <span class="math inline">\(2^{1 - (2^{e - 1} - 1)} = 2^{2 - 2^{e - 1}}\)</span> 。在非规格化条件下，如果将尾数按照无符号整数解析得到的非负整数标记为 <span class="math inline">\(n\)</span> ，那么该浮点数应该为 <span class="math inline">\(2^{2 - 2^{e - 1}} \cdot 2^{-m}n\)</span> 。这里非负整数 <span class="math inline">\(n\)</span> 取值范围为 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(2^m - 1\)</span> 。</p>
<p>所以说非规格化的浮点数所能表述的非负数序列为：</p>
<p><span class="math display">\[
0, \ 2^{2 - 2^{e - 1}} \cdot 2^{-m} \cdot 1, \ \cdots, \ 2^{2 - 2^{e - 1}} \cdot 2^{-m}(2^m - 1)
\]</span></p>
<p>这是一个公差为 <span class="math inline">\(2^{2 - 2^{e - 1}} \cdot 2^{-m}\)</span> 的等差数列，而且最后正好可以和规格化浮点数所表述的最小正数 <span class="math inline">\(2^{2 - 2^{e - 1}}\)</span> “无缝衔接”。所以说非规格化浮点数是一个合理的拓展。</p>
<p>但是，注意非规格化浮点数之中有 <code>+0</code> 和 <code>-0</code> 的区别。</p>
<p>全 <code>1</code> 的阶码用于表示很大的浮点数。一般而言尾数全 <code>0</code> 的时候该浮点数被保留用于表示无穷。而尾数有非 <code>0</code> 位的时候，该浮点数被保留用于表示 <code>NaN</code> 。</p>
<hr />
<p>现在补全了非规格化浮点数之后，可以发现浮点数的大小比较实际上几乎可以按照无符号整数从高位直接比较到低位的逻辑进行。因为阶码大的数一定大，阶码一样的时候尾数大的数一定大，包括无穷大也可以纳入进来。但是要考虑这样的例外：</p>
<ul>
<li><p>考虑符号位</p></li>
<li><p>考虑 <code>+0</code> 和 <code>-0</code> 的特例</p></li>
<li><p>考虑 <code>NaN</code> 的问题</p></li>
</ul>
<h2 id="浮点数的舍入问题">浮点数的舍入问题</h2>
<p>由于部分数不能表述为有限的二进制小数，所以在转化为浮点数表示的时候需要舍入。一般而言向上舍入、向下舍入、向零舍入都会带来统计误差，而计算机之中常常使用<strong>向偶数舍入</strong>。其舍入的规则是向最接近的数舍入。如果向两边舍入的距离一致，那么优先舍入到偶数。比如说下列数之中，向百分位的舍入为：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; 12.324999 \Rightarrow 12.32 \\
&amp; 12.325001 \Rightarrow 12.33 \\
&amp; 12.325000 \Rightarrow 12.32 \\
&amp; 12.335000 \Rightarrow 12.34 \\
\end{aligned}
\]</span></p>
<p>回到二进制上的话，由于十进制的 <code>0.5</code> 相当于二进制的 <code>0.1</code> 。也就是说如果二进制小数之中后面需要舍去的部分大于 <code>100...</code> 则向上舍入，小于 <code>100...</code> 则向下舍入，恰好是 <code>100...</code> 则向偶数舍入（舍入完毕后尾数为 <code>0</code> ）。</p>
<p>这里要注意一点，舍入是有可能导致溢出。</p>
<hr />
<p>至此，小数的计算机编码方式基本就介绍完毕了。其具体过程为：</p>
<ul>
<li><p>根据使用的浮点数标准，判定使用规格化的浮点数还是非规格化的浮点数</p></li>
<li><p>据此判定符号位、阶码和尾数</p></li>
<li><p>对尾数进行舍入后转化为二进制表示</p></li>
</ul>
<h2 id="c-语言的浮点数">C 语言的浮点数</h2>
<p>C 语言之中， <code>int</code> 类型以及 <code>float</code> 类型是 4 字节的， <code>double</code> 则是 8 字节。它们之间的互相转换满足这样的规则：</p>
<ul>
<li><p><code>int</code> 可以精确转换为 <code>double</code> 类型</p></li>
<li><p><code>int</code> 转换为 <code>float</code> 类型不会溢出，但有可能被舍入</p></li>
<li><p><code>float</code> 以及 <code>double</code> 转换为 <code>int</code> 时尾数截断，如果发生溢出则产生 UB</p></li>
</ul>
<h1 id="汇编语言基本知识">汇编语言基本知识</h1>
<p>在这一部分，我们使用<strong>指令集架构（ Instruction Set Architecture, ISA ）</strong>来定义机器级程序的行为。在这个架构之中， CPU 内有一个记录下一条指令在主存储器之中位置的<strong>指令寄存器（ Program Counter, PC ）</strong>，这个寄存器在 X86 体系中被命名为 <code>%rip</code> 。 CPU 之中同时还具有若干个<strong>寄存器</strong>，以及一个用于存储最近执行指令的结果状态信息的<strong>条件码寄存器</strong>。除去 CPU 外，这个架构之中还有<strong>主存储器</strong>，其可以认为是以字节为单元的一片连续的地址空间。</p>
<h2 id="汇编语言的数据类型">汇编语言的数据类型</h2>
<p>和 C 语言不同，汇编语言不区分具体的数据类别，其不关心某一组二进制数据具体代表什么类型的数据。其不区分有符号和无符号的整数，甚至不区分指针和整数。其一般只区分数据的长度为字节、字、双字、四字。在处理这四种长度的数据的时候，指令的后缀分别为 <code>b, w, l, q</code> 。比如说传送数据的命令为 <code>mov</code> ，在传送字节的时候该命令写为 <code>movb</code> ，在传送单字的时候该命令写为 <code>movw</code> 等等。</p>
<h2 id="汇编语言的数据操作">汇编语言的数据操作</h2>
<p>汇编语言的基本操作只包括对寄存器或主存数据进行运算、在寄存器和主存内部或者之间传递数据、转移程序执行位置这三种。</p>
<div class="note info no-icon"><p>在 X86-64 系统之下，寄存器是四字长的、通过名称访问的一片空间。但实际上有的时候指令可以不用访问整个四字长的寄存器空间，其可以通过 32 位操作访问四个字之中较低位的两个字，通过 16 位操作访问四个字中最低位的字，也可以通过字节操作访问最低位的字节。相应的，指代这一片寄存器空间的名称有所改变：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">64 位操作</th>
<th style="text-align: center;">32 位操作</th>
<th style="text-align: center;">16 位操作</th>
<th style="text-align: center;">字节操作</th>
<th style="text-align: center;">64 位操作</th>
<th style="text-align: center;">32 位操作</th>
<th style="text-align: center;">16 位操作</th>
<th style="text-align: center;">字节操作</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>%rax</code></td>
<td style="text-align: center;"><code>%eax</code></td>
<td style="text-align: center;"><code>%ax</code></td>
<td style="text-align: center;"><code>%al</code></td>
<td style="text-align: center;"><code>%r8</code></td>
<td style="text-align: center;"><code>%r8d</code></td>
<td style="text-align: center;"><code>%r8w</code></td>
<td style="text-align: center;"><code>%r8b</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>%rdx</code></td>
<td style="text-align: center;"><code>%edx</code></td>
<td style="text-align: center;"><code>%dx</code></td>
<td style="text-align: center;"><code>%dl</code></td>
<td style="text-align: center;"><code>%r9</code></td>
<td style="text-align: center;"><code>%r9d</code></td>
<td style="text-align: center;"><code>%r9w</code></td>
<td style="text-align: center;"><code>%r9b</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>%rcx</code></td>
<td style="text-align: center;"><code>%ecx</code></td>
<td style="text-align: center;"><code>%cx</code></td>
<td style="text-align: center;"><code>%cl</code></td>
<td style="text-align: center;"><code>%r10</code></td>
<td style="text-align: center;"><code>%r10d</code></td>
<td style="text-align: center;"><code>%r10w</code></td>
<td style="text-align: center;"><code>%r10b</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>%rbx</code></td>
<td style="text-align: center;"><code>%ebx</code></td>
<td style="text-align: center;"><code>%bx</code></td>
<td style="text-align: center;"><code>%bl</code></td>
<td style="text-align: center;"><code>%r11</code></td>
<td style="text-align: center;"><code>%r11d</code></td>
<td style="text-align: center;"><code>%r11w</code></td>
<td style="text-align: center;"><code>%r11b</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>%rsi</code></td>
<td style="text-align: center;"><code>%esi</code></td>
<td style="text-align: center;"><code>%si</code></td>
<td style="text-align: center;"><code>%sil</code></td>
<td style="text-align: center;"><code>%r12</code></td>
<td style="text-align: center;"><code>%r12d</code></td>
<td style="text-align: center;"><code>%r12w</code></td>
<td style="text-align: center;"><code>%r12b</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>%rdi</code></td>
<td style="text-align: center;"><code>%edi</code></td>
<td style="text-align: center;"><code>%di</code></td>
<td style="text-align: center;"><code>%dil</code></td>
<td style="text-align: center;"><code>%r13</code></td>
<td style="text-align: center;"><code>%r13d</code></td>
<td style="text-align: center;"><code>%r13w</code></td>
<td style="text-align: center;"><code>%r13b</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>%rsp</code></td>
<td style="text-align: center;"><code>%esp</code></td>
<td style="text-align: center;"><code>%sp</code></td>
<td style="text-align: center;"><code>%spl</code></td>
<td style="text-align: center;"><code>%r14</code></td>
<td style="text-align: center;"><code>%r14d</code></td>
<td style="text-align: center;"><code>%r14w</code></td>
<td style="text-align: center;"><code>%r14b</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>%rbp</code></td>
<td style="text-align: center;"><code>%ebp</code></td>
<td style="text-align: center;"><code>%bp</code></td>
<td style="text-align: center;"><code>%bpl</code></td>
<td style="text-align: center;"><code>%r15</code></td>
<td style="text-align: center;"><code>%r15d</code></td>
<td style="text-align: center;"><code>%r15w</code></td>
<td style="text-align: center;"><code>%r15b</code></td>
</tr>
</tbody>
</table>
<p>实际上，有的时候我们还可以用字节操作访问 <code>%rax, %rbx, %rcx, %rdx</code> 这四个寄存器的倒数第二低位的字节，指代这一部分空间的名称则为 <code>%ah, %bh, %ch, %dh</code> 。</p>
</div>
<p>在具体进行操作的时候，一个机器指令往往需要跟随若干的操作数具体规定操作方法（如传送数据的时候，需要通过操作数指定传送的起始位置和终止位置）。操作数有三种表述方式：</p>
<ul>
<li><p><strong>立即数</strong>。其是一个整型的常数，写法为 <code>$</code> 后接上一个 C 风格的数字表示这个立即数的值。比如说 <code>$-521</code> 以及 <code>$0x4FD</code> 。</p></li>
<li><p><strong>寄存器数值</strong>。直接使用寄存器的名称访问，如 <code>%rbp</code> 就代表这个寄存器之中的数据。但是注意，寄存器 <code>%rsp</code> 一般而言是被保留的。</p></li>
<li><p><strong>主存数值</strong>。使用地址访问，其地址由某一个寄存器之中的数据指定，写法为寄存器名称加括号。比如说要访问某一个主存数值，其地址存储在寄存器 <code>%rax</code> 之中，那么其写法为 <code>(%rax)</code> 。</p></li>
</ul>
<h2 id="汇编语言的寻址方式">汇编语言的寻址方式</h2>
<h3 id="x86-系统的变址寻址方式">X86 系统的变址寻址方式</h3>
<p>但实际上，在 X86 系统中访问主存数值的方式（这也被称为<strong>寻址方式</strong>）并不是单一的。除去直接使用寄存器之中的数据作为地址去访问， X86 系统提供了包含变址、立即数偏移的寻址模式，其表记一般为 <code>IMM(a, b, s)</code> 。这里 <code>IMM</code> 为一个立即数，称为<strong>立即数偏移</strong>， <code>a, b</code> 为两个寄存器名，分别称为<strong>定址寄存器</strong>和<strong>变址寄存器</strong>， <code>s</code> 为 <code>1, 2, 4, 8</code> 之中的一个数，称为<strong>比例因子</strong>。这个记号所代表的地址为：</p>
<p><span class="math display">\[
{\rm IMM} + {\rm R}(a) + {\rm R}(b) \cdot s 
\]</span></p>
<p>这里符号 <span class="math inline">\({\rm R}(a)\)</span> 表示寄存器 <code>a</code> 之中的数据。</p>
<p>这个表记存在一系列简写：</p>
<ul>
<li><p>当不存在定址和变址寄存器的时候，简写为 <code>IMM</code> 。这个时候相当于不经过寄存器直接指定主存中的某一个地址，称为<strong>绝对寻址</strong>。</p></li>
<li><p>当 <code>IMM</code> 为 <code>0</code> ，不存在变址寄存器的时候，简写为 <code>(a)</code> 。这也就是最简单的寻址方式，即直接将寄存器数值作为地址解读，称为<strong>间接寻址</strong>。</p></li>
<li><p>当存在变址寄存器但 <code>s</code> 为 <code>1</code> 的时候，简写为 <code>IMM(a, b)</code> 。</p></li>
</ul>
<hr />
<p>现在我们就可以尝试解读一些汇编代码了，比如：</p>
<figure class="highlight plaintext"><figcaption><span>X86-64 Assembly</span></figcaption><table><tr><td class="code"><pre><span class="line">movq $-147, (%rax)</span><br></pre></td></tr></table></figure>
<p>这个指令的意思是按照四字数据转移的方式，将立即数 <code>-147</code> 写入主存，写入地址为寄存器 <code>%rax</code> 的数值。</p>
<h3 id="利用寻址进行整数计算">利用寻址进行整数计算</h3>
<p>地址实际上也可以被解读为整数，而机器进行寻址的时候实际上就在完成整数计算。根据上面给出的变址寻址方式，我们可以利用寻址命令来计算类似 <span class="math inline">\(x + ky\)</span> 的整数算式。</p>
<p>首先需要知道指令：</p>
<figure class="highlight plaintext"><figcaption><span>X86-64 Assembly</span></figcaption><table><tr><td class="code"><pre><span class="line">leaq [SRC], [DEST]</span><br></pre></td></tr></table></figure>
<p>这里 <code>[SRC]</code> 是一个寻址表达式，其计算出来的结果将赋给 <code>[DEST]</code> 。比如 <code>leaq (%rdi, %rdi, 2), %rax</code> 会将前面寻址计算出来的地址赋予寄存器 <code>%rax</code> 。</p>
<p>实际上在编译器优化之中，部分整数运算都会被优化为地址计算。比如说 <code>x * 12</code> 这个代码有可能会被转化为如下的汇编代码：</p>
<figure class="highlight plaintext"><figcaption><span>X86-64 Assembly</span></figcaption><table><tr><td class="code"><pre><span class="line">leaq (%rdi, %rdi, 2), %rax</span><br><span class="line">salq $2, %rax</span><br></pre></td></tr></table></figure>
<p>第一步使用地址计算实际上计算了 <code>x + x * 2</code> ，即三倍的 <code>x</code> 。第二步命令为左移，左移两位即再次乘以 <code>4</code> 得到最后结果。</p>
<h2 id="汇编语言常用的整数计算命令">汇编语言常用的整数计算命令</h2>
<p>汇编语言计算整数运算的时候，会有如下表所列出的常用命令。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">命令格式</th>
<th style="text-align: center;">等价的 C 代码</th>
<th style="text-align: center;">备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>addq [SRC], [DEST]</code></td>
<td style="text-align: center;"><code>DEST = DEST + SRC</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>subq [SRC], [DEST]</code></td>
<td style="text-align: center;"><code>DEST = DEST - SRC</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>imulq [SRC], [DEST]</code></td>
<td style="text-align: center;"><code>DEST = DEST * SRC</code></td>
<td style="text-align: center;">结果取较低的 64 位截断</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>salq [SRC], [DEST]</code></td>
<td style="text-align: center;"><code>DEST = DEST &lt;&lt; SRC</code></td>
<td style="text-align: center;">与逻辑左移 <code>shll</code> 等价</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>sarq [SRC], [DEST]</code></td>
<td style="text-align: center;"><code>DEST = DEST &gt;&gt; SRC</code></td>
<td style="text-align: center;">算术右移</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>shrq [SRC], [DEST]</code></td>
<td style="text-align: center;"><code>DEST = DEST &gt;&gt; SRC</code></td>
<td style="text-align: center;">逻辑右移</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>xorq [SRC], [DEST]</code></td>
<td style="text-align: center;"><code>DEST = DEST ^ SRC</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>andq [SRC], [DEST]</code></td>
<td style="text-align: center;"><code>DEST = DEST &amp; SRC</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>orq [SRC], [DEST]</code></td>
<td style="text-align: center;"><code>DEST = DEST | SRC</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>incq [DEST]</code></td>
<td style="text-align: center;"><code>DEST = DEST + 1</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>decq [DEST]</code></td>
<td style="text-align: center;"><code>DEST = DEST - 1</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>negq [DEST]</code></td>
<td style="text-align: center;"><code>DEST = -DEST</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>notq [DEST]</code></td>
<td style="text-align: center;"><code>DEST = ~DEST</code></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h1 id="条件码与其应用">条件码与其应用</h1>
<p>当程序运行的时候，部分和当前程序运行状态相关的数据将会被 CPU 保存。我们已经介绍过指向下一条指令的程序计数器 <code>%rip</code> ，存储临时数据的寄存器堆。另外我们要提到的是被保留的寄存器 <code>%rsp</code> 其用于存储<strong>栈顶地址</strong>。另外提一下条件码，条件码一般分为四个：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">条件码标记</th>
<th style="text-align: center;">名称</th>
<th style="text-align: center;">备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>CF</code></td>
<td style="text-align: center;">Carry Flag</td>
<td style="text-align: center;">进位标记</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>ZF</code></td>
<td style="text-align: center;">Zero Flag</td>
<td style="text-align: center;">运算数为零标记</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>SF</code></td>
<td style="text-align: center;">Sign Flag</td>
<td style="text-align: center;">运算数符号标记</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>OF</code></td>
<td style="text-align: center;">Overflow Flag</td>
<td style="text-align: center;">补码运算溢出标记</td>
</tr>
</tbody>
</table>
<p>条件码一般是由算术指令运算过程中隐含地设定的，具体如何设定条件码需要查看具体的命令运行方式。这里额外指出， <strong><code>leaq</code> 指令计算的时候不设置条件码</strong>。</p>
<h2 id="推知操作数关系">推知操作数关系</h2>
<p>若干以 <code>set</code> 为前缀的命令可以读取条件码的内容并存入某寄存器的最低位字节（使用字节操作）。比如说 <code>setle</code> 命令实际上会读取 <code>SF, OF, ZF</code> 三个条件码，将 <code>(SF ^ OF) | ZF</code> 的计算结果存入指定字节。</p>
<p>这个计算结果其实就代表了两个操作数之间的一个关系。比如说 <code>cmpq [SRC], [DEST]</code> 指令在 <code>SRC == DEST</code> 的时候会将 <code>ZF</code> 置真，在 <code>DEST - SRC &lt; 0</code> 的时候将 <code>SF</code> 置真，在运算溢出的时候将 <code>OF</code> 置真。那么 <code>setle</code> 所计算的结果为真实际上就代表 <code>DEST &lt;= SRC</code> 。</p>
<p>这里给出具体示例，比如以下 C 语言代码：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gt</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt; y; &#125;</span><br></pre></td></tr></table></figure>
<p>会被汇编为：</p>
<figure class="highlight plaintext"><figcaption><span>X86-64 Assembly</span></figcaption><table><tr><td class="code"><pre><span class="line">cmpq   %rsi, %rdi</span><br><span class="line">setg   %al</span><br><span class="line">movzbl %al, %eax</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>其含义为首先使用 <code>cmpq</code> 命令更新条件码，然后使用 <code>setg</code> 命令读取条件码，最后使用 <code>movzbl</code> 将计算结果移动到表示函数返回值的寄存器。</p>
<h2 id="实现程序跳转">实现程序跳转</h2>
<p>对于 C 语言之中的 <code>if, goto</code> 等涉及到程序跳转的语句，汇编之中也应当有相应的可以跳转执行的命令，而条件码及其相关运算结果会控制程序是否跳转。与 <code>set</code> 系列命令一致，汇编之中还有 <code>j</code> 系列命令，如 <code>je</code> 。其会读取条件码并计算，结果为真则会触发程序跳转。</p>
<p>比如这样的 C 代码：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">absdiff</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) result = x - y;</span><br><span class="line">    <span class="keyword">else</span> result = y - x;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>会被汇编为：</p>
<figure class="highlight plaintext"><figcaption><span>X86-64 Assembly</span></figcaption><table><tr><td class="code"><pre><span class="line">absdiff:</span><br><span class="line">    cmpq %rsi, %rdi</span><br><span class="line">    jle  .L4</span><br><span class="line">    movq %rdi, %rax</span><br><span class="line">    subq %rsi, %rax</span><br><span class="line">    ret</span><br><span class="line">.L4:</span><br><span class="line">    movq %rsi, %rax</span><br><span class="line">    subq %rdi, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>这里第三行就会读取 <code>cmpq</code> 命令设置的条件码，如果满足了跳转条件，就会跳转到 <code>.L4</code> 标记处继续执行，否则向下继续执行。</p>
<p>实际上，汇编代码的跳转基本和 C 语言之中的 <code>goto</code> 类似，所以我们可以将 <code>if</code> 转为等价的 <code>goto</code> 表达式，这样的话就可以得到和汇编代码形式类似的 C 代码。对于以下的 C 代码：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (CASE) &#123; <span class="comment">/* IF BLOCK */</span> &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">/* ELSE BLOCK */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>实际上等价于以下 C 代码：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!CASE) <span class="keyword">goto</span> Else;</span><br><span class="line">    <span class="comment">/* IF BLOCK */</span></span><br><span class="line">    <span class="keyword">goto</span> Done;</span><br><span class="line">Else:</span><br><span class="line">    <span class="comment">/* ELSE BLOCK*/</span></span><br><span class="line">Done:</span><br></pre></td></tr></table></figure>
<div class="note info no-icon"><p>使用条件码实现程序跳转的方式称为<strong>条件跳转</strong>。但实际上，条件跳转一般会拖慢整个系统的速度。这是因为现代的流水线式处理器一般要求系统能够基本精确得知接下来应当运行的指令是什么，这样才能保证并发执行，获得高效率。</p>
<p>为了解决这个问题，一种方法是提高处理器对下面具体运行哪一个分支的预测准确率，一种方法是使用<strong>条件转移</strong>。</p>
<p>条件转移指的是将两个分支的结果都计算出来，最后再根据条件码决定取用哪一个。比如说上面的 <code>absdiff</code> 函数，现代编译器一般会把 <code>x - y</code> 和 <code>y - x</code> 都计算出来，最后根据条件码取其中一个放到返回值寄存器上。</p>
<p>但是条件转移的使用是有局限性的，比如说下面两种情况就并不适合：</p>
<ul>
<li><p>某一个分支有副作用，比如说修改了某些其他数据</p></li>
<li><p>某一个分支的计算量过于庞大</p></li>
</ul>
</div>
<p>除去 <code>if</code> ， C 语言中还可以使用 <code>switch</code> 语句实现程序跳转。 <code>switch</code> 语句可以翻译为若干的 <code>if-else</code> 组，但是更常见的解读方式是<strong>构建跳转表</strong>。</p>
<p><code>TODO</code></p>
<h2 id="实现程序循环">实现程序循环</h2>
<p>C 语言之中使用关键字 <code>do, while, for</code> 可以实现程序循环，同样我们可以使用条件码和 <code>j</code> 系列命令完成等价汇编代码编写，实际上我们只需要改写为等价的 <code>goto</code> 表达的 C 代码就可以。</p>
<p>对于 <code>do ... while</code> 循环，等价改写为：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/* do ... while */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123; <span class="comment">/* CONTENT */</span> &#125; <span class="keyword">while</span> (CASE)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* goto */</span></span><br><span class="line"></span><br><span class="line">Loop:</span><br><span class="line">    <span class="comment">/* CONTENT */</span></span><br><span class="line"><span class="keyword">if</span> (CASE) <span class="keyword">goto</span> Loop;</span><br></pre></td></tr></table></figure>
<p>对于 <code>while</code> 循环，等价改写为：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/* while */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (CASE) &#123; <span class="comment">/* CONTENT */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* goto v1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> Test;</span><br><span class="line">Loop:</span><br><span class="line">    <span class="comment">/* CONTENT */</span></span><br><span class="line">Test:</span><br><span class="line">    <span class="keyword">if</span> (CASE) <span class="keyword">goto</span> Loop;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* goto v2 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!CASE) <span class="keyword">goto</span> Done;</span><br><span class="line">Loop:</span><br><span class="line">    <span class="comment">/* CONTENT */</span></span><br><span class="line"><span class="keyword">if</span> (CASE) <span class="keyword">goto</span> Loop;</span><br><span class="line">Done:</span><br></pre></td></tr></table></figure>
<p>而 <code>for</code> 循环一般是改写为等价的 <code>while</code> 循环后再改写为 <code>goto</code> 版本：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/* for */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="comment">/* INIT */</span>; CASE; <span class="comment">/* UPDATE */</span>) &#123; <span class="comment">/* CONTENT */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* while */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* INIT */</span></span><br><span class="line"><span class="keyword">while</span> (CASE) &#123;</span><br><span class="line">    <span class="comment">/* CONTENT */</span></span><br><span class="line">    <span class="comment">/* UPDATE */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="函数调用与程序栈">函数调用与程序栈</h1>
<h2 id="程序栈和相关指令">程序栈和相关指令</h2>
<p>X86 系统中，将一片内存区域按照栈的方式管理，其中<strong>高地址为栈底</strong>，这片内存区域就被称为<strong>程序栈</strong>，其栈顶地址由寄存器 <code>%rsp</code> 管理。</p>
<p>对程序栈有两种最为基本的操作，即压栈和出栈。压栈操作命令为 <code>pushq [SRC]</code> ，含义是将 <code>[SRC]</code> 写入程序栈，寄存器 <code>%rsp</code> 减小一个字节（即减去 <code>8</code> ）。而出栈命令为 <code>popq [DEST]</code> ，含义是将程序栈栈顶字节写入 <code>[DEST]</code> ，寄存器 <code>%rsp</code> 增加一个字节（即加上 <code>8</code> ）。</p>
<h2 id="函数调用">函数调用</h2>
<p>有关函数调用的两个命令为 <code>call</code> 和 <code>ret</code> ，两者分别代指调用某一个函数和某一个函数返回。</p>
<p><strong>注解：</strong>似乎在汇编之中，更习惯把函数调用说成过程调用，我们之后也使用这样的名称。</p>
<p><code>call</code> 的命令格式为 <code>callq 40050 &lt;mul&gt;</code> 。两个参数分别为需要调用的过程的机器码在主存里的位置，系统根据这个参数令程序指针 <code>%rip</code> 跳转。第二个参数则是调用的过程的名称。</p>
<p><code>call</code> 命令一共会完成两个任务。第一个任务是将<strong>返回地址</strong>（返回地址指的是 <code>call</code> 指令<strong>下一条</strong>指令的地址）压入程序栈，这一步是为了在调用的过程终结返回的时候能够返回到正确的位置继续执行。第二个任务是将 <code>%rip</code> 设置为要跳转的过程在主存之中的地址，实现真正的跳转。</p>
<p>而 <code>ret</code> 命令所完成的就是将程序栈的栈顶写入 <code>%rip</code> ，让系统回到原先位置继续执行。其不需要接受参数，一般只需要命令本身即可。</p>
<hr />
<p>有的时候调用过程需要传递参数。在 X86 架构之下，如果传递参数不多于 6 个，则使用 <code>%rdi, %rsi, %rdx, %rcx, %r8, %r9</code> 一共 6 个寄存器进行传递。如果参数多余 6 个，则使用程序栈传递，序号越大的参数越在栈底。而函数返回值默认存放在 <code>%rax</code> 之中。</p>
<h2 id="栈帧">栈帧</h2>
<p>类似 C 之类的语言，会支持函数的递归调用，这就说明了这些语言的代码支持<strong>重入（ Reentrant ）</strong>，即允许多个实例同时运行同一块代码。基于这样的要求，我们不仅需要在程序栈之中记录返回地址，我们还需要记录是哪一个实例调用了过程。而每一次过程调用就会在程序栈之中生成一片用于记录这次调用的数据（包括这一次调用的临时变量、返回地址、寄存器副本等），这就是一个<strong>栈帧（ Stack frame ）</strong>。</p>
<p>栈帧的管理也是简单的，在过程被调用的时候分配空间、创建栈帧，在过程返回之后，该栈帧被释放。由于栈帧一般多于一个字节，所以除去栈顶指针 <code>%rsp</code> 外，还设定了栈帧指针 <code>%rbp</code> 标记栈帧的起始地址，所以 <code>%rbp</code> 和 <code>%rsp</code> 之间的程序栈指代栈顶的栈帧。</p>
<hr />
<p>另外我们也需要指出，有的时候系统会做出一些“明明没有分配栈帧（ <code>%rsp</code> 没有动）但相当于创建了临时栈帧”的行为。一种可能是使用栈空间进行数据传递，这个时候栈就类似于寄存器。比如说系统可以在不动 <code>%rsp</code> 的条件下将数据通过比 <code>%rsp</code> 低一个字节的位置传递一定的数据。但栈空间的也是有限制的，比 <code>%rsp</code> 低多于 128 字节的栈空间一般是被保留的，不能直接使用。</p>
<h2 id="寄存器使用惯例">寄存器使用惯例</h2>
<p>在一个过程调用另外一个过程的时候，往往会出现寄存器冲突，比如说两者都需要使用 <code>%rdi</code> 存放参数。这个时候一般需要将寄存器数据复制到栈帧之中暂且保存，将寄存器空出给另外一方使用。</p>
<p>而到底由调用者还是被调用者的栈帧暂存寄存器，则一般遵循一些惯例。在 X86 架构下寄存器 <code>%rbx, %rbp, %r12, %r13, %r14, %r15</code> 称为<strong>被调用者保存（ Callee saved ）</strong>寄存器，即被调用者的栈帧保存这些寄存器的数据，在<strong>过程返回之前将栈帧数据复原</strong>。寄存器 <code>%r10, %r11</code> 和所有的传递参数的寄存器称为<strong>调用者保存（ Caller saved ）</strong>寄存器，即调用者的栈帧保存寄存器的数据，在<strong>调用结束后将栈帧数据复原</strong>。</p>
<h1 id="数组及结构的存储表示">数组及结构的存储表示</h1>
<h2 id="数组的存储">数组的存储</h2>
<p>数组 <code>T a[N]</code> 在主存之中存储的基本原则为连续存储，也就是将连续 <code>N * sizeof(T)</code> 字节的空间用于存储这个数组。</p>
<p>而对于二维数组，我们还是会使用连续的存储空间进行存储，而且一般遵循<strong>行优先</strong>原则。对于 <code>int a[3][5]</code> ，其在主存之中的存储顺序为 <code>a[0][0], a[0][1], ..., a[0][4], a[1][0], ..., a[2][4]</code> 。这种存储方式称为<strong>嵌套数组（ Nested array ）</strong>。</p>
<p>除了嵌套数组，还有一种存储方式是<strong>多级指针数组（ Multi-level pointer array ）</strong>。其基本想法为在根数组上存若干指针，这些指针指向下一级数组的起始地址。这样的存储方式方便进行多级扩展，但相应的由于内存空间不连续，而且读取指针并定位需要多次寻址，一定程度上降低了效率。</p>
<h2 id="结构的存储">结构的存储</h2>
<p>一个结构体的数据是将其成员按照声明顺序，在一片连续的空间内存储的。比如说：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>[<span class="number">4</span>] val;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其将会在连续的 32 个字节中存储这个结构体，其中低地址的 16 字节存放 <code>val</code> ，中间的 8 字节存放 <code>i</code> ，高地址的 8 字节存放 <code>next</code> 。</p>
<p>而在实际存储的时候是需要考虑<strong>对齐</strong>问题的：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">align</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> val;</span><br><span class="line">    align* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果按照正常思维推测，一个字符和一个指针应该只需要 9 字节，但在 X86-64 架构下，实际上会占用 16 字节，其中低地址的 8 字节仅有最低一个字节存储了 <code>val</code> ，而剩余的为占位符。</p>
<p>原因是简单的，现代的 CPU 在从主存之中读取数据的时候是同时读取多个，比如说一次性读取 8 个字节。实际上这种读取方式就将每 8 个字节的存储空间划分为了一个机器字（机器字的定义见 <a href="#机器字和字节序">绪论</a>），如果数据在同一个机器字之中，那么一次读取就可以将所有数据读出来。但如果数据跨越了两个机器字，那么就需要两次读取。</p>
<p>所以说编译器会故意在存储结构的空间内部塞入若干的空白空间让每一个成员的数据不跨越机器字以保证读取效率。</p>
<p>另外我们也注意到，变量的声明顺序实际上会影响具体的空间分配。比如说：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    S1* next;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    S2* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里，结构 <code>S1</code> 占用 24 字节，而结构 <code>S2</code> 占用 16 字节。这是因为 <code>S1</code> 在存放 <code>a</code> 后不得不空出 7 字节，否则 <code>next</code> 就会跨机器字。而 <code>S2</code> 中可以先把 <code>a, b</code> 都放置好之后，只需要空出 6 字节就可以让 <code>next</code> 不跨机器字。</p>
<h2 id="联合数据的存储">联合数据的存储</h2>
<p>联合数据类型可以定义多个成员，但是一个联合数据类型的变量在任何时候只能指代某一个成员。这些成员享有同一片存储空间，而联合所占据的空间即其中最大成员占据的空间。比如说：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">U1</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>[<span class="number">2</span>] i;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">double</span> v;</span><br><span class="line">&#125; *p;</span><br></pre></td></tr></table></figure>
<p>这里联合的三个成员分别应该占用 1 字节、 8 字节、 8 字节，所以最后联合占据 8 字节。</p>
<h1 id="程序的链接">程序的链接</h1>
<h2 id="链接的基本概念">链接的基本概念</h2>
<p>多个源代码文件编译成为可执行文件的时候需要经过一个重要过程，即<strong>链接（ Linking ）</strong>，含义就是将各个独立的文件链接为单一的最终文件。这样做的好处是，某一个文件发生修改，只需要对这个文件编译并重新链接即可，不需要再次编译其他文件。同时，一些常用函数可以事先编译为一个库，需要使用的时候再将其链接进入最后的可执行文件即可。</p>
<p>链接之前，编译器首先会将每一个源代码文件之中每一个符号存储起来，存储的内容包括符号名称、其占据的内存大小和其在主存之中的地址，这就构成了<strong>符号表（ Symbol table ）</strong>。随后链接器将所有源代码文件综合为单个文件后，会将符号表之中的地址更新为绝对地址。</p>
<h2 id="elf-格式和符号分析">ELF 格式和符号分析</h2>
<p>可以被链接的文件一般有<strong>可重定向对象文件</strong>和<strong>共享对象文件</strong>，前者扩展名通常为 <code>.o</code> ，后者则多为 <code>.dll / .so</code> 。后者是特殊类型的重定向对象文件，可以被装载入内存后进行动态链接，其链接可以在装载时或者运行时完成。上述两种文件以及可执行文件，这三种二进制文件都必须要符合 <strong>ELF（ Executable &amp; Linkable Format ）</strong>格式。</p>
<p>ELF 格式的文件依次具有以下的部分：</p>
<ul>
<li><p>ELF header 部分。这一部分会存储与这个文件相关的基本信息。</p></li>
<li><p>Segment header table 。这一部分只有可执行文件具有，会存储一些和可执行相关的内容。</p></li>
<li><p><code>.text</code> 部分。这一部分存储代码。</p></li>
<li><p><code>.rodata</code> 部分。这一部分存储只读数据，比如说跳转表。</p></li>
<li><p><code>.data</code> 部分。这一部分存储初始化过的全局变量。</p></li>
<li><p><code>.bss</code> 部分。这一部分存储未初始化的全局变量。</p></li>
<li><p><code>.symtab</code> 部分。这一部分存储符号表。</p></li>
<li><p><code>.rel.text</code> 部分。这一部分是 <code>.text</code> 部分的重定向信息。</p></li>
<li><p><code>.rel.data</code> 部分。这一部分是 <code>.data</code> 部分的重定向信息。</p></li>
</ul>
<p>后续还有一些部分，这里暂且不用讨论。</p>
<p>这里可以提一下 <code>.bss</code> 区设立的原因。 <code>.bss</code> 区域的数据不会存储数据类型，并且会默认将这一部分数据的每一个字节全部置 <code>0x00</code> ，作为系统默认的初始化。这样做显然要比既要存储数据类型，又要存储数据初始值的 <code>.data</code> 区高效。而能够这样粗暴解决问题的原因是系统约定了非静态全局变量的默认初始化方式为全 <code>0</code> ，以及汇编并不区分各种不同的数据类型。</p>
<hr />
<p>在叙述链接过程之前，我们首先要叙述符号的概念。一个程序之中的符号分为三类，即<strong>全局符号</strong>、<strong>局部符号</strong>和<strong>外部符号</strong>。注意，这里全局符号和局部符号的区别不是全局变量和局部变量的区别。局部符号指的是在该模块定义且只可以让该模块引用的符号，包括静态和非静态的局部变量、静态函数和静态全局变量。而全局符号则是可以供给其他模块使用的符号，包括非静态的全局变量和函数。</p>
<p>首先说外部符号，其含义很简单，就是引用的其他模块的符号。包括其他模块开放的非静态全局变量和函数。可以用 <code>extern</code> 关键字声明外部符号，即声明该符号将会在链接的时候再具体给出定义，本文件只是做一个引用。</p>
<p>程序中定义的非静态局部变量，链接器并不会分析。非静态局部变量将会在运行的时候被存储在程序栈之中，使用完立刻释放。</p>
<p>而静态局部变量会被存放在可重定向文件之中的 <code>.data</code> 或者 <code>.bss</code> 部分。对于命名冲突的静态局部变量，编译的时候会给他们赋予后缀以示区分。</p>
<p>对于静态的全局变量和函数，其实际上是局部符号（ <code>static</code> 关键字限制了这些变量和函数只能在本模块之中使用），所以其存放在可重定向文件之中的 <code>.data, .bss, .text</code> 部分。其中函数存放在 <code>.data</code> 部分。而如果多个文件中声明了同名的静态全局变量和函数，并不会冲突。</p>
<p>非静态的全局变量和函数一般也是存放在 <code>.data, .bss, .text</code> 部分。这个时候也有可能出现命名冲突，但此时必须作出区分。此时需要引入<strong>强符号（ Strong symbol ）</strong>和<strong>弱符号（ Weak symbol ）</strong>的定义。这个定义只对非静态的全局变量和函数成立，其中未被初始化的非静态全局变量被称为弱符号，否则是强符号。</p>
<p>链接器的原则是：</p>
<ul>
<li><p>不允许出现强符号命名冲突，否则链接失败。</p></li>
<li><p>有强符号和弱符号的命名冲突则将弱符号的指代指向强符号（强制覆盖弱符号）。</p></li>
<li><p>弱符号之间的命名冲突，则任取其中之一作为代表，其余弱符号指向被选中的弱符号。</p></li>
</ul>
<p>由于存在强制覆盖，我们应当减少全局变量的使用，或者使用静态的全局变量。如果需要使用，尽量将其初始化变为强符号。并且在使用其他模块的全局变量的时候，尽量先使用 <code>extern</code> 关键字声明这个变量。</p>
<h2 id="代码和数据重定向">代码和数据重定向</h2>
<p>在处理完毕符号后，就可以开始链接了。现在有若干的可重定向对象文件，其中 <code>.text</code> 部分存储着代码， <code>.data</code> 部分存储着变量数据。这些文件的代码之中可能包含着函数调用，而我们知道函数调用需要知道函数在内存之中的位置。编译器在编译生成可重定向对象文件的时候有两个重要信息是不了解的：</p>
<ul>
<li><p>这个模块之中的函数最终会被存放在内存的什么地方。</p></li>
<li><p>这个模块所引用的其他模块的函数的地址是什么。</p></li>
</ul>
<p>针对第一个问题，编译器会存放<strong>相对地址</strong>，也就是这个模块之中的所有函数的地址都是相对于这个模块而言的，而不能表示最后的绝对地址。针对第二个问题，编译器可能会选择将地址留空，比如使用 <code>0x00</code> 留空，之后会在 <code>.rel.data</code> 或者 <code>.rel.text</code> 部分留下信息告诉链接器要补全这里的地址。</p>
<p>到这里，编译器的任务就完成了，接下来链接器会修正相对地址并填充留空地址。</p>
<p>首先链接器会将所有可重定向对象文件的 <code>.data</code> 部分拼接为可执行文件的 <code>.data</code> 部分， <code>.text</code> 部分也如此。拼接完成后，所有函数和全局变量的绝对地址就确定了，链接器会将所有需要调整的相对地址调整为目前的绝对地址，并填充留空地址。</p>
<h2 id="库链接">库链接</h2>
<p>我们提到过，一些常用函数会被事先编译为可重定向对象文件，在使用的时候再链接进入程序。但是一般而言这样的函数库是很大的，如果完全链接进入，则相当消耗时间空间。所以有另外一个解决方案，就是将每一个函数都打包为可重定向对象文件，然后把这些可重定向对象文件打包为<strong>静态库文件</strong>，也称<strong>归档文件（ Archive file ）</strong>。归档文件的扩展名常常为 <code>.a</code> 。</p>
<p>归档文件之中每一个可重定向对象文件是具有索引的，基于此，我们让链接器能够在用户编写的代码之中解析外部符号，并且能够在静态库之中寻找出相应的可重定向对象文件进行链接。</p>
<p>现代的静态库一般允许增量更新。</p>
<p>静态库的缺点在于可执行文件以及运行时内存之中会重复包含库文件函数和数据，同时如果库文件发生变动，则所有的相关文件都需要重新链接。目前已有的解决方式是使用<strong>共享库文件</strong>，其特征在 <a href="#elf-格式和符号分析">ELF 格式和符号分析</a> 部分已经说明。</p>
<h1 id="内存布局与缓冲区">内存布局与缓冲区</h1>
<p>在 X86-64 架构下，主存的最高地址部分是程序栈，其栈顶由 <code>%rsp</code> 管理，且栈空间向低地址增长。程序栈一般具有 8MB 的空间限制。程序栈用于存放局部变量等数据。</p>
<p>之后就是分配给每一个任务的存储空间，每一个任务都会在主存之中占用一片空间，这片空间从高地址到低地址的分配为：</p>
<ul>
<li><p>堆。堆空间可以根据程序需要动态分配，如 C 语言的 <code>malloc</code> 函数。堆空间向高地址增长。</p></li>
<li><p>静态数据。这一部分数据会在将可执行文件加载到主存的时候写入内容，写入的内容就是可执行文件的 <code>.data</code> 部分，称为<strong>数据段</strong>。</p></li>
<li><p>机器代码。这一部分就是可执行文件的 <code>.text</code> 部分，称为<strong>代码段</strong>。</p></li>
</ul>
<p>而程序栈的构成，先前已经叙述过。即分为若干的栈帧，其中栈帧高地址的 8 字节存放这个栈帧的返回地址，剩余的部分存放临时变量等数据。</p>
<hr />
<p>这个时候就可以引入缓冲区溢出攻击了。这个攻击利用的是类似 <code>gets()</code> 等不限制读入长度的函数，可能会越过预留空间对程序栈进行非法写入的漏洞。</p>
<p>比如说函数 <code>foo()</code> 之中调用了 <code>gets()</code> ：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">gets</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而函数 <code>foo()</code> 执行的时候是会分配一个栈帧给这个函数存放 <code>buf</code> 这个临时变量的。但是由于 <code>gets()</code> 不限制读入长度，所以我们可以输入相当长的字符串，这样的话就会一直向栈帧的高地址写入，从而会覆写掉返回地址，甚至是上一个函数的栈帧。这样，在 <code>foo()</code> 结束进行返回的时候，就可以控制其跳转到指定的位置执行我们注入的程序。</p>
<p>防御这种攻击的方法也很多。一种是使用可以限制读入长度的函数，如 <code>fgets()</code> 。一种是给栈内部加入随机长度的无意义数据，让攻击方无法准确预测 PC 应当跳转到何处。还有比如说可以限制执行权限，让这一片区域的内存不能作为机器指令执行。此外还可以让函数在返回之前检查栈帧是否被修改等等。</p>
<h1 id="x86-汇编编程基础">X86 汇编编程基础</h1>
<p><code>TODO</code></p>
<h1 id="异常">异常</h1>
<h2 id="基本原理">基本原理</h2>
<p><strong>异常（ Exception ）</strong>指的是会阻止程序正常执行，并且会引起状态切换（比如从用户态切换到内核态）的事件。异常分为同步异常和异步异常。</p>
<p>同步异常一般有三种，即 <strong>Trap</strong> 、 <strong>Fault</strong> 以及 <strong>Abort</strong> 。其中， Trap 一般是由程序主动触发的，比如说产生了系统调用 syscall ，或者是触发了断点或者是使用了 Trap 命令，其恢复之后会跳转到原命令的下一条继续执行。 Fault 往往是由程序出现的一些问题触发的，一般这种问题都是可以恢复的，恢复之后会重新执行原命令。 Abort 则是由不可恢复的问题触发的异常，会引起程序退出。</p>
<p>异步异常则一般由外部事件触发，比如说 IO 设备中断，发生系统重置等等。一般而言，在 MIPS 架构下，如果发生的时候命令已经执行完毕 MEM 阶段，系统会保证这条命令的流水线执行完毕。否则这条流水线会被废弃。这里有关 MIPS 流水线的叙述可以查看下面的 MIPS32 基础。</p>
<h1 id="虚拟内存">虚拟内存</h1>
<h2 id="基本原理-1">基本原理</h2>
<p>我们先前提到过，每一个进程都会分配到一片内存空间，用于存放数据段、代码段并且分配堆空间。但是我们也会注意到，有的进程用不到如此大的内存空间，很容易出现分配了空间但几乎不可能使用的现象。这个问题的一个解决方案是<strong>虚拟内存（ Virtual memory ）</strong>，其相当类似于懒分配，即真正使用到某一块内存的时候再进行分配。</p>
<p>虚拟内存的工作原理大致为，对于每一个新进程，会分配连续的虚拟内存空间。进程使用到某一个存储地址的时候，处理器会去虚存地址和物理内存地址对照表（这个表一般称为<strong>页表（ Page table ）</strong>，并且每个进程都会有自己的页表）之中寻找这个虚拟内存地址所对应的真实地址，如果发现还没有给这个虚存地址分配物理内存空间，则会分配并建立两者之间的映射。</p>
<p>虚拟内存地址通常简称为<strong>虚址（ Virtual address ）</strong>。上述过程中负责将虚址转换为物理地址的单元称为<strong>内存管理单元（ MMU ）</strong>。</p>
<h2 id="页和页缺失">页和页缺失</h2>
<p>一般而言，我们会将一片固定大小的连续虚存集合起来成为一个<strong>页（ Page ）</strong>，而每一个虚存的页映射到物理地址空间也是一片连续的空间，这被称为<strong>页帧（ Page frame ）</strong>。相对应的页和页帧具有相同的大小。 MMU 进行地址映射的时候都是以页为单位的。</p>
<p>基于页的结构，处理器实际上传输给 MMU 进行转换的虚地址可以分为两个部分。前半部分为<strong>虚页码（ Virtual page number / VPN ）</strong>，后半部分是<strong>页内偏置（ Page offset ）</strong>。虚页码指明了虚存之中我需要映射的字节位于具体哪一页，而页内偏置则表明了我需要映射的字节在页内是第几个字节。</p>
<p>MMU 所进行的页码映射就是将虚页码根据页表映射为<strong>物理页码（ Physical page number / PPN ）</strong>，之后根据页内偏置获取最后实际的数据。</p>
<p>如果某次映射之中，某个页没有找到对应的页帧，就会触发<strong>页缺失（ Page fault ）</strong>。页缺失产生后，系统会转入内核态，调用异常处理代码将所需要的数据从外部存储读入内存以解决异常。</p>
<h2 id="页表项的附加标记">页表项的附加标记</h2>
<p>采用虚存机制还有一种好处，就是可以通过页表实现权限管理。页表之中的每一项除去记录页和页帧的映射之外，还可以记录这个进程对物理内存的访问权限，权限控制的具体实现则由硬件完成。</p>
<p>另外，页表项还可以记录目前这个映射是否成立，这一位也常常被称为 valid 位。其为 <code>1</code> 则说明对应的页帧已经被加载到物理内存之中，否则代表对应的页帧还需要从外部存储之中获取。页缺失就会在 valid 位为 <code>0</code> 的时候发生。</p>
<h2 id="快表机制">快表机制</h2>
<p>记住这一句话就可以了：</p>
<div class="note info no-icon"><p>快表（ TLB ）和页表的关系，就是缓存（ Cache ）和内存的关系。</p>
</div>
<p>TLB 相当于页表的一个高速缓存，其出现的原因是处理器所请求的内存地址往往是聚集的，也就是说某一小部分地址占据了处理器的大部分请求。所以这个时候我们可以将常用地址缓存到 TLB 之中，请求内存的时候首先查询 TLB 有无相关映射，命中则直接使用。否则再去页表之中查找，命中则直接使用，同时将这个映射缓存到 TLB 之中。 TLB 满了之后会触发淘汰机制，删去使用较少的映射项。</p>
<p>之所以提到缓存，因为内存之中的常使用部分会被加载到 cache 之中。而系统从 MMU 获取物理地址之后也会先去 cache 之中查找，找不到才会去内存之中查找。这个过程和 TLB 机制几乎一致。</p>
<h2 id="内存映射">内存映射</h2>
<p><code>TODO: We may learn it later from OS class.</code></p>
<h1 id="mips32-基础">MIPS32 基础</h1>
<p>MIPS 架构的特征可以查看本文最开头的部分，有较为详细的介绍。</p>
<p>这里补充一些其他的 MIPS 基础知识。这些知识并不是重点，但是会影响对 MIPS 架构细节的理解，故不单独开一个二级标题但还是需要分点一条条列出：</p>
<ul>
<li><p>MIPS 架构之中，一个字等于四个字节</p></li>
<li><p>MIPS 架构下返回地址不保存在栈上，而是保存在 31 号寄存器之中</p></li>
<li><p>MIPS 架构下 0 号寄存器永远存储常数 <code>0</code></p></li>
<li><p>MIPS 架构不具有条件码，条件的表示全部使用寄存器</p></li>
<li><p>MIPS32 架构除去 32 个通用寄存器，还有高位寄存器 <code>%hi</code> 以及低位寄存器 <code>%lo</code> 。这两者都是 32 位寄存器，其出现的原因是需要处理整数的乘除法。另外需要注意， MIPS32 架构的立即数通常只允许 16 位，而寄存器是 32 位的，所以通常会使用这两个寄存器将 32 位数拆开表示。记号上， <code>%hi($1)</code> 这种写法代表 1 号寄存器的 16 位高位</p></li>
<li><p>MIPS 架构下有四个传参寄存器，即 4 到 7 号寄存器。多余的参数使用栈传递</p></li>
<li><p>MIPS 架构的命令后缀 <code>i</code> 表示立即数， <code>u</code> 表示不启用溢出检测。比如说 <code>addiu</code> 命令表示将某一个寄存器加上一个立即数，溢出的话取模放入结果寄存器</p></li>
</ul>
<h2 id="流水线结构与延迟槽">流水线结构与延迟槽</h2>
<p>在 MIPS 架构之中，任何指令的执行都会分为五个步骤，这五个步骤由不同的硬件完成。这些步骤分别是：</p>
<ul>
<li><p>读取指令（IF）</p></li>
<li><p>读取寄存器（RD）</p></li>
<li><p>代数或逻辑运算（ALU）</p></li>
<li><p>访问内存（MEM）</p></li>
<li><p>回写（WB）</p></li>
</ul>
<p>一个指令的五个执行步骤构成一条<strong>流水线</strong>，而不同指令的流水线是可以并发执行的，只要保证它们不会同时调用某一个硬件资源（比如说两条指令不可以同时在 IF 过程中）。</p>
<p>而这种并行的流水线架构的优越之处就是可以最大程度利用硬件资源。比如说考虑这样的 MIPS 汇编代码：</p>
<figure class="highlight plaintext"><figcaption><span>MIPS32 Assembly</span></figcaption><table><tr><td class="code"><pre><span class="line">jal  printf</span><br><span class="line">move $4, $6</span><br><span class="line">op</span><br></pre></td></tr></table></figure>
<p>这里 <code>jal</code> 类似于 X86 的 <code>call</code> 命令，用于调用过程。但是，与这条指令间隔一条的 <code>op</code> 指令才是 <code>printf</code> 返回后调用的指令（返回地址）。</p>
<p>原因是 <code>jal</code> 指令流水线执行到 ALU 阶段的时候才会发生实质跳转，从 <code>jal</code> 的 IF 阶段结束到实质跳转这段时间 IF 硬件是空闲的，这段时间就被称为<strong>延迟槽（ Delay slot ）</strong>。但是我们可以让 IF 硬件立刻执行 <code>move $4, $6</code> 的 IF 阶段，这样在实质跳转发生前的这段延迟槽就被利用了。</p>
<p>能这样做的原因是 <code>move</code> 指令在 RD 阶段结束后就执行完毕了，后续的阶段可以忽略或者说当成不存在。如果说 <code>jal</code> 命令之后跟随了一些需要实质 ALU 的命令，则可能会因为和 <code>jal</code> 或者所调用的过程发生硬件冲突而导致异常。所以有的时候我们可以填入 <code>nop</code> 回避掉可能的问题。</p>
<h2 id="多线程操作">多线程操作</h2>
<p>在多线程编程之中，我们往往会涉及到多个线程对共享资源的读写操作。在 MIPS 架构中，针对这个场景，有 <code>ll</code> 和 <code>sc</code> 两个命令。</p>
<p><code>ll</code> 全称为<strong>链接加载（ Load linked ）</strong>，在使用这个命令从内存之中加载数据之后，处理器会记住这一次操作，这一次操作访问的地址也会被暂时保存。</p>
<p><code>sc</code> 全称为<strong>条件存储（ Store conditional ）</strong>，使用这个命令将寄存器 <code>v</code> 之中的数据存储到内存的时候，处理器会首先检查上一次 <code>ll</code> 命令操作的内存区域有没有被改动。如果没有被改动过，则存储成功， <code>v</code> 之中的值也会被写为 <code>1</code> 表示操作成功。反之，写入失败，内存不会被修改， <code>v</code> 之中的值也会被写为 <code>0</code> 表示操作失败。</p>
<h2 id="协处理器与异常处理">协处理器与异常处理</h2>
<p>协处理器是用于协助处理器处理类似内存管理、内存映射、异常等工作的硬件，其在可以被认为是一系列拓展寄存器。这里我们主要关注 MIPS 架构下协处理器之中的 Cause 和 Status 寄存器。</p>
<p>MIPS 系统的一个优点就是支持精确异常处理，也就是说保证发生异常的命令之前的所有命令都可以被执行完毕，之后的命令不进行处理。而为了实现这一点，就需要精确记录异常位置，并且处理好延迟槽机制带来的问题。</p>
<p>借助协处理器， MIPS 系统处理异常的步骤大致为：</p>
<ul>
<li><p>保存异常现场信息。协处理器利用<strong>异常程序计数器（ Exception program counter / EPC ）</strong>记录异常命令的位置， Cause 寄存器会记录异常原因，且其 BD 位会记录延迟槽信息， Status 寄存器的<strong>异常标志位（ EXL ）</strong>被置 <code>1</code> 。另外，一些相关寄存器的值也会被保存，另外 26 和 27 号寄存器会被留给异常处理。</p></li>
<li><p>根据具体类型判定处理异常的方式。这里会使用 Cause 寄存器获取异常类型。</p></li>
<li><p>开辟异常处理内存空间。系统会开辟出空间并且保留一部分通用寄存器用于异常处理。</p></li>
<li><p>处理完毕后返回。此时协处理器清空相关寄存器，跳转到原有命令继续执行。</p></li>
</ul>
<p>这里要注意一点，一般异常处理会在内核态下运行，而正常的程序会在用户态下运行。为了防止异常处理机制被不正当利用于在内核态下执行攻击代码，系统要求状态转换和程序跳转回原有命令必须同时。</p>
<h2 id="mips-内存管理">MIPS 内存管理</h2>
<p>MIPS 使用虚存机制，其虚址一般按照下述方式分配：</p>
<ul>
<li><p>高于 <code>0xC0000000</code> 的虚址为 kseg2 空间，其仅可以由核心态使用，使用的时候需要经过 MMU 转换，也就是说这一部分是 Mapped memory 。</p></li>
<li><p>介于 <code>0xA0000000</code> 和 <code>0xC0000000</code> 之间的虚址是 kseg1 空间，其不可以在用户态下使用，使用的时候不需要经过 MMU 转换（其虚址最高三位清零就是物理地址）。另外，这一部分不会被缓存，也就是说这一部分是 Unmapped uncached memory 。</p></li>
<li><p>介于 <code>0x80000000</code> 和 <code>0xA0000000</code> 之间的虚址是 kseg0 空间，其不可以在用户态下使用，使用的时候不需要经过 MMU 转换（其虚址最高一位清零就是物理地址）。另外，这一部分可以被缓存，也就是说这一部分是 Unmapped cached memory 。</p></li>
<li><p>低于 <code>0x80000000</code> 的虚址为 kuseg 空间，是用户态空间，使用的时候需要经过 MMU 转换，也就是说这一部分是 Mapped memory 。</p></li>
</ul>
<p>这样划分的意图就是区分内核态和用户态对内存的访问。另外，上述划分之中有 unmapped 的内存空间，这一部分设置的缘由是系统刚启动的时候 TLB 并未初始化，不可以进行正常的地址转换，故使用 unmapped 的空间进行操作。</p>
<p>另外，为了区分某虚拟地址属于哪一个进程， MIPS 会给虚拟地址附上 ASID 进程标识符。</p>
<hr />
<p>MIPS 架构支持一种特殊的快表，即 JTLB 。其内部记录的是<strong>虚页码除以 2</strong> 之后的结果和<strong>两个</strong>物理页码之间的关系，两个映射项都标注了是否 valid 以及是否允许写入（一般称为是否 dirty ，如果一个页面不是 dirty 的，则会禁止写入）。</p>
<p>这个时候的转换需要将虚页码先去掉末位进行查表，最后如果命中，则需要根据虚页码末位选取最终的映射项。</p>
]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
  </entry>
  <entry>
    <title>《编译原理》学习笔记</title>
    <url>/1021/09/14/note-of-dc/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
  </entry>
  <entry>
    <title>《信号处理原理》学习笔记</title>
    <url>/1021/09/14/note-of-dsp/</url>
    <content><![CDATA[<p>一门纯数学课，没有什么特别有意思的地方。但也正因为它是数学课，所以我感觉我学起来会稍微轻松一些，希望是我四大原理之中最舒服的一门课。</p>
<p><span class="math display">\[
\newcommand{\d}{\mathrm{d}}
\newcommand{\j}{\mathrm{j}}
\]</span></p>
<span id="more"></span>
<h1 id="信号处理基本知识">信号处理基本知识</h1>
<p>信号是一种载有信息的物理量，所以可以说信号是信息的表现形式，信息是信号蕴含的内容。我们探测信号的工具称为<strong>传感器（ Sensor ）</strong>，传感器是将一种物理变化转化为另一种物理变化的装置。比如说为了探测声波，我们可以使用传感器将声波转化为电信号。</p>
<p>通过传感器我们可以将某些难以处理的信号转化为我们易于处理的信号。对信号的处理大致可以分为三类，即<strong>降噪</strong>、<strong>特征抽取</strong>以及<strong>编码解码</strong>。</p>
<p>信号常常使用函数或者序列进行描述，而函数具有图像，所以有的时候信号也会使用具体的图像进行描述。</p>
<hr />
<p>信号可以按照对于给定的自变量能不能得到确定的因变量分类为<strong>确定信号</strong>和<strong>随机信号</strong>。另外，信号 <span class="math inline">\(f(t)\)</span> 也可以按照是否存在 <span class="math inline">\(T &gt; 0\)</span> 满足 <span class="math inline">\(\forall t \in \mathbb R, f(t) = f(t + T)\)</span> 分为<strong>周期信号</strong>和<strong>非周期信号</strong>。</p>
<h2 id="常见信号形式">常见信号形式</h2>
<p><strong>正余弦信号</strong>是最常见的信号形式之一，其数学表达式为：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; f(t) = K \sin(\omega t + \theta) \\
&amp; f(t) = K \cos(\omega t + \theta) \\
\end{aligned}
\]</span></p>
<p>这里 <span class="math inline">\(K\)</span> 表示<strong>振幅</strong>， <span class="math inline">\(\omega\)</span> 表示<strong>角频率</strong>， <span class="math inline">\(\theta\)</span> 表示<strong>初相位</strong>。</p>
<hr />
<p>除去正弦余弦信号， <strong>Sa 信号</strong>也是常见的一种信号形式，其数学表达式为：</p>
<p><span class="math display">\[
{\rm Sa}(t) = \frac{\sin t}{t}
\]</span></p>
<p>这个信号是一个偶函数，其零点构成的集合为 <span class="math inline">\(\{ k\pi \mid k \in \mathbb Z, k \neq 0 \}\)</span> 。这个信号的积分性质为：</p>
<p><span class="math display">\[
\int_{-\infty}^{+\infty} {\rm Sa}(t) \d t = \pi
\]</span></p>
<p>这个积分一般被称为 <strong>Dirichlet 积分</strong>，其一种计算方式可以看下列推导。</p>
<p>考虑函数：</p>
<p><span class="math display">\[
F(t) = \int_{0}^{+\infty} \frac{\sin x}{x} e^{-tx} \d x
\]</span></p>
<p>这个函数的导数可以描述为：</p>
<p><span class="math display">\[
\frac{\d F}{\d t} = \frac\d{\d t} \int_{0}^{+\infty} \frac{\sin x}{x} e^{-tx} \d x = \int_{0}^{+\infty} \frac{\partial e^{-tx}}{\partial t} \frac{\sin x}{x} \d x = -\int_{0}^{+\infty} e^{-tx}\sin x \d x
\]</span></p>
<p>进一步：</p>
<p><span class="math display">\[
\begin{aligned}
\frac{\d F}{\d t} &amp;= \int_{0}^{+\infty} e^{-tx} \d \cos x = \left. e^{-tx}\cos x \right|_{0}^{+\infty} + t \int_{0}^{+\infty} e^{-tx}\cos x \d x \\
&amp;= -1 + t \int_{0}^{+\infty} e^{-tx} \d \sin x = -1 + t \left( \left. e^{-tx}\sin x \right|_{0}^{+\infty} + t \int_{0}^{+\infty} e^{-tx}\sin x \d x \right) \\
&amp;= -1 + t^2 \int_{0}^{+\infty} e^{-tx}\sin x \d x = -1 - t^2 \frac{\d F}{\d t}
\end{aligned}
\]</span></p>
<p>也就是说：</p>
<p><span class="math display">\[
\frac{\d F}{\d t} = -\frac{1}{1 + t^2} \Rightarrow F(t) = -\arctan t + C
\]</span></p>
<p>不难得知 <span class="math inline">\(F(+\infty) = 0\)</span> ，这就说明 <span class="math inline">\(C = \pi / 2\)</span> ，从而 Dirichlet 积分的结果为：</p>
<p><span class="math display">\[
\int_{-\infty}^{+\infty} {\rm Sa}(t) \d t = 2F(0) = \pi
\]</span></p>
<hr />
<p>此外，<strong>指数信号</strong>也较为常见，其数学表达式为：</p>
<p><span class="math display">\[
f(t) = K e^{\alpha t}
\]</span></p>
<p>指数信号的特征就是，其积分或微分后依然是指数信号。</p>
<h2 id="复信号分析">复信号分析</h2>
<p>在分析一般的信号的时候，我们可以常常将其看作某一个复信号的实部或者虚部。比如说考虑复指数信号 <span class="math inline">\(f(t) = K e^{st}\)</span> ，这里 <span class="math inline">\(s \in \mathbb C\)</span> 。显然有：</p>
<p><span class="math display">\[
f(t) = K e^{[\Re(s) + \j\Im(s)]t} = K e^{(\Re s)t} (\cos(t\Im(s)) + \j\sin(t\Im(s)))
\]</span></p>
<p>这里可以发现，<strong>复指数信号的实部和虚部都是正余弦信号</strong>。</p>
<h2 id="函数空间与函数分解">函数空间与函数分解</h2>
<p>我们继续沿用线性空间的基向量、正交向量组、正交基和标准正交基的概念。现在我们考虑这样的一个线性空间，即定义在 <span class="math inline">\([t_1, t_2]\)</span> 上的可积复函数空间，定义其内积为：</p>
<p><span class="math display">\[
\langle\varphi_1, \varphi_2\rangle = \int_{t_1}^{t_2} \varphi_1(t)\varphi^*_2(t) \d t
\]</span></p>
<p>两函数如果内积为零，则称两函数<strong>正交</strong>。</p>
<p>如果函数 <span class="math inline">\(\varphi_1, \varphi_2, \cdots, \varphi_n\)</span> 满足：</p>
<p><span class="math display">\[
\langle\varphi_i, \varphi_j\rangle = \int_{t_1}^{t_2} \varphi_i(t)\varphi^*_j(t) \d t = \begin{cases}
0 &amp; i \neq j \\
k_i &amp; i = j
\end{cases}
\]</span></p>
<p>这里 <span class="math inline">\(k_i\)</span> 为非零常数。那么这些函数构成<strong>正交函数集</strong>。</p>
<p>称一个正交函数集是完备的，如果不存在一个这个函数集之外的函数 <span class="math inline">\(\psi\)</span> 满足 <span class="math inline">\(0 &lt; \psi \cdot \psi &lt; +\infty\)</span> 且 <span class="math inline">\(\psi\)</span> 和该函数集之中所有函数正交。实际上完备的正交函数集就说明了这个函数集不能容纳更多的成员。</p>
<h1 id="信号的运算">信号的运算</h1>
<h2 id="常规运算">常规运算</h2>
<p>对于信号 <span class="math inline">\(f_1, f_2\)</span> ，我们可以仿照函数四则运算的规定来规定其四则运算方式：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; (f_1 + f_2)(t) = f_1(t) + f_2(t) \\
&amp; (f_1 - f_2)(t) = f_1(t) - f_2(t) \\
&amp; (f_1 \cdot f_2)(t) = f_1(t) \cdot f_2(t) \\
&amp; \left(\frac{f_1}{f_2}\right)(t) = \frac{f_1(t)}{f_2(t)}
\end{aligned}
\]</span></p>
<p>另外，我们还可以对信号进行波形变换。常见的变换包括<strong>平移变换</strong>、<strong>反褶变换</strong>、<strong>压扩变换</strong>。</p>
<p>考虑平移变换：</p>
<p><span class="math display">\[
\begin{aligned}
f &amp;\mapsto f&#39; \\
f(t) &amp;\to f(t - b)\\
\end{aligned}
\]</span></p>
<p>这个变换可以将信号的波形沿着横轴（时间轴）正向平移 <span class="math inline">\(b\)</span> 个单位。</p>
<p>反褶变换指的是下述的变换：</p>
<p><span class="math display">\[
\begin{aligned}
f &amp;\mapsto f&#39; \\
f(t) &amp;\to f(-t)\\
\end{aligned}
\]</span></p>
<p>这个变换会将信号沿着纵轴翻折。</p>
<p>而压扩变换指的是：</p>
<p><span class="math display">\[
\begin{aligned}
f &amp;\mapsto f&#39; \\
f(t) &amp;\to f(at)\\
\end{aligned}
\]</span></p>
<p>参数 <span class="math inline">\(a\)</span> 控制了压扩的形式。如果 <span class="math inline">\(a &gt; 0\)</span> ，则压扩的时候不需要反褶。如果 <span class="math inline">\(a &lt; 0\)</span> ，则压扩的时候需要反褶。如果 <span class="math inline">\(|a| &gt; 1\)</span> ，则变换是压缩。如果 <span class="math inline">\(|a| &lt; 1\)</span> ，则变换是扩张。</p>
<h2 id="积分微分运算与能量">积分微分运算与能量</h2>
<p>对于符合一定条件的信号，我们可以进行微分积分运算，记号为：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \left(\frac{\d}{\d t} f\right)(t_0) = \left.\frac{\d f}{\d t}\right|_{t = t_0} \\
&amp; \left(\int_{-\infty} f \d t\right)(t_0) = \int_{-\infty}^{t_0} f(t) \d t
\end{aligned}
\]</span></p>
<p>基于积分微分运算，我们可以给定信号能量和信号功率的定义。对于连续空间（即定义在全实数上）的信号 <span class="math inline">\(f(t)\)</span> ，能量定义为：</p>
<p><span class="math display">\[
E(f) = \int_{-\infty}^{+\infty} \|f(t)\|^2 \d t
\]</span></p>
<p>功率则是能量除以时间，但是考虑到时间范围是无穷大的，所以需要从极限进行定义：</p>
<p><span class="math display">\[
P(f) = \lim_{T\to+\infty}\frac{1}{T}\int_{-T / 2}^{T / 2} \|f(t)\|^2 \d t
\]</span></p>
<p>对于离散空间定义的信号 <span class="math inline">\(f\)</span> ，表达类似：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; E(f) = \sum_{n = -\infty}^{+\infty} \|f(n)\|^2 \\
&amp; P(f) = \lim_{N\to\infty}\frac{1}{2N + 1} \sum_{n = -N}^{N} \|f(n)\|^2
\end{aligned}
\]</span></p>
<p>能量有限的信号称为能量有限信号，或在不引起混淆的时候简称<strong>能量信号</strong>。功率有限的信号称为功率有限信号，或在不引起混淆的时候简称<strong>功率信号</strong>。</p>
<h2 id="卷积运算">卷积运算</h2>
<p>对于两个连续时间信号 <span class="math inline">\(f, g\)</span> ，定义两者的卷积为：</p>
<p><span class="math display">\[
(f * g)(t) = \int_{-\infty}^{+\infty} f(t - \tau)g(\tau) \d\tau
\]</span></p>
<p>卷积的存在性取决于上述积分是否存在，并且要求积分结果是有限的。</p>
<p>而对于离散的时间信号 <span class="math inline">\(f, g\)</span> ，卷积定义为：</p>
<p><span class="math display">\[
(f * g)(n) = \sum_{m = -\infty}^{+\infty} f(n - m)g(m)
\]</span></p>
<p>从几何意义上讲，卷积指的是一个信号的反褶信号在时间轴上滑动的过程中，它与另外一个信号重合部分相乘得到的新信号的面积。</p>
<p>卷积显然符合下述运算律：</p>
<p><span class="math display">\[
\begin{cases}
f_1 * f_2 = f_2 * f_1 \\
f_1 * (f_2 + f_3) = f_1 * f_2 + f_1 * f_3 \\
(f_1 * f_2) * f_3 = f_1 * (f_2 * f_3)
\end{cases}
\]</span></p>
<p>卷积和微分积分运算的关系则为：</p>
<p><span class="math display">\[
\frac{\d}{\d t}(f_1 * f_2) = f_1 * \left(\frac{\d}{\d t} f_2\right) = \left(\frac{\d}{\d t} f_1\right) * f_2
\]</span></p>
<p>以及：</p>
<p><span class="math display">\[
\int_{-\infty} (f_1 * f_2) \d t = f_1 * \left(\int_{-\infty} f_2 \d t\right) = \left(\int_{-\infty} f_1 \d t\right) * f_2
\]</span></p>
<p>对于高阶微分积分，存在下述关系：</p>
<p><span class="math display">\[
(f_1 * f_2)^{(n)} = f_1^{(m)} * f_2^{(n - m)}
\]</span></p>
<p>上标括号中若为正整数，则表示高阶微分。若为负整数，则表示高阶积分。可以发现上述卷积的积分微分运算规律均为该公式的特殊情况。</p>
<h2 id="相关运算">相关运算</h2>
<p>定义两个信号的相关为：</p>
<p><span class="math display">\[
R(f_1, f_2)(t) = \int_{-\infty}^{+\infty} f_1(\tau)f_2^*(\tau - t)\d\tau = \int_{-\infty}^{+\infty} f_1(\tau + t)f_2^*(\tau)\d\tau
\]</span></p>
<p>显然可以注意到：</p>
<p><span class="math display">\[
\begin{cases}
R(f_1, f_2) = \mathcal{R}[R^*(f_2, f_1)] \\
R(f_1, f_2) = f_1 * \mathcal{R}^*[f_2]
\end{cases}
\]</span></p>
<p>这里 <span class="math inline">\(\mathcal{R}\)</span> 表示反褶变换，即 <span class="math inline">\(\mathcal{R}[f](t) = f(-t)\)</span> 。</p>
<p>第一条定律说明了相关运算并不是交换的。</p>
<h1 id="常用奇异信号">常用奇异信号</h1>
<p>我们已经介绍过正弦余弦信号、指数信号等常用信号，另外还有一些形式较为特殊的信号称为奇异信号。这些信号的价值一般在于具有一些较为优越的运算特性。</p>
<p>首先介绍<strong>单位斜变信号</strong>，数学形式为：</p>
<p><span class="math display">\[
R(t) := \begin{cases}
0 &amp; t &lt; 0 \\
t &amp; t \geq 0
\end{cases}
\]</span></p>
<p>另外常用的还有<strong>截顶单位斜变信号</strong>：</p>
<p><span class="math display">\[
R_\tau(t) := \begin{cases}
0 &amp; t &lt; 0 \\
t &amp; 0 \leq t &lt; \tau \\
\tau &amp; t \geq \tau
\end{cases}
\]</span></p>
<p>从单位斜变信号衍生得到<strong>单位阶跃信号</strong>：</p>
<p><span class="math display">\[
u(t_0) = \frac{\d R}{\d t}(t_0) := \begin{cases}
0 &amp; t_0 &lt; 0 \\
1 &amp; t_0 \geq 0
\end{cases}
\]</span></p>
<p>进而可以衍生出<strong>单位矩形脉冲信号</strong>：</p>
<p><span class="math display">\[
G_\tau(t) := \begin{cases}
1 &amp; |t| \leq \tau / 2 \\
0 &amp; |t| &gt; \tau / 2
\end{cases}
\]</span></p>
<p>矩形脉冲信号和阶跃信号具有下述的关系：</p>
<p><span class="math display">\[
G_\tau(t) = u\left(t + \frac{\tau}{2}\right) - u\left(t - \frac{\tau}{2}\right)
\]</span></p>
<p>单位矩形脉冲信号的一个重要作用是作<strong>窗函数</strong>以截取某信号的某一段信息。对于信号 <span class="math inline">\(f\)</span> ，将其与单位矩形脉冲信号作乘法得到 <span class="math inline">\(G_\tau f\)</span> 。该信号仅有 <span class="math inline">\([-\tau / 2, \tau / 2]\)</span> 上的信息被保留，其余均为零。也就是说单位矩形脉冲信号进行了信息截取。</p>
<hr />
<p>单位阶跃信号另外一种衍生是<strong>符号函数信号</strong>：</p>
<p><span class="math display">\[
{\rm sgn}(t) := \begin{cases}
1 &amp; t \geq 0 \\
-1 &amp; t &lt; 0
\end{cases}
\]</span></p>
<p>该信号和单位阶跃信号的关系是：</p>
<p><span class="math display">\[
{\rm sgn}(t) = 2u(t) - 1
\]</span></p>
<hr />
<p>对单位阶跃信号求导即可得到<strong>单位冲激信号</strong> <span class="math inline">\(\delta\)</span> ，其定义为：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_{-\infty}^{+\infty} \delta(t) \d t = 1 \\
&amp; \delta(t) = 0 (t \neq 0)
\end{aligned}
\]</span></p>
<p>更一般的冲激信号可以用单位冲激信号定义，对于在 <span class="math inline">\(t_0\)</span> 处冲激，强度为 <span class="math inline">\(E\)</span> 的冲激信号，其表达式为：</p>
<p><span class="math display">\[
\delta_{E, t_0}(t) = E\delta(t - t_0)
\]</span></p>
<p>另外一种定义方式是利用单位矩形脉冲信号取极限，也就是保证全实数集上积分为 <span class="math inline">\(1\)</span> 的条件下令取非零值的区间尽可能小：</p>
<p><span class="math display">\[
\delta = \lim_{\tau\to 0}\frac{G_\tau}{\tau}
\]</span></p>
<p>冲激信号具有下述压扩性质：</p>
<p><span class="math display">\[
\delta(at) = \frac{1}{|a|}\delta(t) (a \neq 0)
\]</span></p>
<p>冲激信号的一个特征就是<strong>搬移特性</strong>：</p>
<p><span class="math display">\[
f * \delta_{1, t_0} = \mathcal{S}_{t_0}[f]
\]</span></p>
<p>这里 <span class="math inline">\(\mathcal{S}_{t_0}\)</span> 表示平移变换，即 <span class="math inline">\(\mathcal{S}_{t_0}[f](t) = f(t - t_0)\)</span> 。</p>
<p>上述的平移会将 <span class="math inline">\(f\)</span> 原先的原点平移到冲激信号的冲激点处。</p>
<p>证明则可以直接根据卷积的定义：</p>
<p><span class="math display">\[
(f * \delta_{1, t_0})(t) = \int_{-\infty}^{+\infty}f(t - \tau)\delta_{1, t_0}(\tau)\d\tau = f(t - t_0) = \mathcal{S}_{t_0}[f](t)
\]</span></p>
<p>与搬移特性原理类似的是<strong>筛选特性</strong>，也就是冲激信号和信号乘积的积分会得到该信号在冲激点处的值：</p>
<p><span class="math display">\[
\int_{-\infty}^{+\infty}f(t)\delta(t - t_0)\d t = f(t_0)
\]</span></p>
<h1 id="信号分解">信号分解</h1>
<h2 id="基本分解">基本分解</h2>
<p>对于信号 <span class="math inline">\(f\)</span> ，我们可以将其分解为直流分量和交流分量，我们规定交流分量的积分为零，即：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; f_{\rm DC}(t) = \lim_{T\to+\infty}\frac{1}{T}\int_{-T / 2}^{T / 2}f(t)\d t \\
&amp; f_{\rm AC}(t) = f(t) - f_{\rm DC}(t) \\
\end{aligned}
\]</span></p>
<p>此外，还有奇偶分解：</p>
<p><span class="math display">\[
\begin{aligned}
f_e(t) = \frac{f(t) + f(-t)}{2} \\
f_o(t) = \frac{f(t) - f(-t)}{2} \\
\end{aligned}
\]</span></p>
<p>以及实虚分解：</p>
<p><span class="math display">\[
\begin{aligned}
f_r(t) = \frac{f(t) + f^*(t)}{2} \\
f_i(t) = \frac{f(t) - f^*(t)}{2\j} \\
\end{aligned}
\]</span></p>
<p>上述分解都是严格的，但下述的脉冲分解则是一种近似分解。脉冲分解的思想是把信号分解为若干个矩形脉冲的和，在 <span class="math inline">\([t_0, t_0 + \Delta t]\)</span> 区间上，信号 <span class="math inline">\(f\)</span> 可以近似表示为：</p>
<p><span class="math display">\[
f(t) \approx f(t_0)[u(t - t_0) - u(t - t_0 - \Delta t)]
\]</span></p>
<p>将这些脉冲求和，则得到了信号 <span class="math inline">\(f\)</span> 的一个近似表达。</p>
<h2 id="正交分解概述">正交分解概述</h2>
<p>下述讨论均基于函数平方可积的性质。如果函数 <span class="math inline">\(f\)</span> 满足：</p>
<p><span class="math display">\[
\int_{-\infty}^{+\infty} f^2(t) \d t &lt; +\infty
\]</span></p>
<p>那么函数 <span class="math inline">\(f\)</span> 平方可积。所有的平方可积函数构成函数空间 <span class="math inline">\(\mathcal{L}^2(\mathbb{R})\)</span> 。</p>
<p>此外，依然沿用先前的函数内积、正交、完备正交函数集等定义。</p>
<hr />
<p>我们考虑 <span class="math inline">\([t_1, t_2]\)</span> 上的完备正交函数集 <span class="math inline">\(\{\varphi_i\}\)</span> 以及函数 <span class="math inline">\(f\)</span> ，其正交分解为：</p>
<p><span class="math display">\[
f = \sum_{k = 1}^{+\infty} c_k\varphi_k
\]</span></p>
<p>显然我们可以得到（这一步求解系数的变换称为 Karhunen-Loeve 变换）：</p>
<p><span class="math display">\[
c_k = \frac{\langle f, \varphi_k \rangle}{\langle \varphi_k, \varphi_k \rangle}
\]</span></p>
<p>据此，可以证明 Parseval 恒等式：</p>
<p><span class="math display">\[
E(f) = \int_{t_1}^{t_2} \|f(t)\|^2 \d t = \sum_{k = 1}^{+\infty} \langle \varphi_k, \varphi_k \rangle\|c_k\|^2 = \sum_{k = 1}^{+\infty} E(c_k\varphi_k)
\]</span></p>
<p>这个定理表明，在正交分解下，信号的能量等于各个分量能量的和。其证明只需要进行展开就可得到：</p>
<p><span class="math display">\[
\begin{aligned}
\int_{t_1}^{t_2} \|f\|^2 \d t &amp;= \int_{t_1}^{t_2} \left\|\sum_{k = 1}^{+\infty} c_k\varphi_k(t)\right\|^2 \d t = \int_{t_1}^{t_2} \left(\sum_{k = 1}^{+\infty} c_k\varphi_k(t)\right)\left(\sum_{k = 1}^{+\infty} c_k\varphi_k(t)\right)^* \d t \\
&amp;= \int_{t_1}^{t_2} \left(\sum_{k = 1}^{+\infty} c_k\varphi_k(t)\right)\left(\sum_{k = 1}^{+\infty} c_k^*\varphi_k^*(t)\right) \d t \\
&amp;= \int_{t_1}^{t_2} \left(\sum_{k = 1}^{+\infty} c_kc_k^*\varphi_k(t)\varphi_k^*(t) + \sum_{i\neq j} c_ic_j^*\varphi_i(t)\varphi_j^*(t)\right) \d t \\
&amp;= \sum_{k = 1}^{+\infty} \|c_k\|^2 \int_{t_1}^{t_2} \varphi_k(t)\varphi_k^*(t) \d t = \sum_{k = 1}^{+\infty} \langle \varphi_k, \varphi_k \rangle\|c_k\|^2
\end{aligned}
\]</span></p>
<div class="note info"><p>你说我展开没考虑连续、可导、收敛啥的？我们工科生不懂这些。</p>
</div>
<p>将信号展开为完全正交函数集的线性组合的过程即函数正交分解，求解线性组合系数的过程为<strong>信号变换</strong>。</p>
<h2 id="周期信号的正交分解">周期信号的正交分解</h2>
<p>现在考虑满足 Dirichlet 条件的周期信号 <span class="math inline">\(f\)</span> 。 Dirichlet 条件指的是：</p>
<ul>
<li><p>在一个周期内间断点有限</p></li>
<li><p>在一个周期内极值点有限</p></li>
<li><p>在一个周期内绝对值积分有限</p></li>
</ul>
<p>我们考虑下述两个常见的完备正交函数集，这里 <span class="math inline">\(\omega = 2\pi / T\)</span> ， <span class="math inline">\(T\)</span> 是 <span class="math inline">\(f\)</span> 的周期，下述函数集在任意的长度为 <span class="math inline">\(T\)</span> 的闭区间上正交完备：</p>
<ul>
<li><p>三角函数集 <span class="math inline">\(\{1, \cos(n\omega t), \sin(n\omega t): n \in \mathbb{N}^+\}\)</span></p></li>
<li><p>指数函数集 <span class="math inline">\(\{e^{\j n\omega t}: n \in \mathbb{Z}\}\)</span></p></li>
</ul>
<p>在这两个基底下展开得到的线性组合式可以理解为一个无穷级数，这个无穷级数就是<strong>傅里叶级数（ Fourier series ）</strong>。两个函数集得到的傅里叶级数分别称为三角形式的傅里叶级数和指数形式的傅里叶级数。</p>
<p>三角形式的傅里叶级数表示为：</p>
<p><span class="math display">\[
f(t) = a_0 + \sum_{k = 1}^{+\infty} (a_n\cos(n\omega t) + b_n\sin(n\omega t))
\]</span></p>
<p>不难根据先前的论证得到系数的计算公式，这里 <span class="math inline">\(t_0\)</span> 为任意实数：</p>
<p><span class="math display">\[
\begin{aligned}
a_0 &amp;= \frac{\omega}{2\pi} \int_{t_0}^{t_0 + 2\pi / \omega} f(t) \d t \\
a_n &amp;= \frac{\omega}{\pi} \int_{t_0}^{t_0 + 2\pi / \omega} f(t)\cos(n\omega t) \d t \\
b_n &amp;= \frac{\omega}{\pi} \int_{t_0}^{t_0 + 2\pi / \omega} f(t)\sin(n\omega t) \d t \\
\end{aligned}
\]</span></p>
<p>指数形式的傅里叶级数表示为：</p>
<p><span class="math display">\[
f(t) = \sum_{k = -\infty}^{+\infty} F_ke^{\j k\omega t}
\]</span></p>
<p>其中有：</p>
<p><span class="math display">\[
F_k = \frac{\omega}{2\pi} \int_{t_0}^{t_0 + 2\pi / \omega} f(t)e^{-\j k\omega t} \d t
\]</span></p>
<div class="note info"><p>两个形式的傅里叶级数的适用范围均是全实数，但实际上这只是因为 <span class="math inline">\(f\)</span> 是周期的。</p>
<p>严格意义上说，由于我们给定的正交函数集只是在某个长度为 <span class="math inline">\(T\)</span> 的闭区间上正交，所以展开的傅里叶级数也只应当在这个闭区间上可用。但是由于周期性，我们可以简单地说明闭区间外这个级数表达依然成立。</p>
<p>这个区分是有必要的，因为严格意义上，在计算 <span class="math inline">\(f\)</span> 的能量、功率等数值的时候，积分区间均应该是长度为 <span class="math inline">\(T\)</span> 的闭区间。</p>
</div>
<p>三角形式和指数形式的傅里叶级数之间的关系可以考虑下述变形：</p>
<p><span class="math display">\[
\begin{aligned}
f(t) &amp;= a_0 + \sum_{k = 1}^{+\infty} (a_n\cos(n\omega t) + b_n\sin(n\omega t)) \\
&amp;= a_0 + \sum_{k = 1}^{+\infty} \left(a_n\frac{e^{\j n\omega t} - e^{-\j n\omega t}}{2\j} + b_n\frac{e^{\j n\omega t} + e^{-\j n\omega t}}{2}\right) \\
&amp;= a_0 + \sum_{k = 1}^{+\infty} \left(-\j a_n\frac{e^{\j n\omega t} - e^{-\j n\omega t}}{2} + b_n\frac{e^{\j n\omega t} + e^{-\j n\omega t}}{2}\right) \\
&amp;= a_0 + \sum_{k = 1}^{+\infty} \left(\frac{b_n - \j a_n}{2} e^{\j n\omega t} + \frac{b_n + \j a_n}{2} e^{-\j n\omega t}\right) \\
\end{aligned}
\]</span></p>
<p>也就是说这两者之间是等价的，并且可以据此发现上述系数计算公式之间的关系。</p>
<p>据此，我们也可以得到，如果周期信号 <span class="math inline">\(f\)</span> 是偶函数，那么其指数形式 FS 系数为实数序列。如果为奇函数，则为纯虚数序列。</p>
<hr />
<p>考虑 Parseval 定律在 FS 上的应用，显然有（注意积分区间是长度为 <span class="math inline">\(T\)</span> 的闭区间）：</p>
<p><span class="math display">\[
P(f) = \sum_{k = -\infty}^{+\infty} \|F_k\|^2 = \|a_0\|^2 + \frac12 \sum_{k = 1}^{+\infty}(\|a_k\|^2 + \|b_k\|^2)
\]</span></p>
<h2 id="频谱">频谱</h2>
<h3 id="频谱的定义">频谱的定义</h3>
<p>现在默认 FS 使用指数形式的。考虑系数序列 <span class="math inline">\(\{F_n \in \mathbb C\}_{-\infty &lt; n &lt; +\infty}\)</span> 。以频率为横轴，将频率所对应的 FS 系数的模为该处的频谱值，即可做出信号的幅度频谱。如果以 FS 系数的辐角作为该处的频谱值，则得到相位频谱。两个频谱合并就可以表现出该信号所有的 FS 系数的信息。</p>
<p>我们思考 FS 系数的意义，事实上 FS 系数作为线性组合的系数，代表了被分解信号中某一个频率的成分的多少。从而这就意味着，频谱表现的是信号在频率意义上的构成。</p>
<p>不过注意，由于指数形式的 FS 之中包含 <span class="math inline">\(e^{-\j n\omega t}(n\in \mathbb{N}^+)\)</span> 项，其频率为负数 <span class="math inline">\(-n\omega\)</span> ，所以信号的频谱图上会出现负频率。</p>
<p>我们可以断定频谱的一些性质：</p>
<ul>
<li><p>频谱是离散的，且只会在 <span class="math inline">\(n\omega(n\in \mathbb Z)\)</span> 点处存在值</p></li>
<li><p>幅度频谱图是关于纵轴对称的，而相位频谱是关于原点对称的，这是由于 <span class="math inline">\(F_k\)</span> 与 <span class="math inline">\(F_{-k}\)</span> 共轭。</p></li>
</ul>
<p>现在我们考虑一个重要周期信号的频谱，即周期矩形脉冲。</p>
<p>假设某一周期矩形脉冲信号 <span class="math inline">\(f\)</span> 周期为 <span class="math inline">\(T_0 = 2\pi / \omega_0\)</span> ，在区间 <span class="math inline">\([-T_0 / 2, T_0 / 2]\)</span> 上定义为：</p>
<p><span class="math display">\[
f(t) = \begin{cases}
E &amp; |t| \leq \tau_0 / 2 \\
0 &amp; |t| &gt; \tau_0 / 2
\end{cases}
\]</span></p>
<p>这里 <span class="math inline">\(E &gt; 0\)</span> 且 <span class="math inline">\(\tau_0 &lt; T_0\)</span> 。</p>
<p>其 FS 系数是显然的：</p>
<p><span class="math display">\[
F_k = \frac{\omega_0}{2\pi} \int_{-\pi / \omega_0}^{\pi / \omega_0} f(t)e^{-\j k\omega_0 t} \d t = \frac{E\omega_0}{2\pi} \int_{-\tau_0 / 2}^{\tau_0 / 2} e^{-\j k\omega_0 t} \d t = \frac{E\omega_0\tau_0}{2\pi}\frac{\sin(\omega_0 k\tau_0 / 2)}{\omega_0 k\tau_0 / 2}
\]</span></p>
<p>也就是：</p>
<p><span class="math display">\[
F_k = \frac{E\omega_0\tau_0}{2\pi}{\rm Sa}\left(\frac{\omega_0 k\tau_0}{2}\right)
\]</span></p>
<p>这个结果说明了，周期矩形脉冲信号的频谱具有包络线：</p>
<p><span class="math display">\[
F(\omega) = \frac{E\omega_0\tau_0}{2\pi}{\rm Sa}\left(\frac{\omega\tau_0}{2}\right)
\]</span></p>
<h3 id="带宽">带宽</h3>
<p>事实上我们注意到，大多的信号幅度频谱在高频区域取值很小，这也就说明大多信号在高频区域几乎不具有能量。</p>
<p>实际应用中，在失真可忽略的条件下，信号传递可以只传递低频分量（一般而言取频谱包络线最小绝对值的零点以内的分量），这一段区间的长度称为<strong>频带宽度</strong>，简称<strong>带宽</strong>。</p>
<h2 id="非周期信号的正交分解和频谱">非周期信号的正交分解和频谱</h2>
<p>任何非周期信号 <span class="math inline">\(f\)</span> 实际上都可以看成周期无穷大的周期信号。我们考虑周期为 <span class="math inline">\(T\)</span> 的周期信号 <span class="math inline">\(f_T\)</span> ，其在周期 <span class="math inline">\([-T / 2, T / 2)\)</span> 上定义为 <span class="math inline">\(f_T(t) = f(t), t \in [-T / 2, T / 2)\)</span> 。实际上可以得到：</p>
<p><span class="math display">\[
\lim_{T \to +\infty} f_T = f
\]</span></p>
<div class="note info"><p>我们没有定义过一个函数列如何收敛为一个函数，故这样的表述并非严谨。</p>
<p>后续很多证明也仅仅是形式化的，其作用仅仅是形成对定律的直观理解，请不要将这些推导用于严谨的证明之中。</p>
</div>
<p>考虑 <span class="math inline">\(f_T\)</span> 的傅里叶级数，如果令 <span class="math inline">\(\omega = 2\pi / T\)</span> ，显然有：</p>
<p><span class="math display">\[
\begin{aligned}
f_T(t) &amp;= \sum_{k = -\infty}^{+\infty} F_k e^{\j k\omega t} = \sum_{k = -\infty}^{+\infty} \left(\frac{1}{T}\int_{-T / 2}^{T / 2} f_T(\tau)e^{-\j k\omega\tau} \d\tau\right)e^{\j k\omega t}
\end{aligned}
\]</span></p>
<p>考虑离散频谱中相邻谱线之间的间隔，即 <span class="math inline">\(\Delta\omega = \omega = \dfrac{2\pi}{T}\)</span> ，在 <span class="math inline">\(T \to +\infty\)</span> 的时候谱线间隔 <span class="math inline">\(\Delta\omega \to 0\)</span> ，那么我们有：</p>
<p><span class="math display">\[
\begin{aligned}
f(t) &amp;= \lim_{T \to +\infty} f_T(t) = \lim_{T \to +\infty} \sum_{k = -\infty}^{+\infty} \left(\frac{1}{T}\int_{-T / 2}^{T / 2} f_T(\tau)e^{-\j k\omega\tau} \d\tau\right)e^{\j k\omega t} \\
&amp;= \frac{1}{2\pi} \lim_{\Delta\omega \to 0} \sum_{k = -\infty}^{+\infty} \left(\int_{-T / 2}^{T / 2} f_T(\tau)e^{-\j k\omega\tau} \d\tau\right)e^{\j k\omega t} \Delta\omega
\end{aligned}
\]</span></p>
<p>现在我们定义：</p>
<p><span class="math display">\[
\begin{aligned}
F_T(x) &amp;= \int_{-T / 2}^{T / 2} f_T(\tau)e^{-\j x\tau} \d\tau \\
F(x) &amp;= \int_{-\infty}^{+\infty} f(\tau)e^{-\j x\tau} \d\tau
\end{aligned}
\]</span></p>
<p>显然有：</p>
<p><span class="math display">\[
\lim_{\Delta\omega \to 0} F_T = F
\]</span></p>
<p>该定义下，可以有：</p>
<p><span class="math display">\[
f(t) = \frac{1}{2\pi} \lim_{\Delta\omega \to 0} \sum_{k = -\infty}^{+\infty} F_T(k\omega) e^{\j k\omega t} \Delta\omega
\]</span></p>
<p>下一步则是将该极限转写为积分。但我们注意这样的一点，即 <span class="math inline">\(\Delta\omega\)</span> 在变动的时候，被积函数 <span class="math inline">\(F_T\)</span> 本身也在变动。按照严格的数学理论，这里我们应当严格说明收敛性。但我们只需要直观理解，具体的证明则省略：</p>
<p><span class="math display">\[
f(t) = \frac{1}{2\pi} \lim_{\Delta\omega \to 0} \sum_{k = -\infty}^{+\infty} F_T(k\omega) e^{\j k\omega t} \Delta\omega = \frac{1}{2\pi} \int_{-\infty}^{+\infty} F(\omega) e^{\j\omega t} \d\omega
\]</span></p>
<hr />
<p>上述推导中，我们实际上已经给出了一个函数 <span class="math inline">\(F(\omega)\)</span> 和信号 <span class="math inline">\(f(t)\)</span> 之间的关系：</p>
<p><span class="math display">\[
\begin{aligned}
f(t) &amp;= \frac{1}{2\pi} \int_{-\infty}^{+\infty} F(\omega) e^{\j\omega t} \d\omega \\
F(\omega) &amp;= \int_{-\infty}^{+\infty} f(t)e^{-\j\omega t} \d t
\end{aligned}
\]</span></p>
<p>这里我们可以给出函数 <span class="math inline">\(F(\omega)\)</span> 的一个理解，我们将其和 FS 比较：</p>
<p><span class="math display">\[
\begin{aligned}
f(t) &amp;= \sum_{k = -\infty}^{+\infty} F_ke^{\j k\omega t} \\
f(t) &amp;= \frac{1}{2\pi} \int_{-\infty}^{+\infty} F(\omega) e^{\j\omega t} \d\omega \\
\end{aligned}
\]</span></p>
<p>可以发现上述用 <span class="math inline">\(F(\omega)\)</span> 推出 <span class="math inline">\(f(t)\)</span> 的公式实际上类似于将 <span class="math inline">\(f\)</span> 表达为正交函数的线性组合，只不过这里的正交函数集是无穷集。这里 <span class="math inline">\(F(\omega)\)</span> 实际上相当于信号 <span class="math inline">\(f(t)\)</span> 的频谱，即其频域表现。</p>
<p>由 <span class="math inline">\(f\)</span> 推出 <span class="math inline">\(F\)</span> 的过程就称为<strong>傅立叶变换（ Fourier transformation ）</strong>，简称 FT 。反过来由 <span class="math inline">\(F\)</span> 推出 <span class="math inline">\(f\)</span> 则称为<strong>傅立叶逆变换</strong>，简称 IFT 。标记为：</p>
<p><span class="math display">\[
F = \mathcal{F}[f], f = \mathcal{F}^{-1}[F]
\]</span></p>
]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
  </entry>
  <entry>
    <title>《 GAMES101 》学习笔记</title>
    <url>/2021/10/16/note-of-games101/</url>
    <content><![CDATA[<p>这门课是万恶的安主席推荐的，但毕竟已经进入渲染这个计算机方向，这门课必然是首先需要学明白的课程。总之现在这个笔记，既可以是我自己的学习笔记，也是图形学兴趣小组的整理笔记，也可以是技能引导文档，同时也是目前实验室的工作。属于是真的赢麻了。</p>
<span id="more"></span>
<p><span class="math display">\[
\newcommand{\b}{\boldsymbol}
\newcommand{\lv}{\left(\begin{matrix}}
\newcommand{\rv}{\end{matrix}\right)}
\]</span></p>
<h2 id="课程简介">课程简介</h2>
<p>本课程主要分为四个部分，即光栅化、曲线与曲面、光线追踪、动画仿真。</p>
<p><strong>光栅化（ Rasterization ）</strong>指的是将三维图形实时显示在二维平面上。在图形学中， 30 FPS 就可以认为是实时的，低于这个帧率的则认为是离线渲染。</p>
<p><strong>光线追踪（ Ray tracing ）</strong>指的是像每一个像素发射光，令光线不断反射。这样的技术能够让渲染更加真实，但是效率会更低。使用光线追踪是效果和效率的 Trade-off 。</p>
<h3 id="图形学与计算机视觉">图形学与计算机视觉</h3>
<p>从二维图像和三维模型的角度出发，我们认为一切以三维模型为起点的都是<strong>计算机图形学（ Computer graphics ）</strong>的范畴，而所有从二维图像为起点的都是<strong>计算机视觉（ Computer vision ）</strong>。特别的，从三维模型出发获得二维图像的称为<strong>渲染（ Rendering ）</strong>，从三维模型出发获得新的三维模型的可以是<strong>模拟（ Simulation ）</strong>。但是上述的分类也是粗糙而模糊的。</p>
<h2 id="线性代数回顾">线性代数回顾</h2>
<div class="note success"><p>这里我们默认大家线性代数都挺好的。</p>
</div>
<p>首先明确记号，向量 <span class="math inline">\(\b{a}\)</span> 的长度标记为 <span class="math inline">\(\|\b{a}\|\)</span> 。与向量 <span class="math inline">\(\b{a}\)</span> 同方向的单位向量标记为 <span class="math inline">\(\hat{\b{a}}\)</span> ，其满足：</p>
<p><span class="math display">\[
\hat{\b{a}} = \frac{\b{a}}{\|\b{a}\|}
\]</span></p>
<p>向量的加减运算、点乘和叉乘运算省略。</p>
<p>另外，该课程明确向量默认为列向量，比如说二维向量表示为：</p>
<p><span class="math display">\[
\b{a} = \lv x \\ y \rv
\]</span></p>
<p>在这个标记下，三维向量的叉乘可以表示为：</p>
<p><span class="math display">\[
\b{a} = \lv x_a \\ y_a \\ z_a \rv, \b{b} = \lv x_b \\ y_b \\ z_b \rv \Rightarrow \b{a}\times\b{b} = \lv y_az_b - y_bz_a \\ z_ax_b - x_az_b \\ x_ay_b - y_ax_b \rv
\]</span></p>
<p>此外还需要正交基、矩阵的基本计算等基本知识。</p>
<h2 id="齐次坐标系统">齐次坐标系统</h2>
<p>矩阵可以用于描述线性变换，常见的线性变换包括缩放、反射、切变、旋转。但是注意，在图形学中有一个常见变换并不能简单用矩阵表述，即<strong>平移变换</strong>，其不满足一般的线性变换定义（变换不保原点）。考虑下述二维空间平移：</p>
<p><span class="math display">\[
\begin{cases}
x&#39; = x + t_x \\
y&#39; = y + t_y \\
\end{cases}
\]</span></p>
<p>实际上一种解决方式是给点和向量的表述添加一个维度。我们将向量 <span class="math inline">\(\b{a} = \lv x \\ y \rv\)</span> 转换为下述标记：</p>
<p><span class="math display">\[
\b{a} = \lv x \\ y \\ 0 \rv
\]</span></p>
<p>将点 <span class="math inline">\(A(x, y)\)</span> 转换为下述标记：</p>
<p><span class="math display">\[
A = \lv x \\ y \\ 1 \rv
\]</span></p>
<p>并且人为规定第三维度必须归一化，即：</p>
<p><span class="math display">\[
\lv x \\ y \\ w \rv := \lv x / w \\ y / w \\ 1 \rv(w \neq 0)
\]</span></p>
<p>在这种标记下，向量的线性运算得到的依然是向量，点与点的差得到向量，点与点的和得到中点，向量和点的线性运算得到点。这些性质都是符合直觉的。</p>
<p>那么上述的平移变换（变换均指的是对点的变换）在这个标记下就可以表示为：</p>
<p><span class="math display">\[
\lv x&#39; \\ y&#39; \\ 1 \rv = \lv 1 &amp; 0 &amp; t_x \\ 0 &amp; 1 &amp; t_y \\ 0 &amp; 0 &amp; 1 \rv \lv x \\ y \\ 1 \rv
\]</span></p>
<p>实际上，上述所有的变换均可以被统一表示为：</p>
<p><span class="math display">\[
\lv x&#39; \\ y&#39; \\ 1 \rv = \lv a &amp; b &amp; t_x \\ c &amp; d &amp; t_y \\ 0 &amp; 0 &amp; 1 \rv \lv x \\ y \\ 1 \rv
\]</span></p>
<p>这些变换统称<strong>仿射变换（ Affine transformation ）</strong>，仿射变换即对某一个点先进行线性变换后再平移的一类变换（考虑到变换复合没有交换律，注意顺序不能变）。仿射变换的矩阵具有一定的结构，即左上角的子阵表示除去平移之外的变换对应的矩阵，右侧的一列则代表平移量。</p>
<p>这种添加维度以表示平移的坐标系统为<strong>齐次坐标</strong>。</p>
<h3 id="三维旋转">三维旋转</h3>
<p>这里着重介绍 Rodrigue 旋转公式，考虑绕轴 <span class="math inline">\(\b{n}\)</span> 逆时针旋转 <span class="math inline">\(\alpha\)</span> ，这个变换的矩阵可以表示为：</p>
<p><span class="math display">\[
\b{R}(\b{n}, \alpha) = \cos\alpha \b{I} + (1 - \cos\alpha) \b{n}\b{n}^T + \sin\alpha\lv
0 &amp; -n_z &amp; n_y \\
n_z &amp; 0 &amp; -n_x \\
-n_y &amp; n_x &amp; 0 \\
\rv
\]</span></p>
<p>这是一个三阶矩阵，构成的是齐次坐标意义下的变换矩阵的左上角子阵。</p>
<h2 id="mvp-变换">MVP 变换</h2>
<p>我们的渲染过程一般分为三个部分，即 Modeling 、 View 和 Projection ，这一整个变换过程就是 MVP 变换。</p>
<p>Modeling 一般可以认为是定义相机的位置的过程，定义相机需要三个量：</p>
<ul>
<li><p>位置矢量（ Position ） <span class="math inline">\(\b{e}\)</span></p></li>
<li><p>相机朝向（ Gaze direction ） <span class="math inline">\(\hat{\b{g}}\)</span></p></li>
<li><p>向上方向（ Up direction ） <span class="math inline">\(\hat{\b{t}}\)</span></p></li>
</ul>
<p>位置矢量定义了相机的位置，之后需要使用相机朝向定义观测方向，但是除此之外，我们需要使用向上方向定义相机最后的旋转形态（同一位置且朝向相同的相机依然有一个旋转自由度）。</p>
<p>另外，我们考虑到如果相机和物体进行了完全一致的变换，那么最后渲染结果不应当变化。所以说我们默认 Modeling 最后的结果为：</p>
<ul>
<li><p>相机在原点</p></li>
<li><p>相机朝向 <span class="math inline">\(-z\)</span> ，向上方向为 <span class="math inline">\(y\)</span></p></li>
</ul>
<p>相机定位完毕后（即 Modeling 完成后），后续所有对物体的变换均需要对相机进行同样的变换。</p>
<hr />
<p>现在推导 Modeling 变换的矩阵，考虑原先的相机形态为 <span class="math inline">\((\b{e}, \hat{\b{g}}, \hat{\b{t}})\)</span> 。</p>
<p>Modeling 过程可以这样考虑，即首先将相机平移到原点，随后旋转调整相机。平移的矩阵显然是：</p>
<p><span class="math display">\[
\b{T}_v = \lv
1 &amp; 0 &amp; 0 &amp; -x_e \\
0 &amp; 1 &amp; 0 &amp; -y_e \\
0 &amp; 0 &amp; 1 &amp; -z_e \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\rv
\]</span></p>
]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
  </entry>
  <entry>
    <title>《人工智能导论》学习笔记</title>
    <url>/1021/06/16/note-of-iai/</url>
    <content><![CDATA[<p>这个文档就是一时兴起想要好好学学人工智能背后的玩意创建的。主要还是记录《人工智能导论》课程的笔记。</p>
<span id="more"></span>
<p>大概随着这个文档越来越饱满，我应该就能看懂<code>paper.md</code>这个诡异的超纲文档了。</p>
<h2 id="搜索问题">搜索问题</h2>
<h3 id="盲目搜索bfs-dfs">盲目搜索（BFS / DFS）</h3>
<p>DFS 优先扩展深度深的节点， BFS 优先扩展深度浅的节点。由于 DFS 往往存在深度限制，所以 DFS 是有可能找不到最优解的，并且最坏情况下 DFS 等价于枚举。而 BFS 在<strong>单位耗散值的有解问题</strong>上一定能找到最优解。</p>
<p>但有的时候搜索树上的相邻节点之间距离并非一致，所以出现了 Dijkstra 算法。这个算法是最短路算法之中较为重要的一个。在 Dijkstra 算法之中，原则是优先扩展<strong>距离起点最近的节点</strong>。</p>
<p>Dijkstra 算法考虑了当前节点与起点的距离，但是实则没有对距离终点的距离进行评估。所以之后可以引入启发式搜索。</p>
<h3 id="启发式搜索a-a">启发式搜索（A / A*）</h3>
<p>所谓启发式，就是引入<strong>启发知识</strong>，也就是对当前节点与目标之间的距离的评估。</p>
<p>在 A 算法之中，我们引入对节点 <span class="math inline">\(n\)</span> 的<strong>评估函数</strong> <span class="math inline">\(f(n)\)</span> ：</p>
<p><span class="math display">\[
f(n) = g(n) + h(n)
\]</span></p>
<p>这里 <span class="math inline">\(h(n)\)</span> 就是对当前节点与目标之间距离的评估，也被称为<strong>启发函数</strong>。</p>
<p>上述函数均为<strong>估计值</strong>。我们把相应的实际值（也就是最短路所对应的）分别标记为 <span class="math inline">\(f^*(n), g^*(n), h^*(n)\)</span> 。</p>
<p>A 算法的核心为，优先扩展 <span class="math inline">\(f(n)\)</span> 最小的节点。</p>
<p>在算法的具体实现过程之中，定义了<code>OPEN</code>表以及<code>CLOSE</code>表，分别代表<strong>当前考虑扩展的节点</strong>以及<strong>当前暂时不考虑扩展的节点</strong>。一份伪代码实现为：</p>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line">OPEN = [<span class="string">&#x27;s&#x27;</span>] <span class="comment"># &#x27;s&#x27; is the starting node</span></span><br><span class="line">CLOSE = []</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> OPEN.empty():</span><br><span class="line">    <span class="comment"># Select the node with minimum f value</span></span><br><span class="line">    n = OPEN.node_with_min_f()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># n is the expected node</span></span><br><span class="line">    <span class="keyword">if</span> expected(n):</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    </span><br><span class="line">    OPEN.remove(n)</span><br><span class="line">    CLOSE.add(n)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Traverse the neighbors</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> n.neighbor():</span><br><span class="line">        path_len = g(n) + distance(n, m)</span><br><span class="line">        <span class="comment"># Expand the list</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> m <span class="keyword">in</span> OPEN) <span class="keyword">and</span> (<span class="keyword">not</span> m <span class="keyword">in</span> CLOSE):</span><br><span class="line">            OPEN.add(m)</span><br><span class="line">            n.<span class="built_in">next</span> = m</span><br><span class="line">        <span class="comment"># m has been explored before, but it needs update</span></span><br><span class="line">        <span class="keyword">elif</span> (m <span class="keyword">in</span> OPEN) <span class="keyword">and</span> (path_len &lt; g(m)):</span><br><span class="line">            g(m) = path_len</span><br><span class="line">            n.<span class="built_in">next</span> = m</span><br><span class="line">        <span class="comment"># m has been discarded, but it can be reused now</span></span><br><span class="line">        <span class="keyword">elif</span> (m <span class="keyword">in</span> CLOSE) <span class="keyword">and</span> (path_len &lt; g(m)):</span><br><span class="line">            CLOSE.remove(m)</span><br><span class="line">            OPEN.add(m)</span><br><span class="line">            n.<span class="built_in">next</span> = m</span><br><span class="line"><span class="comment"># Fail</span></span><br><span class="line"><span class="keyword">return</span> FAIL</span><br></pre></td></tr></table></figure>
<p>在 A 算法之中，如果满足：</p>
<p><span class="math display">\[
h(n) \leq h^*(n)
\]</span></p>
<p>那么 A 算法就称为 A* 算法。 A* 算法的特点就在于<strong>只要初始节点到目标节点有路径，那么算法永远能找到最优解</strong>，而 A 算法并不保证有最优解。</p>
<p>另外给出一个定理：</p>
<blockquote>
<p>对于两个 A* 算法 <span class="math inline">\(A_1, A_2\)</span> ，如果对于非目标节点均满足：</p>
<p><span class="math display">\[
h_2(n) &gt; h_1(n)
\]</span></p>
<p>那么 <span class="math inline">\(A_1\)</span> 所扩展的节点数不小于 <span class="math inline">\(A_2\)</span> 所扩展的节点数。</p>
</blockquote>
<h3 id="改进-a-算法">改进 A* 算法</h3>
<p>A* 算法面临的一个问题在于<strong>可能会多次扩展同一个节点</strong>，这就导致了算法的低效，而实际上多次扩展某一个节点的原因在于扩展该节点所使用的路径并非是最短的。</p>
<p>我们可以认为可以使用<strong>单调的</strong>启发函数来解决这一问题，启发函数的单调性指的是三角形法则：</p>
<p><span class="math display">\[
\begin{cases}
    h(n_i) - h(n_j) \leq {\rm distance}(n_i, n_j) \\
    h(t) = 0
\end{cases}
\]</span></p>
<p>这里 <span class="math inline">\(n_j\)</span> 为 <span class="math inline">\(n_i\)</span> 的子节点。</p>
<p>我们可以证明如果 <span class="math inline">\(h\)</span> 是单调的，那么使用这个启发函数的 A* 算法一旦扩展到了某一个节点 <span class="math inline">\(n\)</span> ，就已经找到了从起点到这个节点的最短路，也就是说 <span class="math inline">\(g(n) = g^*(n)\)</span> 。</p>
<p>实际上还有一个结论，就是满足单调性的 <span class="math inline">\(h\)</span> 必然满足 A* 条件。</p>
<p>基于此改进 A* 算法如下（伪代码表示）：</p>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line">OPEN = [<span class="string">&#x27;s&#x27;</span>] <span class="comment"># &#x27;s&#x27; is the starting node</span></span><br><span class="line">CLOSE = []</span><br><span class="line">f_max = <span class="number">0</span> <span class="comment"># The maximum f value that has been found till now</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> OPEN.empty():</span><br><span class="line">    <span class="comment"># Find the nodes in OPEN with f value less than f_max</span></span><br><span class="line">    NEST = OPEN.with_f_less_than(f_max)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Select the node</span></span><br><span class="line">    <span class="comment"># When the f value has been small enough to be selected into NEST</span></span><br><span class="line">    <span class="comment"># We just need to select the minimum g value now</span></span><br><span class="line">    n = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> NEST.empty():</span><br><span class="line">        n = OPEN.node_with_min_f()</span><br><span class="line">        f_max = f(n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        n = NEST.node_with_min_g()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># n is the expected node</span></span><br><span class="line">    <span class="keyword">if</span> expected(n):</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    </span><br><span class="line">    OPEN.remove(n)</span><br><span class="line">    CLOSE.add(n)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Traverse the neighbors</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> n.neighbor():</span><br><span class="line">        path_len = g(n) + distance(n, m)</span><br><span class="line">        <span class="comment"># Expand the list</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> m <span class="keyword">in</span> OPEN) <span class="keyword">and</span> (<span class="keyword">not</span> m <span class="keyword">in</span> CLOSE):</span><br><span class="line">            OPEN.add(m)</span><br><span class="line">            n.<span class="built_in">next</span> = m</span><br><span class="line">        <span class="comment"># m has been explored before, but it needs update</span></span><br><span class="line">        <span class="keyword">elif</span> (m <span class="keyword">in</span> OPEN) <span class="keyword">and</span> (path_len &lt; g(m)):</span><br><span class="line">            g(m) = path_len</span><br><span class="line">            n.<span class="built_in">next</span> = m</span><br><span class="line">        <span class="comment"># m has been discarded, but it can be reused now</span></span><br><span class="line">        <span class="keyword">elif</span> (m <span class="keyword">in</span> CLOSE) <span class="keyword">and</span> (path_len &lt; g(m)):</span><br><span class="line">            CLOSE.remove(m)</span><br><span class="line">            OPEN.add(m)</span><br><span class="line">            n.<span class="built_in">next</span> = m</span><br><span class="line"><span class="comment"># Fail</span></span><br><span class="line"><span class="keyword">return</span> FAIL</span><br></pre></td></tr></table></figure>
<h2 id="博弈问题对抗搜索">博弈问题（对抗搜索）</h2>
<h3 id="alpha-beta-剪枝"><span class="math inline">\(\alpha-\beta\)</span> 剪枝</h3>
<p>我们在面临双方博弈，需要我方决策的时候，我们可以先搜索一遍所有可能的双方情况并使用专家知识对局面进行评估。由于对方有利就是我方不利，所以在搜索到最底部回溯得到估值的时候，要注意并不是始终取孩子节点的最大值，而是按层数交替取最大值和最小值。</p>
<p>一般而言，根节点要取最大的儿子节点（一般用方形节点代表<strong>极大过程</strong>），下一层要取最小的儿子节点（一般用圆形节点代表<strong>极小过程</strong>），以此类推。</p>
<p>所谓剪枝，就是目前遍历到此，发现继续遍历子节点都不会更新这个节点的估值了，此时就可以剪枝。注意，判定是否剪枝的时候是要和<strong>当前节点的所有祖先</strong>都进行比较的，不能只比较父节点。</p>
<p>不过要注意，在最后给出根节点估值后确定最后决策的时候，<strong>只能沿着决策树走一步</strong>。这是因为你做出决策后决策树可能会改变形态，不能保证后面的决策的估值情况还保证如此。</p>
<h3 id="蒙特卡罗方法">蒙特卡罗方法</h3>
<p><span class="math inline">\(\alpha-\beta\)</span> 剪枝依赖于大量的专家知识，所以在实际应用上也有所局限。其基本的思路是在给定的时限之内不断通过模拟对弈的方式扩展搜索树，最后再给定走步方式。</p>
<p>基本的循环包括以下几个部分：</p>
<ul>
<li>根据前期评估结果选取最有希望的叶子节点</li>
<li>在该叶子节点处随机进行一步，扩展出新叶子节点</li>
<li>从新叶子节点开始随机模拟对弈直到判定出胜负</li>
<li>根据模拟的结果反向更新决策树上各个节点的评估值</li>
</ul>
<p>一般而言，节点的评估值包含两个方面：</p>
<ul>
<li>当前信息下节点是有希望的</li>
<li>深度较浅的节点具有更大的探索可能</li>
</ul>
<p>一般而言可以选择这样的评估方式：</p>
<p><span class="math display">\[
I_j = \overline{X_j} + c\sqrt{\frac{2\ln n}{T_j(n)}}
\]</span></p>
<p>这里 <span class="math inline">\(\overline{X_j}\)</span> 表示经过当前节点的决策路径的胜率，这是一个守成的选项。</p>
<p><span class="math inline">\(n\)</span> 表示当前搜索总次数， <span class="math inline">\(T_j(n)\)</span> 表示当前节点访问次数。</p>
<h2 id="高级搜索">高级搜索</h2>
<h3 id="局部搜索">局部搜索</h3>
<p>局部搜索的意思就是一直往更好的地方走，具体过程为：</p>
<ul>
<li>选择初始点 <span class="math inline">\(x_0\)</span> ，以及其相邻可考察点集 <span class="math inline">\(P\)</span> ；</li>
<li>只要不满足退出条件，进行下面循环：
<ul>
<li>选择 <span class="math inline">\(P&#39; \subset P\)</span> ，取 <span class="math inline">\(P&#39;\)</span> 之中最优解 <span class="math inline">\(x_b\)</span> ；</li>
<li>如果 <span class="math inline">\(x_b\)</span> 更优，则切换为考察 <span class="math inline">\(x_b\)</span> ， <span class="math inline">\(P\)</span> 修改为 <span class="math inline">\(x_b\)</span> 的相邻考察点集；</li>
<li>否则 <span class="math inline">\(P = P - P&#39;\)</span> ；</li>
</ul></li>
<li>输出结果。</li>
</ul>
<h3 id="模拟退火算法">模拟退火算法</h3>
<p>模拟退火实际上是对局部搜索的一个优化。其基本原理来自于液态金属凝固的时候如果降温过快则有可能由于分子没有充分时间排列为结晶态而导致凝固不工整（没有达到最低能状态），而实际工艺会让温度缓慢下降，并且有回升温度的可能，保证大概率凝固为结晶态。</p>
<p>迁移到局部搜索上，为了防止落入局部最小值，我们可以让“温度回升”是一个有概率发生的事情。对于评估函数 <span class="math inline">\(E(i)\)</span> ，以及两个状态 <span class="math inline">\(p,q\)</span> ，给出从 <span class="math inline">\(p\)</span> 迁移到 <span class="math inline">\(q\)</span> 的概率：</p>
<p><span class="math display">\[
P(p \rightarrow q) = \begin{cases}
1 &amp; E(q) \leq E(p) \\
\exp\left(\dfrac{E(p) - E(q)}{kT}\right) &amp; E(q) &gt; E(p) \\
\end{cases}
\]</span></p>
<p>这里 <span class="math inline">\(k\)</span> 是一个常量， <span class="math inline">\(T\)</span> 是“温度”，指的是优化问题之中的控制参数。</p>
<p>根据物理定律（ Boltzmann 分布）实际上我们可以给出定律：</p>
<ul>
<li>同一温度下，物体处于低能量状态的概率高于高能量状态；</li>
<li>温度无限高的时候，物体等概率处于任何状态；</li>
<li>温度无限低的时候，物体等概率处于任何最低能状态；</li>
<li>温度下降的时候，物体进入低能量状态概率上升，进入高能量状态概率下降。</li>
</ul>
<p>所以我们使用模拟退火方法的时候需要尽可能保证：</p>
<ul>
<li>初始能量足够高；</li>
<li>每个温度下状态交换足够充分；</li>
<li>温度的下降足够缓慢。</li>
</ul>
<p>所以算法的基本思路就是：</p>
<ul>
<li>选定初始状态；</li>
<li>随机选定初始状态的某一个相邻状态，考察它和初始状态的评估函数差：
<ul>
<li>如果新状态更优，直接迁移；</li>
<li>如果原状态更优，则按照概率迁移；</li>
</ul></li>
<li>迁移完毕后降温，重复上述迁移步骤直到寻找到满意的状态。</li>
</ul>
<p>这里有些细节的问题需要考量。</p>
<p>首先是<strong>什么是满意的状态</strong>，一般而言最简单的就是设定温度阈值或者降温次数阈值，另外一个是如果多次降温都没有能够让评估函数的变化超过阈值就可以认为稳定了。</p>
<p>其次是<strong>什么时机降温</strong>，上述算法框架之中每次迁移完毕就会降温，但实际上有的时候会进行若干次迁移后才会降温。一般而言我们可以设定迁移次数阈值。</p>
<p>之后是<strong>怎么降温</strong>。等比例降温是最简单的，另外还有一个较为常用的：</p>
<p><span class="math display">\[
t_{k + 1} = \frac{t_k}{1 + \frac{t_k\ln(1 + \delta)}{3\sigma_{t_k}}}
\]</span></p>
<p>最后是<strong>初始温度如何设定</strong>。一般而言较高就可以了。</p>
<h3 id="遗传算法">遗传算法</h3>
<p>遗传算法的本质就是模拟生物进化的过程，通过引入交叉、变异等干扰因素尝试在若干代迭代后获得满意的结果。不过我们首先关注最为重要的<strong>选优</strong>过程的模拟。</p>
<p>考虑一个包含 <span class="math inline">\(N\)</span> 个个体的群体，其中第 <span class="math inline">\(i\)</span> 个个体的适应值为 <span class="math inline">\(F(x_i)\)</span> ，那么在进化过程中其被选中的概率为：</p>
<p><span class="math display">\[
p(x_i) = \frac{F(x_i)}{\sum_{j = 1}^N F(x_j)}
\]</span></p>
<p>之后就可以模拟选优，过程为：</p>
<ul>
<li>从 <span class="math inline">\(x_1\)</span> 开始，以 <span class="math inline">\(p(x_1)\)</span> 的概率选择 <span class="math inline">\(x_1\)</span> 。若选中，结束模拟，否则继续；</li>
<li>转到 <span class="math inline">\(x_2\)</span> ，以 <span class="math inline">\(p(x_1) + p(x_2)\)</span> 的概率选择 <span class="math inline">\(x_2\)</span> 。若选中，结束模拟，否则继续；</li>
<li>......</li>
<li>结束模拟</li>
</ul>
<p>这是选出一个染色体的方式，下面介绍如何选出一个群体：</p>
<p>对于每一个个体 <span class="math inline">\(x_i\)</span> ，我们用上述方法在 <span class="math inline">\(N\)</span> 个个体之中选取 <span class="math inline">\(\lfloor p(x_i)N\rfloor\)</span> 次。之后按照 <span class="math inline">\(p(x_i)N - \lfloor p(x_i)N\rfloor\)</span> 从大到小排序群体，再取若干个让选出的群体恰好有 <span class="math inline">\(N\)</span> 个个体。</p>
<p>这种方法就是模拟了群体的一次进化，高适应的个体就有高可能得到繁殖（被多次取到）。</p>
<p>另外，交叉和变异则是对表示状态的二进制（或者十进制）数字串进行一定处理。</p>
<p>从而就有了遗传算法的基本框架：</p>
<ul>
<li>给定群体规模 <span class="math inline">\(N\)</span> ，交叉概率 <span class="math inline">\(p_c\)</span> 以及变异概率 <span class="math inline">\(p_m\)</span> ；</li>
<li>随机生成 <span class="math inline">\(N\)</span> 个染色体作为初始群体，并计算适应值；</li>
<li>下面不断重复循环直到找到合适的解：
<ul>
<li>选优出 <span class="math inline">\(N\)</span> 个染色体成为扩展群体；</li>
<li>按照 <span class="math inline">\(p_c,p_m\)</span> 进行交叉和变异，未变化的染色体保留，形成新群体；</li>
</ul></li>
<li>选取整个进化过程中最适应的染色体作为最后输出。</li>
</ul>
<p>不过我们注意，我们一定要<strong>选取合适的编码方式</strong>，否则可能会因为问题的状态难以描述而导致编码串有过多无用位，从而导致无效变异。</p>
<p>二进制的交叉和变异是简单的，十进制的交叉可以如此：</p>
<ul>
<li>子代 1 的交叉位之后的基因从父代 2 的所有基因之中按顺序取出尚未在子代 1 之中基因；</li>
<li>指定若干的欠缺位，让父代 2 这些位置留空，之后按照父代1的顺序把原来的数字填回去形成子代 2 ；</li>
<li>指定一个一一对应的映射，以生成子代。</li>
</ul>
<p>变异则可以：</p>
<ul>
<li>指定两个位置，将后面的数字移到前面的指定位置之前；</li>
<li>指定两个位置，交换两个位置上的基因；</li>
<li>随意打乱某一区间。</li>
</ul>
<h2 id="统计机器学习">统计机器学习</h2>
<h3 id="基本概念">基本概念</h3>
<p>现实中的预测问题都可以归纳为在函数空间 <span class="math inline">\(H = \{f \mid f: X \rightarrow Y\}\)</span> 之中寻找最优的预测函数。这里 <span class="math inline">\(X\)</span> 是输入集，其中的元素一般表示预测的基础（已知信息）。而 <span class="math inline">\(Y\)</span> 是输出集，其中的元素一般表示需要预测的结果。</p>
<p>我们假设 <span class="math inline">\(f \in H\)</span> 为最优函数，也就是我们要寻找的。一般这个函数不会已知，但我们可以知道若干对输入输出组 <span class="math inline">\((x_i, y_i)\)</span> 满足 <span class="math inline">\(f(x_i) = y_i \pm {\rm noise}\)</span> （ <span class="math inline">\({\rm noise}\)</span> 指的是可能出现的数据扰动）。这些输入输出组构成<strong>训练集</strong>。</p>
<p>统计机器学习的目标就是根据训练集，按照某种算法尝试找一个 <span class="math inline">\(g \in H\)</span> ，让 <span class="math inline">\(g\)</span> 尽可能表现类似 <span class="math inline">\(f\)</span> 。</p>
<p>统计机器学习可以按照监督的介入分为：</p>
<ul>
<li>监督学习</li>
<li>无监督学习</li>
<li>半 / 弱监督学习</li>
</ul>
<p>监督学习事实上更贴近我们上述的统计机器学习定义，其又可以被分为<strong>回归</strong>（如线性回归、二次回归）以及<strong>分类</strong>。而无监督学习实际上常常被称为<strong>聚类</strong>。</p>
<p>有无监督的差别可以理解为训练集之中的输入输出对 <span class="math inline">\((x_i, y_i)\)</span> 的 <span class="math inline">\(y_i\)</span> 是否明确。如果 <span class="math inline">\(y_i\)</span> 明确，那么这个学习就有监督，否则无监督。</p>
<p>下面解释为何无监督又被称为聚类。由于 <span class="math inline">\(y_i\)</span> 是不给定的，所以我们不能很明确给出一个已知局面具体属于何种类别，但我们对于给定的两个已知局面，我们可以判断其相似性（断定两者是否大概率属于同一类别），进而将类似的输入输出对聚合在一类里面，不类似的尽可能分开，这就是<strong>聚类（ clustering ）</strong>。所以尽管学习目标都是寻找 <span class="math inline">\(g\)</span> 让模型的预测尽可能准确，但是两者的学习方式是不同的。</p>
<p>之后我们给出两个概念，就是<strong>过拟合</strong>以及<strong>泛化能力</strong>。</p>
<p>过拟合是机器学习要处理的一个重要问题，其描述的就是算法给出了一个相当复杂的函数 <span class="math inline">\(g\)</span> ，其在训练集上能够相当准确率地和 <span class="math inline">\(f\)</span> 类似，但是在其余输入上却不够好。泛化能力描述的是这个模型在面对未知输入的时候是否能够做出合理输出的能力。</p>
<h3 id="朴素-bayes-法">朴素 Bayes 法</h3>
<p>这个方法应用在多分类问题上。我们可以认为输入空间为若干 <span class="math inline">\(n\)</span> 维向量的集合 <span class="math inline">\(\boldsymbol X \subset \mathbb R^n\)</span> ，输出空间则是若干类别（标签）的集合 <span class="math inline">\(\boldsymbol Y = \{c_1, c_2, \cdots, c_k\}\)</span> 。所以说输入 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(\boldsymbol X\)</span> 上的随机变量，输出 <span class="math inline">\(Y\)</span> 是 <span class="math inline">\(\boldsymbol Y\)</span> 上的随机变量。考虑 <span class="math inline">\(X, Y\)</span> 的联合分布 <span class="math inline">\(f(x, y)\)</span> 。</p>
<p>我们得出：</p>
<p><span class="math display">\[
P(Y = c_k \mid X = x) = \frac{
    P(X = x \mid Y = c_k)P(Y = c_k)
} {
    \sum_k P(X = x \mid Y = c_k)P(Y = c_k)
}
\]</span></p>
<p>这个概率实际上是在给定输入 <span class="math inline">\(X = x\)</span> 的时候，输出 <span class="math inline">\(Y = c_k\)</span> 的后验概率。所有的先验概率来源于训练集，也就是用频率近似概率。</p>
<p>我们确定最后的输出的方式是寻找令后验概率最大的 <span class="math inline">\(c_k\)</span> 。由于上述分母保持常数，所以输出：</p>
<p><span class="math display">\[
y = \arg\max_{c_k} P(X = x \mid Y = c_k)P(Y = c_k)
\]</span></p>
<p>但是我们这里要注意到先验概率之中的 <span class="math inline">\(P(X = x \mid Y = c_k)\)</span> 项，其复杂度随着 <span class="math inline">\(n\)</span> 的上升而指数上升。但是我们可以假设 <span class="math inline">\(X\)</span> 的各个维度是独立的，所以我们可以得到：</p>
<p><span class="math display">\[
\begin{aligned}
P(X = x \mid Y = c_k) &amp;= P\left(X^{(1)} = x^{(1)}, X^{(2)} = x^{(2)}, \cdots, X^{(n)} = x^{(n)} \ \middle| \  Y = c_k\right) \\
&amp;= \prod_{j = 1}^n P\left(X^{(j)} = x^{(j)} \ \middle| \ Y = c_k\right)
\end{aligned}
\]</span></p>
<p>最终给出的 <strong>Bayes 分类器</strong>为： <span class="math display">\[
y = \arg\max_{c_k} P(Y = c_k)\prod_{j = 1}^n P\left(X^{(j)} = x^{(j)} \ \middle| \ Y = c_k\right)
\]</span></p>
<p>这里给出<strong>平滑</strong>的概念。也就是如果训练集中如果没有出现过某一个 case ，这个时候 case 的频率为 <span class="math inline">\(0\)</span> ，但是显然我们不能把概率估计为 <span class="math inline">\(0\)</span> ，这个时候会引入平滑。这里给出一个例子：</p>
<p><span class="math display">\[
P_\lambda\left(X^{(j)} = a_{jl} \ \middle| \ Y = c_k\right) = \frac{
    \sum_{i = 1}^N {\rm idx}\left(x_i^{(j)} = a_{jl}, y_i = c_k\right) + \lambda
} {
    \sum_{i = 1}^N {\rm idx}(y_i = c_k) + S_j\lambda
}
\]</span></p>
<p><span class="math inline">\({\rm idx}\)</span> 函数为<strong>示性函数</strong>，其参数为布尔表达式，为真的时候函数返回 <span class="math inline">\(1\)</span> ，否则返回 <span class="math inline">\(0\)</span> 。</p>
<p>这里 <span class="math inline">\(S_j\)</span> 为 <span class="math inline">\(x^{(j)}\)</span> （输入第 <span class="math inline">\(j\)</span> 维）的取值集合 <span class="math inline">\(\{a_{j1}, a_{j2}, \cdots, a_{jS_j}\}\)</span> 的大小。</p>
<p>这里 <span class="math inline">\(\lambda\)</span> 是平滑系数，一般取 <span class="math inline">\(\lambda = 1\)</span> ，此时平滑成为 <strong>Laplace 平滑</strong>。</p>
<h3 id="支持向量机-svm">支持向量机（ SVM ）</h3>
<p>SVM 是一个适用于二分类问题的计算模型。</p>
<p>给定线性可分训练集 <span class="math inline">\(T = \{(\boldsymbol x_1, y_1), (\boldsymbol x_2, y_2), \cdots, (\boldsymbol x_N, y_N)\}\)</span> ，这里 <span class="math inline">\(\boldsymbol x_i \in X = \mathbb R^n\)</span> 以及 <span class="math inline">\(y_i \in Y = \{1, -1\}\)</span> 。这里我们称 <span class="math inline">\(1\)</span> 为正类， <span class="math inline">\(-1\)</span> 为负类。</p>
<p>我们希望寻找一个超平面 <span class="math inline">\(\boldsymbol w^{*T}\boldsymbol x + b^* = 0\)</span> ，给定决策函数：</p>
<p><span class="math display">\[
f(\boldsymbol x) = {\rm sgn}(\boldsymbol w^{*T}\boldsymbol x + b^*)
\]</span></p>
<p>这就是<strong>线性可分支持向量机</strong>。</p>
<p>为了评估一个超平面 <span class="math inline">\(\boldsymbol w^T\boldsymbol x + b = 0\)</span> ，我们给定 <span class="math inline">\(T\)</span> 之中的一个样本点 <span class="math inline">\((x_i, y_i)\)</span> ，定义<strong>函数间隔</strong>：</p>
<p><span class="math display">\[
\hat\gamma_i = y_i(\boldsymbol w^T\boldsymbol x_i + b)
\]</span></p>
<p>定义<strong>几何间隔</strong>：</p>
<p><span class="math display">\[
\gamma_i = y_i\left(\frac{\boldsymbol w^T}{\|\boldsymbol w\|}\boldsymbol x_i + \frac{b}{\|\boldsymbol w\|}\right)
\]</span></p>
<p>上述定义是针对单个样本点的，所以对于整个训练集 <span class="math inline">\(T\)</span> ，定义：</p>
<p><span class="math display">\[
\begin{cases}
    \hat\gamma = \min_i \hat\gamma_i \\
    \gamma = \min_i \gamma_i \\
\end{cases}
\]</span></p>
<p>这也就是训练集和超平面的函数间隔以及几何间隔。这两种间隔之间相差 <span class="math inline">\(\|\boldsymbol w\|\)</span> 倍。</p>
<p>我们选择超平面的标准就是<strong>最大化超平面和训练集的间隔</strong>，也就是求取 <span class="math inline">\(\max_{\boldsymbol w, b}\gamma\)</span> 。由于 <span class="math inline">\(\boldsymbol w, b\)</span> 可以成比例缩放，所以说我们完全可以假设 <span class="math inline">\(\hat\gamma = 1\)</span> ，从而最优化问题转化为最大化 <span class="math inline">\(1 / \|\boldsymbol w\|\)</span> ，等价于最小化 <span class="math inline">\(1 / 2\|\boldsymbol w\|^2\)</span> 。所以说问题就是求解 <span class="math inline">\(\min_{\boldsymbol w, b} 1 / 2\|\boldsymbol w\|^2\)</span> 。</p>
<p>这里由于 <span class="math inline">\(\hat\gamma = 1\)</span> ，所以说总是存在 <span class="math inline">\((\boldsymbol x_i, y_i)\)</span> 满足 <span class="math inline">\(y_i(\boldsymbol w^T\boldsymbol x_i + b) = \hat\gamma = 1\)</span> ，这个向量就是<strong>支持向量</strong>。</p>
<p>SVM 的学习过程，可以先定义 Lagrange 函数：</p>
<p><span class="math display">\[
L(\boldsymbol w, b, \boldsymbol\alpha) = \frac{1}{2}\|\boldsymbol w\|^2 + \sum_{i = 1}^N \alpha_i[1 - y_i(\boldsymbol w^T\boldsymbol x_i + b)]
\]</span></p>
<p>这里 <span class="math inline">\(\alpha_i \geq 0\)</span> ，并且 <span class="math inline">\(\boldsymbol\alpha = (\alpha_1, \alpha_2, \cdots, \alpha_N)^T\)</span> 为 Lagrange 乘子向量。</p>
<p>我们知道：</p>
<p><span class="math display">\[
\max_\boldsymbol\alpha L(\boldsymbol w, b, \boldsymbol\alpha) =
\begin{cases}
    \dfrac{1}{2}\|\boldsymbol w\|^2 &amp; {\rm when\ some\ requirements\ are\ satisfied} \\
    \infty &amp; {\rm otherwise}
\end{cases}
\]</span></p>
<p>所以说 <span class="math inline">\(\min_{\boldsymbol w, b}\max_\alpha L(\boldsymbol w, b, \boldsymbol\alpha)\)</span> 与原问题等价。</p>
<p>另外，我们断定：</p>
<p><span class="math display">\[
\min_{\boldsymbol w, b} L(\boldsymbol w, b, \boldsymbol\alpha) \leq L(\boldsymbol w, b, \boldsymbol\alpha) \leq \max_\boldsymbol\alpha L(\boldsymbol w, b, \boldsymbol\alpha)
\]</span></p>
<p>所以我们有：</p>
<p><span class="math display">\[
\max_\boldsymbol\alpha\min_{\boldsymbol w, b} L(\boldsymbol w, b, \boldsymbol\alpha) \leq \min_{\boldsymbol w, b}\max_\boldsymbol\alpha L(\boldsymbol w, b, \boldsymbol\alpha)
\]</span></p>
<p>这个等号成立的条件为 <strong>KKT 条件</strong>。所以我们将问题转化为求 <span class="math inline">\(\max_\boldsymbol\alpha\min_{\boldsymbol w, b} L(\boldsymbol w, b, \boldsymbol\alpha)\)</span> 。</p>
<p>我们令 <span class="math inline">\(L(\boldsymbol w, b, \boldsymbol\alpha)\)</span> 对 <span class="math inline">\(\boldsymbol w, b\)</span> 偏导为 <span class="math inline">\(0\)</span> 并带入就将问题转化为：</p>
<p><span class="math display">\[
\max_\boldsymbol\alpha\left[-\frac{1}{2}\sum_{i = 1}^N \sum_{j = 1}^N \alpha_i\alpha_jy_iy_j(\boldsymbol x_i^T\boldsymbol x_j) + \sum_{i = 1}^N \alpha_i\right]
\]</span></p>
<p>这里的约束条件为：</p>
<p><span class="math display">\[
\sum_{i = 1}^N \alpha_iy_i = 0\ (\alpha_i \geq 0)
\]</span></p>
<p>我们据此获得 <span class="math inline">\(\alpha^*\)</span> ，从而我们可以计算：</p>
<p><span class="math display">\[
\begin{cases}
    \boldsymbol w^* = \sum_{i = 1}^N \alpha_i^*y_i\boldsymbol x_i \\
    b^* = y_j - \sum_{i = 1}^N \alpha_i^*y_i(\boldsymbol x_i^T\boldsymbol x_j)\ (\alpha_j^* \neq 0)
\end{cases}
\]</span></p>
<p>但是有的时候这些点并不能被线性超平面完全分隔，所以说 <span class="math inline">\(y_i(\boldsymbol w^T\boldsymbol x_i + b) \geq 1\)</span> 并不能处处满足，所以需要引入<strong>松弛变量</strong>：</p>
<p><span class="math display">\[
y_i(\boldsymbol w^T\boldsymbol x_i + b) \geq 1 - \xi_i
\]</span></p>
<p>为了尽量减小 <span class="math inline">\(\xi_i\)</span> 的影响，所以我们可以把优化目标改为：</p>
<p><span class="math display">\[
\min_{\boldsymbol w, b, \xi}\left(\frac{1}{2}\|\boldsymbol w\|^2 + C\sum_{i = 1}^N \xi_i\right)
\]</span></p>
<p>这种处理方式称为<strong>软间隔最大化</strong>，这里 <span class="math inline">\(C &gt; 0\)</span> 为惩罚参数， <span class="math inline">\(C\)</span> 越大惩罚力度越大。</p>
<p>按照线性可分 SVM 的方法，问题转化为：</p>
<p><span class="math display">\[
\max_\alpha\left[-\frac{1}{2}\sum_{i = 1}^N \sum_{j = 1}^N \alpha_i\alpha_jy_iy_j(\boldsymbol x_i^T\boldsymbol x_j) + \sum_{i = 1}^N \alpha_i\right]
\]</span></p>
<p>这里的约束条件为：</p>
<p><span class="math display">\[
\sum_{i = 1}^N \alpha_iy_i = 0\ (0 \leq \alpha_i \leq C)
\]</span></p>
<p>我们据此获得 <span class="math inline">\(\alpha^*\)</span> ，从而我们可以计算：</p>
<p><span class="math display">\[
\begin{cases}
    \boldsymbol w^* = \sum_{i = 1}^N \alpha_i^*y_i\boldsymbol x_i \\
    b^* = y_j - \sum_{i = 1}^N \alpha_i^*y_i(\boldsymbol x_i^T\boldsymbol x_j)\ (0 &lt; \alpha_j^* &lt; C)
\end{cases}
\]</span></p>
<p><span class="math inline">\(\alpha_i^* &gt; 0\)</span> 对应的 <span class="math inline">\(\boldsymbol x_i\)</span> 是支持向量。</p>
<ul>
<li>若 <span class="math inline">\(\alpha_i^* = 0\)</span> ，则不是支持向量（对应曲线外侧的点）</li>
<li>若 <span class="math inline">\(0 &lt; \alpha_i^* &lt; C\)</span> ，则 <span class="math inline">\(\xi_i = 0\)</span> ，那么 <span class="math inline">\(\boldsymbol x_i\)</span> 在间隔边界上，是支持向量（对应两条虚线上的点）</li>
<li>若 <span class="math inline">\(\alpha_i^* = C\)</span> ，那么 <span class="math inline">\(\boldsymbol x_i\)</span> 也是支持向量
<ul>
<li>若 <span class="math inline">\(0 &lt; \xi_i &lt; 1\)</span> ，则分类正确（对应在己方虚线和实线之间的点）</li>
<li>若 <span class="math inline">\(\xi_i = 1\)</span> ，则在超平面上（对应在实线上的点）</li>
<li>若 <span class="math inline">\(\xi_i &gt; 1\)</span> ，则被误分（对应在实线和对方虚线之间的点）</li>
</ul></li>
</ul>
<p>这里给出一个结论，也就是样本点到软间隔边界（虚线边界）的距离为 <span class="math inline">\(\xi_i / \|\boldsymbol w\|\)</span> 。</p>
<p>另外一方面，我们考虑使用非线性的方式分割数据点。事实上就是尝试建立一个非线性映射将原空间的数据点映射到新空间上，这些数据点在新空间上线性可分。</p>
<p>考虑使用映射 <span class="math inline">\(\phi: X \rightarrow H\)</span> 将输入 <span class="math inline">\(\boldsymbol x \in X\)</span> 映射到新空间 <span class="math inline">\(H\)</span> 上，这里把 <span class="math inline">\(K(\boldsymbol x, \boldsymbol y) := \phi(\boldsymbol x)^T\phi(\boldsymbol y)\)</span> 称为<strong>核函数</strong>。这个时候所有的与内积相关的运算均应该使用核函数进行。</p>
<p>按照线性可分 SVM 的方法，问题转化为：</p>
<p><span class="math display">\[
\max_\alpha\left[-\frac{1}{2}\sum_{i = 1}^N \sum_{j = 1}^N \alpha_i\alpha_jy_iy_jK(\boldsymbol x_i, \boldsymbol x_j) + \sum_{i = 1}^N \alpha_i\right]
\]</span></p>
<p>这里的约束条件为：</p>
<p><span class="math display">\[
\sum_{i = 1}^N \alpha_iy_i = 0\ (0 \leq \alpha_i \leq C)
\]</span></p>
<p>我们据此获得 <span class="math inline">\(\alpha^*\)</span> ，从而我们可以计算：</p>
<p><span class="math display">\[
b^* = y_j - \sum_{i = 1}^N \alpha_i^*y_iK(\boldsymbol x_i, \boldsymbol x_j)\ (0 &lt; \alpha_j^* &lt; C)
\]</span></p>
<p>原有的决策函数之中含有内积，所以也需要将其修改为：</p>
<p><span class="math display">\[
f(\boldsymbol x) = {\rm sgn}\left(\sum_{i = 1}^N \alpha_i^*y_iK(\boldsymbol x_i, \boldsymbol x) + b^*\right)
\]</span></p>
<p>常用的核函数包括<strong>多项式核函数</strong>：</p>
<p><span class="math display">\[
K(\boldsymbol x, \boldsymbol y) = (\boldsymbol x^T\boldsymbol y + 1)^p
\]</span></p>
<p>以及<strong>高斯核函数</strong>：</p>
<p><span class="math display">\[
K(\boldsymbol x, \boldsymbol y) = \exp\left(-\frac{\|\boldsymbol x - \boldsymbol y\|^2}{2\sigma^2}\right)
\]</span></p>
<h3 id="决策树">决策树</h3>
<p>我们定义随机变量 <span class="math inline">\(X\)</span> 的熵为：</p>
<p><span class="math display">\[
H(X) = -\sum_{i = 1}^n p_i\log p_i
\]</span></p>
<p>当概率由训练集 <span class="math inline">\(D\)</span> 给出，该熵可以标记为 <span class="math inline">\(H(D)\)</span> 。</p>
<p>之后给出条件熵：</p>
<p><span class="math display">\[
H(Y \mid X) = \sum_{i = 1}^n P(X = x_i)H(Y \mid X = x_i)
\]</span></p>
<p>这表示的是已经知道 <span class="math inline">\(X\)</span> 的时候 <span class="math inline">\(Y\)</span> 的不确定性。</p>
<p>之后定义特征 <span class="math inline">\(A\)</span> 对数据集 <span class="math inline">\(D\)</span> 的<strong>信息增益</strong>为：</p>
<p><span class="math display">\[
g(D, A) = H(D) - H(D \mid A)
\]</span></p>
<p>这实际上表示的是给定特征 <span class="math inline">\(A\)</span> 的时候数据集 <span class="math inline">\(D\)</span> 不确定性减少的程度。</p>
<p>假设有训练集 <span class="math inline">\(D\)</span> ，有 <span class="math inline">\(K\)</span> 个类 <span class="math inline">\(C_k\)</span> ，特征 <span class="math inline">\(A\)</span> 有 <span class="math inline">\(n\)</span> 个取值 <span class="math inline">\(a_i\)</span> ，特征 <span class="math inline">\(A\)</span> 的不同取值将 <span class="math inline">\(D\)</span> 划分为 <span class="math inline">\(n\)</span> 个子集 <span class="math inline">\(D_i\)</span> ，记 <span class="math inline">\(D_i\)</span> 中属于 <span class="math inline">\(C_k\)</span> 类的样本集合为 <span class="math inline">\(D_{ik}\)</span> ，那么：</p>
<p><span class="math display">\[
\begin{aligned}
    g(D, A) &amp;= H(D) - H(D \mid A) \\
    &amp;= -\sum_{k = 1}^K \frac{|C_k|}{|D|}\log\frac{|C_k|}{|D|} + \sum_{i = 1}^n \frac{|D_i|}{|D|}\left(\sum_{k = 1}^K \frac{|D_{ik}|}{|D_i|}\log\frac{|D_{ik}|}{|D_i|}\right)
\end{aligned}
\]</span></p>
<p>下面介绍 ID3 算法，这个算法可以用于生成决策树：</p>
<ul>
<li>如果 <span class="math inline">\(D\)</span> 之中所有例子属于同一类或者没有用于判断的特征，则返回单节点树，类标记为实例数最多的类；</li>
<li>选择信息增益最大的特征 <span class="math inline">\(A_g\)</span> ，其信息增益为 <span class="math inline">\(\delta_A\)</span> ；</li>
<li>如果 <span class="math inline">\(\delta_A\)</span> 小于阈值 <span class="math inline">\(\varepsilon\)</span> ，那么置单节点决策树，类标记为实例数最多的类；</li>
<li>否则按照特征取值分割训练集，如果某个分割后的块为空，那么构建单节点子树，类标记为 <span class="math inline">\(D\)</span> 实例数最多的类。若非空则构建子树，递归上述过程。</li>
</ul>
<p>这样的算法倾向于选择分支比较多的属性。</p>
<p>所以定义<strong>信息增益比</strong>：</p>
<p><span class="math display">\[
g_R(D, A) = \frac{g(D, A)}{H_A(D)}
\]</span></p>
<p>将 ID3 算法之中的信息增益换成信息增益比则得到 C4.5 算法。</p>
<p>这种方法生成的决策树可能产生过拟合，所以需要一定程度上的剪枝。剪枝的基本流程在于找到一个父节点，剪取其下一代后将其作为新的叶子节点，其类型标记为其原来对应的子树中量最大的类。</p>
<p>在数据量足够大的时候，可以使用验证集进行剪枝，也就是不断使用验证集剪枝直到性能下降。如果数据量不够，则使用训练集，从下往上缩节点，直到损失函数回升。损失函数定义：</p>
<p><span class="math display">\[
C_a(T) = \sum_{t = 1}^{|T|}N_tH_t(T) + a|T|
\]</span></p>
<p>这里经验熵定义为：</p>
<p><span class="math display">\[
H_t(T) = -\sum_k \frac{N_{tk}}{N_t}\log\frac{N_{tk}}{N_t}
\]</span></p>
<p>这里某一个节点 <span class="math inline">\(t\)</span> 的样本数为 <span class="math inline">\(N_t\)</span> ，其中 <span class="math inline">\(k\)</span> 类的样本数为 <span class="math inline">\(N_{tk}\)</span> 。</p>
<h2 id="神经网络与深度学习">神经网络与深度学习</h2>
<h3 id="基本神经元结构">基本神经元结构</h3>
<p>一个神经网络中的神经元一般接受多个输出并产生一个输出，一般而言其数学表达为：</p>
<p><span class="math display">\[
y = g\left(\sum_{i = 1}^n w_ix_i + b\right)
\]</span></p>
<p>这里函数 <span class="math inline">\(g\)</span> 一般是非线性的，称为<strong>激活函数</strong>。激活函数常见的有 sigmoid 等。</p>
<h3 id="反向传播算法-bp">反向传播算法（ BP ）</h3>
<p>训练一个多层神经网络可以分为两步，首先是正向从输入计算出输出，和标准输出对比，算出损失函数（衡量实际输出和标准输出的差别），这是<strong>正向传播</strong>。之后就是根据差别的大小，计算出网络中各个权重对最终输出的偏导数，从而更新权重值，这是<strong>反向传播</strong>。</p>
<p>一般而言我们常常使用均方误差评价输出，也就是说对于某一层神经元以及某一个样本 <span class="math inline">\(d\)</span> ，标记其中第 <span class="math inline">\(j\)</span> 个神经元的实际输出为 <span class="math inline">\(o_j\)</span> ，理想输出为 <span class="math inline">\(t_j\)</span> ，那么损失函数为：</p>
<p><span class="math display">\[
E_d(\boldsymbol w) = \frac{1}{2}\sum_j (t_j - o_j)^2
\]</span></p>
<p>根据损失函数，权重 <span class="math inline">\(w_{ji}\)</span> （第 <span class="math inline">\(j\)</span> 个神经元对第 <span class="math inline">\(i\)</span> 个输入的权重）的更新量为：</p>
<p><span class="math display">\[
\Delta w_{ji} = -\eta\frac{\partial E_d}{\partial w_{ji}}
\]</span></p>
<p>这里 <span class="math inline">\(0 &lt; \eta &lt; 1\)</span> 称为<strong>学习率</strong>。</p>
<p>我们设置一个中间量：</p>
<p><span class="math display">\[
n_j := \sum_iw_{ji}x_{ji} + b_j
\]</span></p>
<p>也就是未激活的神经元输出。那么我们知道：</p>
<p><span class="math display">\[
\frac{\partial E_d}{\partial w_{ji}} = \frac{\partial E_d}{\partial n_j}\frac{\partial n_j}{\partial w_{ji}} = \frac{\partial E_d}{\partial n_j}x_{ji}
\]</span></p>
<p>下面我们对输出层和隐含层分别计算损失函数对未激活输出的偏导数。</p>
<p>如果该层为输出层，那么我们进一步展开：</p>
<p><span class="math display">\[
\frac{\partial E_d}{\partial n_j} = \frac{\partial E_d}{\partial o_j}\frac{\partial o_j}{\partial n_j} = \frac{\partial}{\partial o_j}\left(\frac{1}{2}\sum_k(t_k - o_k)^2\right)\frac{\partial \sigma(n_j)}{\partial n_j} = -(t_j - o_j)o_j(1-o_j)
\]</span></p>
<p>这里默认激活函数为 sigmoid 函数。</p>
<p>如果该层为隐藏层，我们记其下游层的神经元构成集合 <span class="math inline">\(D\)</span> 。作如下展开：</p>
<p><span class="math display">\[
\begin{aligned}
\frac{\partial E_d}{\partial n_j} &amp;= \sum_{k \in D}\frac{\partial E_d}{\partial n_k}\frac{\partial n_k}{\partial o_j}\frac{\partial o_j}{\partial n_j} \\
&amp;= \sum_{k \in D}\frac{\partial E_d}{\partial n_k}\frac{\partial}{\partial o_j}\left(\sum_l w_{kj}o_j + b\right)\frac{\partial\sigma(n_j)}{\partial n_j} \\
&amp;= \sum_{k \in D}\frac{\partial E_d}{\partial n_k}w_{kj}o_j(1 - o_j) \\
&amp;= o_j(1 - o_j)\sum_{k \in D}\frac{\partial E_d}{\partial n_k}w_{kj}
\end{aligned}
\]</span></p>
<p>这里还有一项偏导数实则可以继续按照上述的方式递推计算，直到计算到输出层。</p>
<p>这里额外提一下，均方误差只是一个选择，在分类问题中，更常用的是<strong>交叉熵误差</strong>：</p>
<p><span class="math display">\[
H_\boldsymbol t(\boldsymbol o) = -\sum_i t_i\log(o_i)
\]</span></p>
<h3 id="过拟合问题与正则化">过拟合问题与正则化</h3>
<p>过拟合问题在之前有过说明，在深度学习之中减少过拟合的一个方法就是在损失函数之中加入正则项：</p>
<p><span class="math display">\[
E_d(\boldsymbol w) = \frac{1}{2}\sum_k(t_k - o_k)^2 + \|\boldsymbol w\|
\]</span></p>
<p>另外还有引入 Dropout 以及引入验证集的方式，这里均不展开。</p>
<h3 id="卷积神经网络-cnn">卷积神经网络（ CNN ）</h3>
<p><code>TODO</code></p>
<h3 id="循环神经网络-rnn">循环神经网络（ RNN ）</h3>
<p><code>TODO</code></p>
]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
  </entry>
  <entry>
    <title>《无线移动网络技术》学习笔记</title>
    <url>/1021/09/17/note-of-mnt/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
  </entry>
  <entry>
    <title>《计算机网络原理》学习笔记</title>
    <url>/1021/09/13/note-of-net/</url>
    <content><![CDATA[<p>网原总之是一个没打算认真学的专业课，因为真的对网络没有很大的兴趣。再加上上学期曾经看着迅哥哥他们被网原折磨，自己也没什么信心能学好这门专业课。</p>
<p>这个笔记完全基于上一届流传下来的《网原干饭背诵》，在此基础上对重点做一些标记做一些讲解，反正是个背书课，那么就只能一点一点背了。根据前人经验，这个笔记会把比较重要的东西用星号标注出来。</p>
<span id="more"></span>
<h1 id="计算机网络的历史和新进展">计算机网络的历史和新进展</h1>
<h2 id="背诵-1-网络基础">【背诵 1 】网络基础</h2>
<ul>
<li><p>网络所提供的最基本服务为<strong>信息传递</strong>，不同的网络依据其提供的服务进行区分。而区分服务的依据则包括功能、延迟、带宽等各种<strong>外部特性</strong>。</p></li>
<li><p>网络依据<strong>空间距离</strong>可以分为局域网（ LAN ）、城域网（ MAN ）、广域网（ WAN ）和个域网（ PAN ）。依据<strong>信息类型</strong>可以分为数据网络、电话网络。依据<strong>应用类型</strong>可以分为专用网络、通用网络。依据<strong>使用权</strong>可以分为私有网络、公用网络。同时，网络也可以按照使用的协议进行分类，如 IP 协议等。</p></li>
</ul>
<h2 id="背诵-2-计算机网络发展历史">【背诵 2 】计算机网络发展历史</h2>
<p>计算机网络的历史可以大致描述为：</p>
<ul>
<li>1940 年代，第一个计算机 ENIAC 诞生</li>
<li>1950 年代，大型机和多终端系统诞生</li>
<li>1960 - 1964 年，分组交换网络诞生（ Paul Baran ）</li>
<li>1960 年代，计算机网络研究开始</li>
<li>* 1969 年， ARPANET 研究启动</li>
<li>1970 年代，计算机网络发展
<ul>
<li>各国电信部门建设运行 X.25 分组交换网</li>
<li>SNA 以及 DNA 等专用网络体系结构出现</li>
<li>Internet 的前身 ARPANET 进行实验运行，带宽小且仅有不到 100 台计算机接入</li>
<li>* 以太网和 Telnet 出现</li>
<li>* 1979 年， TCP/IP 协议成熟</li>
</ul></li>
<li>1980 年代，计算机网络逐步成型
<ul>
<li>标准化的计算机网络体系结构 ISO/OSI 出现</li>
<li>局域网 LAN 技术发展</li>
<li>FTP 、 NFS 、 E-mail 、 USENET 等技术出现</li>
<li>1980 - 1983 年， ARPANET 和 MILNET 分离，前者采用 TCP/IP 协议</li>
<li>1983 年， BSD UNIX 内置 TCP/IP 协议</li>
<li>1985 - 1986 年， NSFNET 建成，用于连接 6 个超级计算中心</li>
<li>1987 - 1990 年， NSFNET 开始连接地区网络</li>
<li>Internet 初具规模， 1987 年，中国第一个电子邮件发送到 Internet</li>
<li>中国开始依赖电话线建立低速广域网</li>
</ul></li>
<li>1990 年代，计算机网络进一步发展
<ul>
<li>Internet 商业化，在中国也得到了广泛应用</li>
<li>Web 技术在 Internet 上得到广泛应用</li>
<li>中国出现局域网，如 Novell 等</li>
<li>1990 - 1992 年， NSFNET 带宽提高，连接了 16 个地区网络</li>
<li>1994 年， NSFNET 骨干网解体，出现了若干其他的商用骨干网</li>
<li>1995 年，中国教育和科研网 CERNET 出现</li>
</ul></li>
<li>2000 年代，计算机网络广泛应用
<ul>
<li>网络应用发展迅速，搜索引擎和社交网络出现</li>
<li>移动互联网产业快速发展</li>
<li>2006 年，与 IPv6 相关的 CNGI-CERNET2 出现</li>
</ul></li>
<li>最近，数据中心网络、天地一体化网络、 IPv6 技术等快速发展
<ul>
<li>2011 年开始设立 World IPv6 Day</li>
<li>2011 年 2 月 3 日，全球互联网名称与数字地址分配机构 ICANN 宣布 IPv4 地址耗尽</li>
</ul></li>
</ul>
<h2 id="背诵-3-internet-技术">【背诵 3 】 Internet 技术</h2>
<ul>
<li>Internet 是全球范围的、通用的、异构的公用计算机网络</li>
<li>Internet 是其他类型的计算机网络技术的基础，如企业内部网（ Intranet ）</li>
<li>Internet 开放的标准由 IETF 负责制定、维护和协调。其他类似 IRTF 、 IAB 、 IESG 等机构也参与了标准的维护
<ul>
<li>IETF 全称 Internet Engineering Task Force ，其分为若干个工作组（ WG ），其提交的 Internet 标准被称为 RFC ，即 Request For Comments</li>
<li>IRTF 全称 Internet Researching Task Force ，由各类专注某一个领域的研究小组组成</li>
<li>IAB 全称 Internet Architecture Board ，负责定义 Internet 的大体框架，为 IETF 提供方向上的指导</li>
<li>IESG 全称 Internet Engineering Steering Group ，负责在技术方面上管理 IETF 的活动</li>
</ul></li>
<li>Internet 是历史上发展最快的一种技术，其发展速度甚至超越摩尔定律</li>
</ul>
<h2 id="背诵-4-网络时代三大定律">【背诵 4 】网络时代三大定律</h2>
<ul>
<li>【摩尔定律】 CPU 性能每 18 个月会翻番，每 10 年翻 100 倍</li>
<li>【光纤定律】也称超摩尔定律，骨干网带宽每 9 个月会翻番。每 10 年翻 10000 倍</li>
<li>【麦特卡菲定律】也称联网定律，网络价值和用户数量的平方成正比</li>
</ul>
<h2 id="理解-1-分组交换技术">【理解 1 】分组交换技术</h2>
<p>Paul Baran 在设计能承受核攻击的通信系统的时候，确立了三个设计准则。</p>
<ul>
<li>自适应系统的<strong>热土豆路由策略</strong>（能够学习并适应各种新的环境）
<ul>
<li>如果不知道正确的路由，就将分组转发给所有邻居</li>
<li>通过观察路过的分组来更新路由表，旧的路由表项会被删除</li>
<li>尽可能快地转发分组，分组途径的路径并不一定是最短路径</li>
</ul></li>
<li>分组发送策略（端节点能够容忍错误并恢复）
<ul>
<li>每个节点根据自我的路由表决定如何转发分组</li>
<li>每个分组的转发完全独立于其他的分组</li>
<li>交换节点不保存端节点信息，这一点让网络的可拓展性大大增强</li>
</ul></li>
<li>分布式策略
<ul>
<li>所有交换节点平等，避免单一节点失效问题</li>
<li>通过物理硬件冗余和自适应路由实现系统稳健性</li>
</ul></li>
</ul>
<p>而 Internet 就是这一类网络。 Internet 连接了各种异构的子网，提供两个最基本的功能，即全球唯一地址和分组通过动态路由传输。</p>
<p>分组交换技术具有相当多的优点，包括：</p>
<ul>
<li>简单性
<ul>
<li>每个分组自身携带信息</li>
<li>一个路由表可以为所有的流量服务</li>
<li>可以适应快速增长的网络规模</li>
</ul></li>
<li>灵活性
<ul>
<li>可以在各种物理底层上运行</li>
<li>可以支持各种网络应用</li>
</ul></li>
<li>可扩展性
<ul>
<li>可以应对端系统的增加</li>
<li>可以应对流量的增加</li>
<li>可以应对网络规模增大带来的路由表增大和路由频繁变化</li>
</ul></li>
<li>健壮性
<ul>
<li>默认了网络结构变化是正常现象</li>
<li>牺牲一定的效率换取网络的稳定</li>
</ul></li>
</ul>
<h2 id="背诵-5-今日互联网">【背诵 5 】今日互联网</h2>
<ul>
<li>今日的互联网具有更大的规模和更多的用户，而且支持更多的功能，具有更高的价值，但是其健壮性、适应性和互联程度都下降了</li>
<li>当今互联网面临的一个问题就是 IPv4 地址耗尽，而目前缓解这个问题地方案是<strong>网络地址转换协议（ Network Address Translation / NAT ）</strong>
<ul>
<li>NAT 缓解了地址耗尽的问题，增强了安全性和控制性</li>
<li>但是另外一方面却打破了 Internet 中地址唯一的假设</li>
<li>端到端的分组传输路径变成多个 NAT 域的级联，相当于虚电路</li>
<li>为了恢复 Internet 的原有结构，目前正在推进 IPv6 技术</li>
</ul></li>
</ul>
<h2 id="杂项-1-未分类知识点">【杂项 1 】未分类知识点</h2>
<ul>
<li>二十世纪后期人类两项最伟大的战略工程为<strong>星球大战计划</strong>和<strong>互联网计划</strong>。目前互联网已经发展为继海、陆、空、天之后的<strong>第五空间</strong>。</li>
</ul>
<h1 id="计算机网络体系结构">计算机网络体系结构</h1>
<h2 id="背诵-6-计算机网络的定义和组成">【背诵 6 】计算机网络的定义和组成</h2>
<ul>
<li>计算机网络定义为若干独立自治的计算机系统的互联集合体
<ul>
<li>计算机网络和分布式系统不同，分布式系统虽然也是由若干个计算机系统组成，但其具有<strong>内聚性</strong>和<strong>透明性</strong>，故分布式系统呈现给用户的更像是一台计算机。计算机网络则明显分立，在用户的视角依然是若干不同的计算机</li>
<li>目前分布式系统和计算机网络有合流的趋势，两者正在走向统一</li>
</ul></li>
<li>计算机网络有两级组成，即<strong>资源子网</strong>和<strong>通信子网</strong>。资源子网常常是服务器或者用户计算机，而通信子网常常是通信线路等信道和路由器、交换机等网络互联设备</li>
<li>计算机网络之中的通信通常有两种，即<strong>交换式通信</strong>和<strong>广播式通信</strong>
<ul>
<li>交换式通信又称<strong>点对点通信</strong>
<ul>
<li>需要经过交换设备，将消息转发给一个或一组结点</li>
<li>交换设备根据需要选择输出</li>
<li>网络典型的拓扑结构包括 star / ring(loop) / tree / complete / intersecting rings / irregular</li>
<li>关键技术是<strong>路由选择</strong></li>
</ul></li>
<li>广播式通信
<ul>
<li>多台计算机共享通信线路</li>
<li>任一台计算机发出的信息可以直接被其它计算机接收</li>
<li>网络典型的拓扑结构包括 bus / ring(loop)</li>
<li>关键技术是<strong>通道分配</strong>
<ul>
<li>静态分配，即分时间片。特点是控制简单，但通道利用率低</li>
<li>动态分配，即各站点动态使用通道。特点是控制复杂，但通道利用率高。通道分配方法有两种。集中式指的是只有一个仲裁机构，分布式指的是各站点均有仲裁机构</li>
</ul></li>
</ul></li>
<li>传统的 LAN 一般使用广播式通信，而 MAN 和 WAN 一般使用交换式通信。现代的 LAN 中交换式通信的应用正在增多</li>
</ul></li>
</ul>
<h2 id="理解-2-计算机网络体系结构">【理解 2 】计算机网络体系结构</h2>
<ul>
<li>计算机网络体系结构指的是对计算机网络及其部件所完成功能的比较精确的定义，即从功能的角度描述计算机网络的结构，是<strong>层次和层间关系</strong>的集合。但体系结构只会从功能上定义网络，并不会定义协议的细节和接口关系
<ul>
<li>现代计算机网络体系架构指出，计算机网络的基本功能是为地理位置不同的计算机用户之间提供访问通路，并且应当提供若干功能（具体功能列表见 PPT ），这些功能中最重要的是<strong>通信功能</strong></li>
<li>这些功能的特征是<strong>分层</strong>，也就是说计算机网络中提供的功能是分成层次的</li>
<li>位于不同计算机上进行对话的同一层通信各方可分别看成是一种进程，称为<strong>对等（同等）进程</strong></li>
</ul></li>
<li>计算机网络体系结构定义了计算机网络的功能是分层次的，而协议（ Protocol ）就是计算机网络同等层次中，通信双方进行信息交换时必须遵守的规则
<ul>
<li>协议由三部分组成
<ul>
<li>语法（ Syntax ）部分。即以二进制形式表示的命令和相应的结构</li>
<li>语义（ Semantics ）部分。即发出的命令请求，完成的动作和回送的响应组成的集合</li>
<li>定时关系（ Timing ）部分。即有关事件顺序的说明</li>
</ul></li>
<li>网络体系结构的分层决定了协议的分层，协议的分层构成了<strong>洋葱结构</strong>
<ul>
<li>目的主机某一层收到的报文与源主机同一层发出的报文相同</li>
<li>协议分层要保证整个通信系统功能完备高效</li>
</ul></li>
</ul></li>
<li>协议定义了不同计算机同层次之间的关系，而服务（ Service ）定义同一个计算机的上下层之间的交换信息时必须遵守的规则</li>
<li>在同一个计算机之中相邻层之间都有一个接口（ Interface ），它定义了下层向上层提供的原语操作和服务</li>
</ul>
]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
  </entry>
  <entry>
    <title>《计算机网络安全技术》学习笔记</title>
    <url>/1021/09/17/note-of-nst/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>《计算机组成原理》学习笔记</title>
    <url>/1021/09/14/note-of-pcc/</url>
    <content><![CDATA[<p>本学期重中之重的一门专业课，也是 4 学分的大课。但是考虑到我的意向研究生方向和这门课实际上不太贴合，估计还是稍微学学就撤退吧。</p>
<p>说实话到第五周才开始写这门课的笔记还是比较惭愧，但确实这一学期在课内的投入少了很多。</p>
<span id="more"></span>
<h2 id="计算机系统概述">计算机系统概述</h2>
<h3 id="计算机发展历史简述">计算机发展历史简述</h3>
<p>在计算机发展进程之中，先后出现了类似 Pascal 加法机、差分机、分析机等计算工具。随后， Turing 提出了通用计算机的概念，这种计算机可以执行任何一个算法。基于这个理论，计算机科学形成了“可计算性”概念的基础。而这种通用的计算模型就是 Turing Machine 。</p>
<p>在 1946 年，第一台通用电子计算机 ENIAC 制成。之后， Von Neumann 提出了包含五大部件的现代的计算机架构，基于此，第一台 Von Neumann 架构计算机 EDSAC 诞生。</p>
<p>随后，第一台小型机 PDP-1 ，第一个编译器 A0 编译器，第一个面向商务的语言 COBOL 语言，第一个系列计算机 IBM 360 逐次诞生。</p>
<h3 id="von-neumann-架构">Von Neumann 架构</h3>
<p>Von Neumann 架构的计算机包含的组件为 Datapath 、 Control 、 Memory 、 Input 和 Output 。其负责的职能分别为：</p>
<ul>
<li><p>Datapath 负责完成算术和逻辑运算，通常这些任务也包含了寄存器操作</p></li>
<li><p>Control 是 CPU 的组成部分，其根据程序指令来控制计算机其他组件共同完成程序功能</p></li>
<li><p>Memory 负责存放运行时程序及其所需要的数据</p></li>
<li><p>IO 则负责将信息传入计算机和将计算机结果展示给用户</p></li>
</ul>
<p>这种架构里，程序和数据统一表示为二进制数据。</p>
<p>在此架构下，计算机具有以下特征：</p>
<ul>
<li><p>程序由指令构成，程序功能通过指令序列表述，指令序列在存储器之中顺序存放</p></li>
<li><p>程序指针指向需要执行的指令，执行指令的时候首先从存储器之中读取指令，执行完毕后程序指针自增，指向下一条指令</p></li>
</ul>
<h3 id="汇编语言和高级语言">汇编语言和高级语言</h3>
<p>这一部分建议参考 <a href="/1021/08/09/note-of-asm/">汇编课程的笔记</a> 的内容。</p>
]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
  </entry>
  <entry>
    <title>《美少女万华镜 5 ——理与迷宫的少女》游戏测评</title>
    <url>/2021/08/18/renge-5/</url>
    <content><![CDATA[<p>Holder 不是一个玩 GAL 的人，能想到的 GAL 除了万华镜就是柚子社这种。但是 Holder 想了想，决定把万华镜 5 这个宣称中的最终章认真通一下，也算对我几乎唯一知晓的 GAL 致以敬意。</p>
<p>离万华镜 5 发售差不多过去一年半了，各路汉化理论上应该充斥互联网，但 Holder 也只找到了生肉，于是也顺便当成了日语阅读练习。</p>
<span id="more"></span>
<h1 id="总的感想">总的感想</h1>
<p>Holder 大概花掉了靠近三十个小时打通了所有的线，由于 H 情节在一年前实际上就已经都看过一遍而且自己也有全 CG ，这次的重点就是把当时看来冗杂无比的剧情认真看一下。</p>
<p>当然，一直都说万华镜系列就是单纯的拔作，剧情几乎可有可无，这句话我可以说认同一半。首先，针对万华镜 5 ，如果不走莲华线，而是没有压住枪走了月丘线，那确实没有任何剧情，平平淡淡地每晚在澡堂触发 H 情节就结束了。而你如果剧情看到一半没忍住走了绿毛线（绿毛名字是もよか，说实话不知道怎么找当て字，倒是“绿毛”这个代号挺深入人心的），那也是很快就 BE 了。而如果你认认真真把莲华线推完，就会发现若干的伏笔被回收，剧情似乎就有了那么一点的道理（ Holder 整体上还是觉得这个剧情偏扯，但是莲华线稍微补了一点论述）。其次，万华镜整个系列，确实几乎都是没啥剧情的，除了 5 。其他系列都是推一会就开始炮火连天，而 5 我是整整看剧情看了靠近两天之后才解锁了新天地（当然玩的莲华线）。</p>
<p>如果说总的感想的话，就是感觉看了一个很普通的小说。撇去还算优秀的 H 情节不谈，我在玩的时候几乎全程在看底下的文字，因为图像说实话提供不了信息。比如说“ A 把 B 扶起来”，这个动作在番或者剧里面都可以画或者演出来，但是万华镜里面也仅仅是两个人的立绘贴了一下，动作则是文字给出。所以整体我还是一直在看文字，当小说看。</p>
<p>而说它“普通”，是因为贯穿全程的就是“理”或者“命运”或者“轮回转生”，题材不是什么新颖的东西，而且能预料到莲华和男主的一些前世姻缘之类的。然后中心矛盾之一也是普通的，“我能逆天改命”和“我们只能顺应命运”的矛盾，最后认为“我能逆天改命”的人盒饭了，但却让“我们只能顺应命运”的思想少许动摇，但是为时已晚不得不继续投入到命运的轮回之中。</p>
<p>要我说的话，论剧情，万华镜 5 就是很普通的一个小说，人物关系简单，矛盾点简单。但是论 H 情节，首先我认为绿毛连动态情节都没有是很难受的（巫女后辈啊！不配画一点动态的吗！），但是莲华在二次轮回的时候 H 情节确实作画很好，动态也不错，还是稍微给点表扬。</p>
<h1 id="剧情简要分析">剧情简要分析</h1>
<h2 id="莲华-轮回线">莲华-轮回线</h2>
<p>既然核心是“理”（不得不提的就是这个“理”在游戏里面训读成ことわり，而这个读音一般写成“断り”）和“轮回转生”，那么我们应该默认天理和轮回转生的存在。</p>
<p>剧情的主干实际上就是莲华和男主深见夏彦的前世姻缘，他们可以说每一世都会相遇相爱但由于各种不可抗力无法修成正果。先是罗马时代的奴隶主和奴隶，又是中世纪的女王和下臣，之后是猎巫人和女巫。而重点是第四世，他们是古代日本的一对恋人（这时深见夏彦的名字是“彦一”，记住，要考的），而第五世就是莲华和深见夏彦。</p>
<p>说第四世重要，是因为这里狐妖介入了进来。实际上狐妖附身了第四世的莲华，或者在一定程度上，莲华在这个时候已经成为了狐妖。而当彦一（第四世的深见夏彦）死于战火的时候，狐妖则处于对人类的憎恨和爱人亡故的怨念火烧城池。人们最后将狐妖的怨念封印为“杀生石”，并在城中修建相当数量的狐狸雕像望向杀生石的方向以镇压，同时也在杀生石所在的山顶修建了一座规模宏大的神社。但是神社实际上在很多年之后的又一次战火中被烧毁，但是村民并没有重建的计划（多半是已经忘了这段历史）。而杀生石和狐狸雕像却保留了下来，成为了传说。</p>
<p>这里的杀生石、狐狸雕像、神社则是第五世（现代）剧情推进的一条线索。</p>
<p>而这个时候就必须引出绿毛了。在第五世，也就是现代，绿毛先前有一个家境优渥的家庭，但是由于他人嫉妒而故意放出的无端谣言而招致了全村人的厌恶，随后她的家人因他人纵火全部亡故，而纵火者却至今逍遥法外，绿毛也因此有了对人类的憎恨和怨念。孤身一人的她投靠了从兄弟 H（名字不想打了，但是这个人的人设和痴汉别无他样，所以就用 Hentai 的首字母代称。这里 H 是一个女子中学的音乐老师），此时绿毛沉迷于深见夏彦所在的杂志社编辑的灵异杂志，自学了很多通灵方法。最终，她独身一人走上了原来有神社和杀生石的山顶，被满是怨念的狐妖附身，开启了剧情主线。</p>
<p>绿毛有了狐妖的力量，而狐妖的一个信念就是“我是可以逆天改命的”，或者说“我不愿意服从命运的安排”。狐妖因恋人离世而对人类憎恶，绿毛因为家人离世也对人类憎恶，两个怨念叠加，绿毛开始了复仇。她的第一步就是先转学到 H 所在的女子高中并要控制全校，因为女子高中生就是当时散布绿毛家族无端谣言的主力。绿毛看中了这所高中禁止使用手机和通信软件，利用了她们相对闭锁的信息环境，开始通过狐妖的力量诱骗她们迷信自己的占卜，随后再通过狐妖的力量对她们下诅咒。诅咒的内容就是：</p>
<div class="note info no-icon"><p>山顶有神社可以实现你的愿望，但是在前往神社之前，你必须不停地画白狐氏（びゃっこ氏）以表虔诚，否则就会降下惩罚。</p>
</div>
<p>而这座神社在现实中是真的不存在的（早就烧掉了还没重建），但是狐妖的灵力可以在山顶创建一个传送门，传送到若干年前的神社，而这个神社就在狐妖（或者说绿毛）控制之下。白狐氏就是这座神社供奉的神灵（就是狐妖），而所谓的惩罚是各种莫名其妙的伤害事件（突然被钢琴盖子砸断手指，实验的时候突然自燃之类），并且惩罚的共同点就是受伤的地方毛细血管会聚集成青色的蜘蛛网的样子，而且会长一个痣。</p>
<p>这也就是最初的最初，深见夏彦所要调查的“青蜘蛛的诅咒”事件。</p>
<hr />
<p>主角团是四人组，深见夏彦，他的编辑月丘香恋，同期的只相信科学的优秀作家皇公晓，以及实体化的莲华。</p>
<p>莲华在第五世转生的时候，没有获得肉体，成为了阿紫旅馆（也就是万华镜 1-4 开头的那个旅馆，其和神社等位于同一个村子）的座敷童子。所谓座敷童子，第五世的莲华的任务就是“超度”，也就是帮助满是怨念的灵魂安宁地走向死亡，走向轮回。而完成超度的道具就是“万华镜”。</p>
<p>所以说 1-4 里面深见夏彦透过万华镜看到的，就是那些已经被超度的魂灵的生前故事，而往往这些故事都或多或少带着点怨恨（ 1 是人鬼情恋的越界之恨， 2 是沉溺于爱而伤害恋人的愧疚之恨， 3 是文明凋亡的孤独之恨， 4 则是近亲的禁忌之恨）。</p>
<p>另外，作为灵力的持有者，莲华的能力就是能够读取和修改人的记忆。</p>
<p>由于没有肉体，莲华无法被感知，从而也让她一直孤独一人。但深见夏彦，作为这么多次轮回之中莲华的恋人，自然是唯一一个能感知到她存在的的人。所以深见夏彦对莲华而言，简直就是世界上唯一可以交流的人类。</p>
<p>另一方面，莲华在得知深见夏彦想要来调查“青蜘蛛的诅咒”事件，要在阿紫旅馆住上一星期左右的时候，其花费了很多的灵力为自己构筑了肉体，并且通过修改记忆让主角团和旅馆工作人员都认为莲华是真实存在的一个女高中生，这也就是实体化。这个时候的莲华就可以和正常人一样活动了。</p>
<hr />
<p>先前提到，第四世的莲华和狐妖实际上几乎是一体的，而在第四世到第五世的轮回之中，莲华被拆分成了两部分，狐妖的部分被封印而剩下的部分幻化成了现在的莲华，这莲华是通过触碰了一只小狐狸之后回想起来的。</p>
<p>在主角团调查的时候，绿毛自然早已经觉察到，深见夏彦就是自己前世恋人彦一，所以绿毛对从兄弟 H 不屑一顾而单单对深见夏彦热情，而且在深见夏彦和莲华前往深山随便走走的时候将他们拉入了神社。绿毛自然也早就明白莲华和自己理论上是一体的，所以才有绿毛的“我唯一的朋友是莲华”这一句。</p>
<p>而绿毛为了在他人面前让自己和深见夏彦亲近显得合理，她故意称其为“哥哥”（大家都知道绿毛失去家人的过往，所以因此会把她亲近深见夏彦理解为“绿毛把对哥哥的思念寄托在深见身上”）。而绿毛则不需要对莲华隐藏，所以在澡堂里直接说“深见才不是我哥哥呢”。</p>
<p>绿毛在知道深见夏彦的存在后，除去复仇的主线，自然是尝试再构姻缘。所以她引诱深见夏彦去神社，去看杀生石，去看她舞蹈，去听铜铃的声音，给他托梦，目的就是让深见夏彦回想起自己的前世。深见夏彦在经历了若干天的噩梦和梦游（梦游去神社）之后，终于在某一天晚上回想起来了自己的一切。但是深见夏彦已经沉迷莲华，依然坚称自己是深见夏彦而非彦一。</p>
<p>得知恋人心意的绿毛，自然是相当悲愤。我大费周章为你复仇，你却出轨我自己（莲华理论上和绿毛是一体的，可以理解为绿毛是邪恶的一面，莲华是善良的一面），于是托了一个巨大的噩梦给深见夏彦（就是那个，裂嘴黑眼圈的莲华 CG ，这也是游戏发售前就流传出来的梗图），想让他忘记莲华。随后动用了巨大的灵力干趴了学校里所有的学生，尝试吸取她们的灵魂。</p>
<p>而随着调查的深入，莲华也了解了狐妖已经附身到绿毛身上开始复仇，而这个时候绿毛也已经因为深见夏彦的背叛而暴走了。所以为了阻止这些计划，莲华只身一人前往神社和狐妖打灵力战斗去了。</p>
<p>但是莲华毕竟力量并非很充足，最后体力渐渐不支。这个时候深见夏彦突然赶到，给莲华挡下一击。绿毛眼看自己的攻击伤到的是自己的恋人，立马停手了。随后由于巨大的自责，她没有抵挡得住莲华的最后一击而幻化为怨念，被万华镜收纳住了。</p>
<p>绿毛是解脱了，和 H 去过平凡的女高中生生活去了。学校的诅咒也解除了，大家渐渐都回到正轨了。但是深见夏彦的灵魂却因为狐妖的一击变得支离破碎，如果不修复，就等于死亡。莲华这个时候想到了解决方式，就是和深见夏彦一起回到万华镜，让深见夏彦重新回想起来所有的回忆，补全灵魂，最后用莲华的力量让死者复生。这里显然就注意到了，死者复生是违反“理”的，也就是说，莲华最终还是走上了背离天理的路。</p>
<p>莲华和深见夏彦两人在万华镜里遨游，把 1-4 的场景都走了一遍，深见夏彦也渐渐回想起了各种东西，灵魂也渐渐补全。在走完第一圈后，莲华认为已经可以送深见夏彦回去了，但是深见夏彦坚决要和莲华在一起，于是他们又走了第二圈。这之后，莲华并不再是询问语气，而是命令深见夏彦赶快回去。</p>
<p>原因很简单，莲华知道自己也是狐妖的一部分，包括自己的实体化，所动用的灵力的基础都是狐妖赖以生存的力量——人类的悲痛，莲华决定自己超度自己肮脏的灵魂。而这最后的力量就是留给将深见夏彦死者复生的，违反天理的力量。但是深见夏彦最终还是不愿回去，而这个时候他需要经受身边人的各种诘难以确认自己的心意。最后在一通告白之后，两人携手走向又一次轮回。</p>
<p>轮回到第六世的结果，就是深见夏彦成了你（这也就是游戏开头让你输入你的名字的原因），莲华成为了一个知性大姐姐和你相遇，和你相恋。两人最后渐渐回想起了前世，由于狐妖已经消逝，阻碍已经消失，所以两人修成正果，过上了炮火连天的日子。</p>
<h2 id="莲华-非轮回线">莲华-非轮回线</h2>
<p>狐妖的部分都是一致的，第一世到第五世都是一致的，一直到两人走进万华镜都和莲华-轮回线一样。</p>
<p>莲华在第一圈后会询问两次深见夏彦是否愿意回去，第二圈则会再问一次。三次都回答不想回去，才会进入轮回线，只要有一次回答了想回去，就会进入非轮回线。</p>
<p>在这里，最后深见夏彦死者复生，但是他丧失了所有和莲华有关的记忆，“青蜘蛛的诅咒”事件也被科学解释了。苏醒的深见夏彦和月丘以及皇，去和旅馆工作人员、学校老师告别后回到东京过上了平凡的生活。虽然深见夏彦时不时还是觉得自己在搜寻着什么，但是总体而言并没有想起莲华。而莲华的灵魂，也随着狐妖一起被超度，不再和深见夏彦产生任何交集。</p>
<h2 id="绿毛线">绿毛线</h2>
<p>应该说是很单纯的 BE 。</p>
<p>绿毛在无数若干次引诱深见夏彦，让他回想前世之后，最终有一天直接冲进澡堂色诱深见夏彦。这个时候如果选择“放任自己”，则会开启第一段绿毛 H ，否则则会以绿毛无故消失结束这一天。</p>
<p>最后某一晚，深见夏彦再一次前往神社的时候终于回想起了一切，这个时候会有选项问“你是谁”。如果先前压住了枪，这里就会有两个选项，一个是“深见夏彦”一个是“彦一”。选择深见夏彦就进入莲华线，被绿毛噩梦调戏一番后直接开始和莲华炮火连天。选择彦一则进入第二段绿毛 H 。不过在一炮之后，绿毛就会以“我要将你变成我的玩物”为由杀死深见夏彦后自杀。而在现实世界中，消息就是“深见夏彦和绿毛在深山中失踪”。随后两年后，月丘香恋和皇公晓回到这个村子尝试回忆一些什么，误入了深山，看到了杀生石下两人的遗体。</p>
<p>如果先前没有压住枪，那么在问“你是谁”的时候，只有“彦一”一个选项，后面的剧情是一样的。</p>
<h2 id="月丘线">月丘线</h2>
<p>最没有意思的线。</p>
<p>月丘实际上一直喜欢着深见。在主角组前往调查之前，月丘前往深见夏彦的家交代一些工作的事情，这个时候月丘得知深见一直不会做饭，于是她决定给深见做一顿饭。在饭后，带有一点醉意的两人突然趴倒在墙角，男下女上。这个时候月丘向深见表白，会有“接受”和“拒绝”的选项。</p>
<p>拒绝的话就正常开始调查，会调查到很多东西，会有机会进绿毛线、莲华线之类。</p>
<p>接受的话直接开启 H 情节。而因此深见夏彦的心态就变成了“我要尝试融入‘大人’的世界，不能再沉迷于莲华的万华镜了”。而这种心态下，主角组调查的时候，莲华就一直处于很边缘的地位，而月丘和深见则会每晚定时开 H 情节。</p>
<p>这次调查最终无疾而终，莲华在意识到深见的心意之后也只是默默留下一句“那就结束了吧”，便再也不见。主角组回到东京之后，自然是深见和月丘的炮火连天的二人世界。</p>
<h1 id="一些其他地方的想法">一些其他地方的想法</h1>
<p>总体而言还是贯彻了万华镜系列“压住枪的都是好儿郎”的准则，越早压不住枪就只能解锁越少的剧情，然后留下越多的没有起底的伏笔。</p>
<p>虽然说万华镜没啥剧情，但是实际上总体看下来虽然平淡无奇，但还算是叙事完整，能看明白。而且有些伏笔也还算可以，比如说旅馆的“野干（やかん）”面具（“野干”在日语中是狐狸的一种代称），一方面暗示了这里和狐狸有千丝万缕的联系，而最终，绿毛跳舞给深见夏彦看的时候，戴的就是野干面具。另一方面，这个村子叫“薬缶”，和“野干”日语同音，应该是讹传出来的地名。</p>
<p>此外，一定要抨击一下文案，不是说他写的东西多差，是<strong>经常把一些已经约定俗成不写汉字的关联词、虚词写成汉字</strong>，而有的时候又会把<strong>约定俗成写成汉字的词写成假名</strong>。这让我这个现代日语没学好的人读得有那么点难受。举点例子吧：</p>
<div class="note info no-icon"><p>成程 折角 兎に角 沢山 取り敢えず 一寸 丁度 其程 是迄</p>
</div>
<p>他们实际上是：</p>
<div class="note info no-icon"><p>なるほど せっかく とにかく たくさん とりあえず ちょっと ちょうど それほど ここまで</p>
</div>
<p>这些词可以说是，不太懂日语的人只要听到读音都能回想起来点什么的词，结果硬生生给我看不懂了。</p>
<h1 id="最后的最后">最后的最后</h1>
<p>万华镜系列我认为是，中下的剧情，中上的作画，虽然不知道为何如此火，但还是有点为三十个小时感到不值。</p>
<p>但如果闲的话推推也不错，当成一个耗时间的小说吧。不过个人建议先把月丘和绿毛推了，先推莲华会很容易没有推支线的动力，因为莲华线的叙事已经很完备，其他线的逻辑就是误入歧途从而有些事情没发现最后遗憾收场。</p>
<p>知乎上看了一句总结比较好：</p>
<div class="note info no-icon"><p>你以为是你把卖片的上了，谁知道人家是命中注定给你卖片。</p>
</div>
<p>就这样吧，小学期还在等着我。</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
  </entry>
  <entry>
    <title>2021 暑假生活记录</title>
    <url>/2021/06/29/summer-record/</url>
    <content><![CDATA[<p>经过 6 月 22 日到 28 日这几天的折腾，大概和高中的老师、驾校教练等人商量了一些后续的安排。现在终于可以安定下来，准备做一些学习、开发、摸鱼的事情了。</p>
<span id="more"></span>
<p>总体而言，这个暑假想要做的事情其实还是很多的。</p>
<ul>
<li><p>学习一些新东西</p>
<ul>
<li><p>Java / Android 开发相关（或许最终的结果是随便看了看 Java 的语法，装好 IDE 就不做事了）</p></li>
<li><p>汇编语言和量子计算（这属于完全不知道干啥，写在这里是因为小学期）</p></li>
<li><p>Verilog 相关（但是这个属于想想而已，因为对这东西没有兴趣，下学期 xge 带我就好）</p></li>
<li><p>编译原理相关（这个也属于想想而已，写这个是因为自动机学得惨不忍睹，要补一点）</p></li>
<li><p>图形学相关（纯纯因为安主席的安利）</p></li>
</ul></li>
<li><p>跟进一些东西</p>
<ul>
<li><p>实验室项目（主要是最近划了，要跟上）</p></li>
<li><p>THUInfo 的 UI 翻新以及培养计划 / 课程表功能翻新</p></li>
<li><p>科协技能引导文档的结构初始化</p></li>
</ul></li>
<li><p>考试相关</p>
<ul>
<li><p>科目二（再不考是来不及了，大三不计划回家）</p></li>
<li><p>GRE （属于想考一下试一下）</p></li>
</ul></li>
</ul>
<p>此外还有一些杂事，包括买一个新电脑、预定 GRE 考试、选大三的课、重办身份证、回高中讲竞赛、和高中东方同好会线下聚会、陪 Sakana 玩等各种。</p>
<p>因为想做的事情很多，所以想着不如就在这里开一个日记贴，就每天写一下想干什么，最后干了什么之类的。没啥价值，目标就是让自己做点事情，别划水了。</p>
<h2 id="section">2021.06.29</h2>
<p><strong>今天想要做的事情：</strong></p>
<ul>
<li><p>去驾校办理科目二入学手续</p></li>
<li><p>公布科协网络部招新结果，准备一下文档初始化</p></li>
<li><p>CRACKER 一日游，就到处看看有什么资料</p></li>
<li><p>准备 THUInfo 主页 UI 翻新</p></li>
<li><p>问一下韩旭下一步可以做什么</p></li>
</ul>
<p>其实想做的多，最后能做完的，凭运气吧。睡大觉去了，祝自己好梦，祝自己暑假顺利。也祝 Sakana 军训平稳度过。</p>
<p><strong>今天汇报：</strong></p>
<p>基本上弄完了网络部招新的通知工作，飞书还没有完全摸完，这个晚上慢慢来。后面应该要去问一下技术顾问团他们的情况，好准备做点事情。不过考虑到零字班的新生估计还要等他们军训完了才能安排工作，所以初始化应该暂且由老人完成。</p>
<p>给韩旭发了微信消息，等他安排吧。</p>
<p>目前下学期应该是四大原理 + 人机交互 + 计算机网络安全 + 台球 / 网球，所以也可以开始做点准备了。</p>
<p>之后就是逛 CRACKER 。目前的一个打算是汇编和计组应该就通过 CSAPP 先摸一下。计组可能还需要一些 Verilog 什么的东西，这个以后等买了 Windows 电脑再来搞一搞，造 CPU 的那本书也已经拿到手了，也可以拿 PPT 做一些补充。 Java 相关是不打算弄多少，总之和 xge 他们组队搬砖，所以就打算把一些算法代码改成 Java 的，熟悉一下语法算了。</p>
<p>编原那就是纯纯的逆天，因为我自动机学不明白，所以编译原理需要先看一些讲义和 Compiler 那本书。</p>
<p>信号据说是数学课，所以找个课本随便学应该也就应付过去了。网原看起来属于巨大背诵的一门课，找了个《计算机网络：自顶而下》，然后要到了所有的课件，就打算看着玩玩算了。</p>
<p>至于那些限选课，网络安全技术看起来和网原巨大相关，懒得搞。然后就是人机交互没啥经验，就算了。</p>
<p>最后是打算学习图形学，问安主席要到了整本书的电子版，然后找到了网课链接，总之打算干活。</p>
<h2 id="section-1">2021.06.30</h2>
<p><strong>今天想要做的事情：</strong></p>
<ul>
<li><p>去驾校办理科目二入学手续，开始练车</p></li>
<li><p>还有一位网络部新人没有联系上，需要补联系，并且需要搞一下飞书</p></li>
<li><p>推一点点 CSAPP 、图形学什么的</p></li>
<li><p>准备 THUInfo 主页 UI 翻新</p></li>
</ul>
<p>其实也没什么好说的，就是学点新知识之后做一点之前就有的锅。明天要早起所以赶快睡大觉吧。</p>
<p><strong>今天汇报：</strong></p>
<p>以为去报名的，结果刚进去就被拉上车开始练了，估计以后就是早上八点下午两点，一整个白天都要在驾校了，所以推活、上课这些事情都得是晚上来做了。</p>
<p>那个还没联系上的新人联系上了，所以招新基本上就结束了，可以开始具体规划下面一步要做的事情了。然后对下面的工作做了一点点的推进。</p>
<p>然后就是 THUInfo 还在消极怠工，不过最近会开工的，会开工的。</p>
<h2 id="section-2">2021.07.01</h2>
<p><strong>今天想要做的事情：</strong></p>
<ul>
<li><p>科目二学侧方停车、倒车入库、坡道起步</p></li>
<li><p>推一点点 CSAPP 之类的</p></li>
<li><p>准备 THUInfo 主页 UI 翻新</p></li>
</ul>
<p>主要是晚上和家里人聊了比较多，所以说实际上今天晚上也没有认真学一些东西。</p>
<p><strong>今天汇报：</strong></p>
<p>学车真的是比较无聊，就开车十分钟等待两小时，于是其实天气热什么的都不是最大的问题，无聊是最需要解决的。</p>
<p>然后，看了一点信号处理原理和编译原理，然后就发现自己的数学全忘完了，还是得回来再学一点点。</p>
<p>没什么好说的，以后估计就是这样的重复的生活了。</p>
<h2 id="section-3">2021.07.02</h2>
<p><strong>今天想要做的事情：</strong></p>
<ul>
<li><p>科目二继续练习，但是要问清楚考试时间这些东西</p></li>
<li><p>推一点点 CSAPP 之类的（这个真的要赶快了）</p></li>
<li><p>准备 THUInfo 主页 UI 翻新（栋栋跑起来 THUInfo 了，工期来了）</p></li>
<li><p>网络部工作规划再稍微写详细一点，准备主席团会议</p></li>
</ul>
<p>这两天除了科目二看起来什么都没有做呢，所以说下面还是要准备开工吧。之前似乎还说过要买新电脑的，似乎也给我搞忘了。</p>
<p>想到一年前的自己还宣称着一个人孤独地走下去反而好，现在却苦于这里找不到人一起做事，莫名有点可笑。</p>
<p>七月份，下半年的开始，要准备拾起自己了。</p>
<p><strong>今天汇报：</strong></p>
<p>很平凡地过了一天，晚上想回姜堰找人吃饭，结果因为下雨没去得了。学习也没学多少，看了一点点 CSAPP ，但是也是很肤浅。</p>
<p>话说直到现在才猛然发现自己似乎没有什么兴趣爱好，这个时候又突然想到自己之前小学的时候填兴趣爱好，永远都是大众化的“读书”。思来想去，觉得自己可能不太喜欢一直呆着，自己还是比较喜欢在路上的感觉。于是就有了一个还在萌芽的想法，就是只用公交或者地铁，去很远的地方，比如说从家到北京、到广州。也正如我自己感觉的那样，我自己还算喜欢折磨自己。这个规划算是很远期很远期的了。然后问了一下 Sakana 有没有兴趣，但是她也没有给出明确答复。</p>
<p>学习？那是不可能学习的。在闷热的天气底下随时准备被教练喊去练车，这种情况下那是不可能学习的。于是我是真的把贴吧、知乎刷到推荐都开始循环，然后就开始戳 Sakana 等她回复，要么就是水群。但哪里有闲人像我这样一整天啥事没有呢，或多或少都要去做点什么事，打游戏也算。</p>
<p>自己还是很不擅长应对无聊这个问题啊。其实只要有一个聊得来的人在，但是我能聊得来的都有事情，这就尴尬了。</p>
<h2 id="section-4">2021.07.03</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>想做的事情和之前差不多，觉得也没有必要再写一遍了。</p>
<p>大概还有一些感慨吧，感慨自己怎么很容易变得惆怅起来，会有那种莫名其妙的伤感。</p>
<p><strong>今天汇报：</strong></p>
<p>今天下午和明天都不用去练车了，还算比较开心。但是相应的，我需要在这段时间内，把之前剩下来的事情处理好，包括之前自学内容要整理成文字，网络部的工作规划还是要继续细化一下，韩旭那边还要继续跟进。</p>
<p>下午先写一些工作规划，然后等韩旭那边的回复，然后就是写博客了。</p>
<p>然后目前实验室下一步要做的事情就是先调教好 T5 以保证能够做 prompt 。具体的东西会在实验室周报上写，这里就不会写了，毕竟也不是什么太适合公开的东西。</p>
<h2 id="section-5">2021.07.04</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>从驾校休息了一天，计划就是什么事情不做，好好放松一下</p>
<p><strong>今天汇报：</strong></p>
<p>发现自己最大的问题实际上是，闲下来的时候很容易胡思乱想，进而就是情绪容易不稳定。最近身边也没什么了解情况的人可以好好聊聊，所以就比较尴尬了。</p>
<p>今晚似乎喝得有点多，又对 Sakana 说了一堆胡话，大概自己到现在还没学会控制情绪。</p>
<h2 id="section-6">2021.07.05</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>暑期回校的计划最终安定下来了， 6 号开始讲课到 22 号，我主要负责答疑。由于 12 号科目二才能考完，所以打算到时候再回去，这前面的一个星期就晚上线上答疑吧。</p>
<p>要做的事情，大概就是继续看看论文，晚上回学校协商一下后面的安排。至于 THUInfo 和科协那边，真的有点过意不去了快要。</p>
<p>本来想今晚找 Sakana 聊聊的，但看来落空了，所以还是自己调节吧。 Holder 能做到的，或许吧。</p>
<p><strong>今天汇报：</strong></p>
<p>回高中和 FFF 遇了一下，商量了后面的安排。</p>
<p>当然还有一些和 Sakana 那边的事情，这里不多说，但是至少我现在，真的感到很安心很快乐就是了。</p>
<h2 id="section-7">2021.07.06</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>没有什么很想做的，就是很平凡地看书学习、写写 THUInfo 、写写实验室代码、写写科协文档。</p>
<p><strong>今天汇报：</strong></p>
<p>选课掉了康总的计组和人机交互，可能打算去搞 VLSI 来混学分。出乎意料的是台球上了。</p>
<p>自从昨天开始， Holder 就变得似乎没那么难受了，或许也与梅雨渐渐离开有关。今天上午看了一点点 CSAPP ，也预约好了 12 号的科目二考试，之后就是每天去练一练就好。</p>
<p>晚上主要在安排暑培和技能引导文档那边，夏老板突然提到了可以和企业 / 实验室 / 其他学生组织做双向链接，这样的话既解决了文档来源比较单一的问题，也一定程度上提高了文档的实用价值。</p>
<p>【和 Sakana 约了见面再聊，默默期待，还有一些误解，需要慢慢解开】</p>
<h2 id="section-8">2021.07.07</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>因为上午不去驾校，所以睡大觉放松一下。晚上的话照常工作，不过比较紧急的事情是编写竞赛习题解答以及和猫猫准备一下文档的部署。</p>
<p><strong>今天汇报：</strong></p>
<p>回学校了，旁听了 FFF 的一节课。</p>
<p>大概是觉得这一届的基础有点问题吧，很基础的解析几何都没有把握很快给出正解，这就比较困难了。</p>
<p>目前老师的意思是想让我带一下几个有机会去清华夏令营的同学，自己也要开始复习一些自主招生题了。</p>
<h2 id="section-9">2021.07.08</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>回家拿一些当时的自主招生参考资料，然后准备码点字吧。自己的事的话，可能就学习一些基本的东西，然后 THUInfo 开一些工。</p>
<p><strong>今天汇报：</strong></p>
<p>出卷子真的是好累啊，到处翻找资料，然后还要想尽办法保证我是站在一个中学生的角度来思考问题。磨了一整天还熬了一夜，基本上把一份数理化的试卷全都出完了，大概准备 10 号来考这一份卷子，以筛选出适合去清北夏令营的同学。</p>
<p>我现在比较担心的是，大家都考得不高，最后还是拉不开差距。</p>
<h2 id="section-10">2021.07.09</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>学车，然后有什么事情就做什么事情。现在是越来越不太想把自己逼得太紧。</p>
<p><strong>今天汇报：</strong></p>
<p>下午把昨天出的卷子的答案给搞出来了，结果发现这份卷子应该是比较困难的，可能会把他们搞得很惨。</p>
<p>THUInfo 说要开工到现在都没有动静，实验室没干活，科协现在还在筹划。总之就是除了正事之外的事情都在做。</p>
<p>今晚回家的时候突然想起来 GRE 还没有报名，可能都快没有考位了，还是赶快把坑填上。身份证也已经做好了，要找个时间去拿。眼镜有点刮花了，其实要去重配，但是也一直在拖。头发也要去剪一下了，现在还是得注意下形象？</p>
<p>明天早上回学校与那些考试的同学见一下面，监考一下之类的。明天下午尽快把卷子批改好成绩公布。</p>
<p>另外，我仔细思考了一下，暑假还是不要预习下学期的内容为好，暑假应该做一些其他的事情。</p>
<p>所以说这个暑假的主线就变成了 THUInfo 、科协、实验室、高中竞赛、 GRE 。至于新电脑、身份证、眼镜、头发之类的也就是支线任务了，科目二也将会在 12 号迎来终结。</p>
<h2 id="section-11">2021.07.10</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>上午回去监考，下午批改试卷并且和老师交流一下。然后尽可能能开工的东西就得开工，目前比较急的就是实验室和技能引导文档了。</p>
<p><strong>今天汇报：</strong></p>
<p>去监了个考，然后尽快把试卷给批改好了给老师。整体而言学弟们做得还是不错，但是细节上属于是真的需要很大的工夫去训练。</p>
<p>然后就是平凡的学车和练习。</p>
<p>另外就是，盼望 Sakana 回来。</p>
<h2 id="section-12">2021.07.11</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>去高港模考科目二，期间要开始阅读论文，至于能看多少，能领悟多少就是另外一回事情了。</p>
<p>然后就是尽快考虑新电脑的事情，并且尽快制定后面的讲课计划吧。</p>
<p><strong>今天汇报：</strong></p>
<p>高港练车真的是好累好累，一整天就在那里站着看各个考试位的点位，很没意思还很折磨。</p>
<p>当天也没别的什么事情了，出去参加了一个饭局，平平凡凡地结束了一天。</p>
<h2 id="section-13">2021.07.12</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>考科目二，然后回去准备和参加清北夏令营的各位见一个面。顺便安排之后的课程。</p>
<p><strong>今天汇报：</strong></p>
<p>科目二让我整整坐在那里等了六个小时，几乎是最后一个才考的。</p>
<p>于是顺理成章地没有赶得上下午回学校，晚上才和学弟学妹们见了个面，稍微聊了一些没有什么含金量的话题。</p>
<p>Sakana 从上海回来了，但我以后白天就似乎没有什么时间去找她玩了。</p>
<h2 id="section-14">2021.07.13</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>给他们讲一点很简单的东西。</p>
<p>自己也要开始干各种的活了，包括看论文，写 THUInfo 。其实最主要的是科协那边似乎真的拖不下去了。</p>
<p><strong>今天汇报：</strong></p>
<p>上课是真的很累，站很长时间会让自己很累很难受，然后还要说很多话，口干舌燥。</p>
<p>其他倒是没有什么特别的感受，总体而言就是觉得过了很平凡的一天。</p>
<h2 id="section-15">2021.07.14</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>做一些平凡的事情，讲讲课。晚上被提前安排了饭局，所以还是得去。</p>
<p><strong>今天汇报：</strong></p>
<p>照样是讲了很平凡的一些课，没有涉及到很深层次的东西。给他们做了一个限时训练，估计效果不会很好吧。</p>
<p>晚上饭局结束，去了一趟宾馆取回东西。和 Sakana 连麦闲聊了一段时间，约了明天出来玩。然后确定买了一个新电脑，联想拯救者 Y7000 ，显卡只是 RTX3050 ，处理器是 i5 的。买这个电脑是为了混一下大作业，顺便尝试一下一些只有 Windows 有的小游戏。</p>
<p>也是很平凡地结束了一整天。</p>
<h2 id="section-16">2021.07.15</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>和 Sakana 约了去猫咖看看，然后吃烧烤打电动。</p>
<p>本来上午打算睡懒觉的，结果接到消息说清北夏令营同学不放假，所以还得去一趟。</p>
<p><strong>今天汇报：</strong></p>
<p>玩得算是很开心？撸猫很好玩，但是猫毛真的是很烦人，到现在我背后都是微微发痒。撸完猫吃了甜品之后去找 FFF 吃烧烤。随后就去时代广场打电动了。</p>
<p>Sakana 说大夏天的不想出门，但这也算是没办法吧。我俩的暑假完美错开，相交的时间几乎只有一个星期左右，所以要见面的话也就只有这一点时间。不过我的新电脑到货了，以后可以找 Sakana 连麦打游戏。</p>
<p>明天被家里人安排了，后天和 Sakana 约了晚上看 1921 ，大后天就得送她走了。于是这个暑假就这样等价于结束了。</p>
<h2 id="section-17">2021.07.16</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>蹲在学校正常讲讲课，晚上已经有了安排所以就没啥了。</p>
<p><strong>今天汇报：</strong></p>
<p>实际情况是，高中突然出现了电力故障导致学校全部停课，但是参与清北夏令营的同学由于在小教室里没有被电力故障波及所以电力一切正常。但是可以想见的是，看见同学们放假了，他们也完全没有心思学习。所以我就和他们玩狼人杀，聊了聊他们现在的焦虑和压力。</p>
<p>他们不是不想学习，但是高中这个体系给他们的限制实在是比较多，我作为学长也只能劝说他们做一些适应和牺牲。其实有的时候，也真的是毫无方法。</p>
<div class="note info no-icon"><p>有时治愈，常常帮助，总是安慰。 To cure sometimes, to relieve often, to comfort always.</p>
</div>
<p>这是特鲁多的名言，本来是形容医生的。但现在看起来我有的时候也像是这样，我帮不了他们实现他们理想中的高中生活，我最多只能做到帮助他们去理解这个可能有些扭曲的体系，让他们稍微以一种平稳的心态度过高中。</p>
<p>高中这边结束之后就去忙自己的事情了。明天去见 Sakana ， 18 号还有一小波聚会。</p>
<h2 id="section-18">2021.07.17</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>正常地活下去。重要的事情是开工技能引导文档。</p>
<p><strong>今天汇报：</strong></p>
<p>结果上午翘班了，在配置新电脑的 C 语言编译器和装 Python 。结果就这两件事硬生生让我一个上午耗费完了。下午平凡地来高中简单讲了些东西，也顺便做了一些小事情。</p>
<p>晚上陪 Sakana 看了 1921 ，虽然对题材没有特别的兴趣，对演员无感，但感觉看下来还算是一部不错的电影，除了叙事线很多很杂，要不是了解一些历史可能就会错乱吧。</p>
<p>Sakana 不急着 18 号就直接回去了，打算 20 号左右回去，于是就默默约了 19 号再出来玩。</p>
<p>总之就是，一切都在慢慢变好。</p>
<h2 id="section-19">2021.07.18</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>今天约了同学聚会，所以重点会在出去玩上。不过高中这边也应该好好干活。</p>
<p><strong>今天汇报：</strong></p>
<p>和姜东会玩了一个下午一个晚上，先去麦当劳吃饭搓音游，然后星巴克打雀、掼蛋、闲聊，之后定番小菜园聚餐和舞立方手痒打机，最后 KTV 。</p>
<p>KTV 上我唱了不少歌，但最满意的还是《太阳系 DISCO 》。作为自己很喜欢和大家都能参与（指鼓掌和参与オーオオー以及ナナナナナナナー环节）的一首歌，整体气氛还是很好的，比那些大部分人看不懂歌词也不熟悉的比较冷的 V 曲要好一些。当然唱完这首歌我嗓子就明显不行了，中途的一段几乎就是在纯靠喊。</p>
<div class="note info no-icon"><p>あの一等星のさんざめく光で，あなたとダンスを踊ろうか。 ーー「太陽系ディスコ」</p>
</div>
<p>回来之后就是和 Sakana 闲聊了一会，然后转头就装了个有补丁的 Riddle Joker 开始推。由于之前认真推过没有补丁的七海线，所以这次就很快地过掉了，看了一下 H 情节怎么搞的就睡觉去了。</p>
<h2 id="section-20">2021.07.19</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>今天 Sakana 家里有一些事情不能出门了，所以今天见不了面了。有一些话不如连麦的时候随便扯一下吧，晚上陪她打打游戏什么的也不是不行。</p>
<p>其他事情就正常慢慢推进就好。</p>
<p>【我自己依然在为一些虚无缥缈的东西而伤心， Holder 还是需要花一些时间来恢复理性】</p>
<p><strong>今天汇报：</strong></p>
<p>用了点时间给自己的网站加了个评论系统，本来是想用 Valine 的，结果现在较高版本的 NexT 不支持了，所以退而求其次装了 DisqusJS ，他的缺点就是需要翻墙的账号。</p>
<p>之后听从了栋栋的建议换了 <a href="https://twikoo.js.org">Twikoo</a> ，发现是真的好用而且还不用翻墙，现在我直接安利这个评论系统。</p>
<h2 id="section-21">2021.07.20</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>今天 Sakana 回上海了，所以估计是不能去找她了。</p>
<p>Holder 一个人要好好地过好自己的生活。</p>
<p><strong>今天汇报：</strong></p>
<p>大概就是接着修了一下评论系统，然后出去吃了个饭，结果又喝多了（ Holder 从来没有信守过自己的 flag ）。回来之后和 Sakana 连麦闲聊了一点点，似乎一直在说胡话，语无伦次。</p>
<p>之后就是和 LCR 两个人联机打 Minecraft ，但说是一起玩，实际上就是两个人在已经建好的一个挡里面骑马。</p>
<div class="note info no-icon"><p>【 LCR 】芜湖，上次骑马出去忘了把第二只马骑回来， Holder 你没马了。</p>
</div>
<p>大概就这样平凡地过去了一整天。</p>
<h2 id="section-22">2021.07.21</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>今天和高中的老师一起吃饭讨论这几天讲课的情况，实际上 Holder 并没有做出什么很突出的贡献。</p>
<p>接着过下去就好了。</p>
<p><strong>今天汇报：</strong></p>
<p>听闻 LCR 那边可以提供他们宿舍给我住，突然有点想要去上海玩一圈，也正好送一下 Sakana 。但是南京突如其来的疫情让家里人对此很担心，我自己还算是不太认为会影响到什么，但也因此搞得很不愉快就是了。</p>
<p>上海不去就算了吧，反正也只是去见个面，最多晚上陪 Sakana 在交大转转圈，再陪 LCR 打一白天加一晚上游戏。</p>
<h2 id="section-23">2021.07.22</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>好好生活。</p>
<p><strong>今天汇报：</strong></p>
<p>最近一直比较烦躁，不知道是因为无聊还是因为什么。其实能隐隐约约感到实际上就是因为当下各种事情都不顺遂（科协事情没做，实验室那边也在咕咕咕，高中这边还是感觉自己没做到什么有用的事情）加上后面还要和 Sakana 失联，一下子又没有了倾诉的人， FFF 不久出去旅游，这下子是真的没有谁出来一起玩了。还是那句话，想到一年前的自己甘愿一个人闭锁在黑暗的房间里，独自对着屏幕无论是欢笑还是难过，都不愿意和其他人过多交流，现在的我无疑是对过去的讽刺。</p>
<p>不过稍微好一些的是，我可能解开了一些心结。概括来说大概就是，我以往认为自己伤感的来源是别人变得特立独行而怪异，但是自己认认真真享受过生活之后，我才认识到，以往昏暗的我才是最为特立独行的。</p>
<div class="note info no-icon"><p>从一个本就不合群还自认为合群的人的眼光之中看去，那一切的平凡和正常，反倒是怪异。</p>
</div>
<p>所以 Holder 重新立起 flag ，从今开始好好生活。</p>
<p>【箴言： Holder 的 flag 没有不倒的】</p>
<hr />
<p>于是今天上午的 Holder 起床之后就在 Riddle Joker ，现在应该只剩下茉优线没有完全结束了（年上系真的不在我的 XP 上，最后推自然没有任何的问题）。</p>
<p>中午的 Holder 开始到处看 V 曲的 live ，真的突然想去一次 V 家演唱会。要说现场感比较好的歌的话，<a href="https://www.bilibili.com/video/BV1Nf4y1U7z1?t=279">《 Unknown Mother Goose 》</a>是首推（众人おおおーおおー的那个场面真的是很震撼的），之后就是<a href="https://www.bilibili.com/video/BV11W411C7io?t=295">《劣等上等》</a>（ Giga 的专业炸场子歌），<a href="https://www.bilibili.com/video/BV16s411h7eE">《号哭》</a>和<a href="https://www.bilibili.com/video/BV1As411B7J8">《东京泰迪熊》</a>也算是很有感觉的。然后就似乎沿着推荐来到了几个网络合唱视频，首先是 2017 年的<a href="https://www.bilibili.com/video/BV1Nx411u7YT">《砂之惑星》</a>（八爷 yyds ，可惜出道娱乐圈了，当个 P 主不好么），然后是 2011 年的<a href="https://www.bilibili.com/video/BV1Ax411w7Sh">《千本樱》</a>，也算是猛然回忆起高中的一些时光了。</p>
<p>之前在<a href="/about">关于页</a>提到我最喜欢《无梦之梦》，但是这首歌适合一个人在难过的时候自己听，用来做安慰用的。其实春卷饭的歌基本都是这个特征，很温柔，适合一个人独自欣赏，很难在演唱会上表演得好。同理还有新曲<a href="https://www.bilibili.com/video/BV1hA411g7mt?from=search&amp;seid=51222177324975189">《第三心脏》</a>，也是最近很喜欢的。</p>
<hr />
<p>最终通过一番协商，还是决定去上海了。自己的一时冲动把 Sakana 还有家里人的安排搞得一团乱，说实话现在还是有一点愧疚。然后在安排在上海的行程的时候，发现竟然想不到可以去哪里玩。</p>
<p>所以说， Holder 的脑子一热带来的是无数若干的混乱，让 Sakana 落单还拉着她一起不知道干什么，一时间不知道说什么好。</p>
<p>今天 Sakana 应该是和同学们出去玩去了， Holder 一个人默默地去未来极越把卡里的钱给用掉了，之后骑车绕县城转了一圈。</p>
<p>一个人真的很无聊，无聊的时候就喜欢胡思乱想，然后可能就会做出很没有理由的事情。</p>
<p>惋惜我自己的高中没有发展若干的朋友，导致现在回到家乡竟然是四处无人。还不如早点回北京，至少我的舍友可以一起打牌，一起出去找地方看个电影或者是到处找点吃的。或者就是找北大的几个熟人出去转转，要么也可以和迅哥哥等 308 闲聊。</p>
<p>于是 Holder 又开始莫名难过起来， Holder 自以为值得夸耀的，竟然是一片荒芜。</p>
<p>Holder 嫉妒且憎恨着那些现实生活充实的人们，虽然这种无名火显得幼稚且没有道理。 Holder 似乎就像是对着并不存在的敌人宣战一般，对着自己幻想中的困境，对着不存在的挫折精神低落而恍惚。</p>
<p>那个好好生活的 flag 突然显得可笑。</p>
<hr />
<p>我一直在思索着，现在的我的生活多么像我先前的追求。和同学彻夜聚会，和 Sakana 看电影、逛街、撸猫，即使一地鸡毛但依然决定去上海，那种自由挥洒情感，自由表达自己，不计成本地为了简单的目标而大闹一番的生活。然而我却似乎不像是之前那样无忧无虑，我每天都被一种不能明状的忧伤所萦绕。即使某天我说我释怀了，我看开了，我似乎找到了生活的乐趣。即使我这么说，我的心中实际上从未解开过这种难过的感情，只不过是因为当下的愉悦而暂且麻痹。</p>
<p>在房间里自说自话地走了几圈，尝试理清楚自己这个情感的来源。结果还是不太弄得明白，所以暂且作罢。</p>
<h2 id="section-24">2021.07.23</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>逃到上海，然后不知道干什么。</p>
<p><strong>今天汇报：</strong></p>
<p>单纯地溜来上海了， Sakana 因为绿格那边的政策一直没有很能确定下来比较低落，于是也就很单纯地一起吃了饭，去了私影玩了一圈而已。</p>
<p>晚上打算玩冬日计划，结果因为网络原因一直没有能够一起玩得了，只能作罢。</p>
<h2 id="section-25">2021.07.24</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>和 LCR 混一天。</p>
<p><strong>今天汇报：</strong></p>
<p>大概就是中午先和 Sakana 吃了一顿饭然后就和 LCR 一起到处瞎跑了。</p>
<p>本来的预定是去外滩，沿着江边随便走走，结果 LCR 在地铁半路上突然提到想要去海边，但是已经出发一段路了，就决定去黄浦江入长江口转一圈。地铁坐了整整两个小时到双江路下，然后就是沿着黄浦江骑车十几公里。本来以为沿着江边能看到什么的，结果全是造船厂，能看到的就是一堆重型机械和工人们。值得一提的是本来今天是台风来的日子，结果雨是真的没有下下来，倒是风是相当的大，大到我骑车下坡不蹬的话，风会把我吹上坡。</p>
<p>然后就是沿着一条路一路骑到了入江口，那里的风已经是相当大了，但依然没有能阻挡钓鱼佬们翻越围墙站到江边的防波堤上钓鱼。自己胆子小，就没翻过去看看，所以也就站在墙外拍了照片，打了个车回去了。</p>
<p>至于今晚发生的一些并不太愉悦的事情，还是暂且不提吧。只能说现在的 Holder 不太振作得起来。</p>
<h2 id="section-26">2021.07.25</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>活着。</p>
<p><strong>今天汇报：</strong></p>
<p>台风终于登陆上海了，整个天都是漆黑的那种，狂风大作暴雨如注。然而我还是和 LCR 两个人出了门在上交里面转了好长一段时间，跑去下院瞎窜，去思源湖边上看台风，去宿舍楼的风口看被吹倒的树。</p>
<p>反正就是两个不要命的人在台风天的无聊之举，和昨天顶着台风去江边上差不多。结果是误了回去的火车，不得不立刻改签第二天的。</p>
<p>Sakana 自然在台风天不愿意出来，所以一整天都没有见到，晚上喊她打游戏也没有理我，说是没有兴致。</p>
<h2 id="section-27">2021.07.26</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>继续活着。</p>
<p><strong>今天汇报：</strong></p>
<p>早上爬起来就接到了火车取消的消息，于是不得不接着留一天。</p>
<p>早上和 LCR 就一直在打 Minecraft 消磨时间，生存档从零开始真的是很耗时间的一种玩法。玩好了之后和 Sakana 说了下午陪她去做核酸，最后是自己任性地拉着她冒着还算不小的雨去了天街。</p>
<p>晚上没事做，于是合计了一下和 LCR 又出门了，结果是一天去了两次天街（这个时候就得说交大旁边真的是没啥玩的，除了两个商场、一个桌游店、一个 KTV 、若干小饭馆之外似乎什么都没有了，喊 Sakana 出门最终的归宿永远是找一个吃饭的地方闲聊，最多去看电影）。</p>
<h2 id="section-28">2021.07.27</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>回家，然后活着。</p>
<p><strong>今天汇报：</strong></p>
<p>早上 Sakana 突然说打算送我去火车站，但实际上我知道她出远门的东西还没收拾好，但还是答应了。</p>
<p>然后就没有什么特别的事情了，在火车站拥抱后分别，自己一个人坐火车然后兜兜转转回到了家，冒着雨赶去高中。</p>
<p>一整天都过得比较累，回来之后又不得不通宵清掉了一些任务。</p>
<h2 id="section-29">2021.07.28</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>清闲地活着。</p>
<p><strong>今天汇报：</strong></p>
<p>今天是给高中的学弟学妹们考试的日子，自己是出题人也是监考。监考这个活是真的令人烦躁，无聊至极，甚至愿意出点事情让自己不至于无聊。</p>
<p>Sakana 最终踏上了旅程，坐了十个小时的火车前往兰州，她也在经受着无聊的时光。两个人一起听歌了一个小时，她到达兰州之后需要办理一系列的事务，便暂且失联了。</p>
<hr />
<p>不过 Holder 似乎算是慢慢理清楚自己到底在担忧什么了，异地造成的交流不畅和误解真的是相当折磨。不多说吧，总之就是意识到了我和 Sakana 处境其实类似，而我潜意识里深刻地误解了很多的事情而已。所以现在应该心态平稳很多了， Holder 也已经下定决心要保证自己生活乐趣的多元化了。</p>
<h2 id="section-30">2021.07.29</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>一个人活着。</p>
<p><strong>今天汇报：</strong></p>
<p>今天什么都没有发生，起床吃饭，一个人躺在床上刷手机。就是典型的一个无聊的人应该有的样子。</p>
<p>现在 Sakana 应该到达了最终的目的地，可能以后就会是几乎完全失联了。大概如此。</p>
<h2 id="section-31">2021.07.30</h2>
<p><strong>今天想要做的事情：</strong></p>
<p>把科协暑培好好弄好。</p>
<p><strong>今天汇报：</strong></p>
<p>Sakana 现在彻底处于失联状态了，多半是不到晚上联系不上了。虽然有点消沉，而且为生日怎么办的事情有点烦躁，但是自己的事情还是得好好做下去。</p>
<hr />
<p>就这样吧，这个纪录就此结束，新的生活渐渐就要开始了。</p>
<p>Holder 通过这个暑假，大概是缓慢地将自己的心态平稳下来了，或许还有一些不能言说的不舍、迷惘、辛酸等等，但暂且都埋藏起来吧。不过相较于一个自闭的 Holder ，虽然现在的我或许不如以往那样沉稳专注，但可能更像一个正常的人吧。</p>
<div class="note info no-icon"><p>あたしが愛を語るのなら，そのすべてはこの歌だ。 誰も知らないこの物語，また口ずさんでしまったみたいだ。 「 Unknown Mother Goose 」</p>
</div>
<p>总而言之，或许还有许多的困难，还有许多的考验，还有很多我们需要去做的事情，但我依然坚信未来可期。</p>
<p>我是 Holder ，我们继续走下去吧。</p>
]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
  </entry>
</search>
