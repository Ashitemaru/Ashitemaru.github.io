---
title: 可微渲染项目记录
date: 2022-04-14 10:56:37
mathjax: true
category:
    - 科研杂谈
---

进入图形学方向的第一个项目，就简简单单记录点东西。

比如说学到了一些零零散散的东西之类，论文笔记之类的自然还是单开。

<!-- more -->

$$
\newcommand{\lm}{\left[\begin{matrix}}
\newcommand{\rm}{\end{matrix}\right]}
\newcommand{\b}{\boldsymbol}
$$

# 配置服务器

大约是从学长那里捡到了一个已经近乎报废的电脑主机，主板是已经停产的 Intel E8，倒是显卡是有 8G 显存的 GTX 1080Ti，要不是看上这点显存可能都不打算把这个主机修好。

首先是买了 SSD，一开始是打算装 Windows 系统的。但几经周折，即使装完了 Windows 系统，系统启动后的系统中断居然就能把 CPU 跑到 100%，这着实令人诧异。不过想想这个电脑的惨状，倒也能理解了。

一星期后又花了点时间装了个 Ubuntu，这下子跑起来了，还算是能带的起来这个系统。然后就是无尽的装显卡驱动、装 CUDA、装 CudNN、装 Pytorch、装 Pytorch3d 还有一堆基础工具链，这些东西整好了都已经快四月了。

然后为了保证我能在宿舍里用这台机子，就给它插了网线、配置了静态 IP，开放 ssh 服务。到三月底，总算是让这个机子变成一个服务器了，虽然性能不好说。

---

好玩的是，现在我每从远程拉取最新的项目代码，大约有 50% 的几率跑不起来，而且都是炸在各种不能理解的地方。这个时候一般就是重装显卡驱动、重装 CUDA、重装 Pytorch、重装 Pytorch3d 一把梭了。

# Tensorboard 服务器配置

由于是在做图形学，训练结果是包括图片乃至视频的，不能单单用终端看，所以大约是需要写一个小后端的。比较好的是 Tensorboard 已经是比较成熟的了，所以只需要在程序里面用 tmux 开一个 Tensorboard 在 8000 端口上，之后 ssh 设置一下静态转发：

{% codeblock lang:bash Bash %}
ssh -L 16006:127.0.0.1:8000 holder@166.111.69.73
{% endcodeblock %}

这样也就可以在浏览器里面通过 `127.0.0.1:16006` 来访问 Tensorboard 服务器了。

但问题就在，Tensorboard 至多允许每 30 秒刷新一次数据，其实不太满足实时性的需求。但考虑到 Tensorboard 生成数据是实时的，只不过它的后端拉取太慢，似乎我的学长自己摸索了一套解析 Tensorboard 数据的东西来实时观测，那可能就暂时没我事情了。

# `-lcuda` 的问题

在某一次更新项目代码之后，完全无法运行，报的错大约是链接器不理解 `-lcuda`。这个错是好理解的，基本上就是缺失了 `libcuda.so` 动态库文件，但是问题就在于，我明明在 `LD_LIBRARY_PATH` 下找到了这份文件，但是链接器就是找不到。

之后我直接一波 `sudo find / -name 'libcuda.**'` 扫了一遍文件树，似乎是在 `**/stub/` 之类的什么地方找到了一份链接库，本以为万事大吉的时候，发现用这个库是无法链接的。

上网找了一波，似乎是 `**/stub` 是一个临时目录，其不能用于链接之类的。

然而在这期间，我也找到一个说法，说 `-lcudart` 和 `-lcuda` 作用是一样的。但现在问题是，链接器脚本是构建过程中生成在 cache 里面的，而项目构建脚本里面也设置不了用 `-lcudart` 替代 `-lcuda`。

但 Holder 还真找到了方法，我直接翻到 Pytorch 的源码库，根据报错信息一路翻，终于翻到了它配置链接器设置的源码，手动用 `-lcudart` 换掉了 `-lcuda`，结果还真行了，但是后续会出现一些问题，我想大概是 `libcudart.so` 和 `libcuda.so` 对一些方法实现不太一样。

然后怎么解决的？直接把显卡驱动重装了，问题圆满解决。

# OpenGL 的一些函数

OpenGL 应该是很常用的一个库，内部包含了大量辅助运算的函数，但是怎么用还是需要自己慢慢摸索。这里使用的是 Python 中的 OpenGL，包名称为 `glm`。

## 坐标系变换函数

考虑模型坐标系、世界坐标系、视图坐标系之间的关系，这三者分别指代以某个模型的某一点为原点的坐标系、绝对坐标系和以观察者（相机）为原点的坐标系。我们考虑这三者之间的转换。

### 视图转换与 `glm.lookAt`

假设相机位于 $\b{p}(p_1, p_2, p_3)$ 点处，相机正上方指向 $\b{u}(u_1, u_2, u_3)$，相机朝向的**反方向**为 $\b{l}(l_1, l_2, l_3)$，那么相机的右侧可以通过叉积得到：

$$
\b{r}(r_1, r_2, r_3) = \b{p} \times \b{l}
$$

这里我们令 $\b{u}, \b{r}, \b{l}$ 都是单位矩阵。

假设将相机平移到世界坐标系原点的矩阵为 $T$，将相机旋转到看向世界坐标系 $-z$ 方向、向上方向为世界坐标系 $+y$ 方向的旋转矩阵为 $R$，那么我们调整相机的矩阵就是 $RT$，而这也就是视图坐标系转换为世界坐标系的转换矩阵。我们所谓的**视图转换**是将世界坐标系转入视图坐标系，所以视图转换矩阵 $V = (RT)^{-1}$。

显然：

$$
T = \lm
I_3 & -\b{p} \\
\b{0}_3^T & 1 \\
\rm = \lm
1 & 0 & 0 & -p_1 \\
0 & 1 & 0 & -p_2 \\
0 & 0 & 1 & -p_3 \\
0 & 0 & 0 & 1 \\
\rm
$$

并且可以显然得到 $R$ 的逆矩阵：

$$
R^{-1} = \lm
\b{r} & \b{u} & \b{l} & \b{0}_3 \\
0 & 0 & 0 & 1 \\
\rm = \lm
r_1 & u_1 & l_1 & 0 \\
r_2 & u_2 & l_2 & 0 \\
r_3 & u_3 & l_3 & 0 \\
0 & 0 & 0 & 1 \\
\rm
$$

所以视图转换矩阵的逆为：

$$
V^{-1} = RT = (R^{-1})^TT = \lm
r_1 & r_2 & r_3 & -\b{r} \cdot \b{p} \\
u_1 & u_2 & u_3 & -\b{u} \cdot \b{p} \\
l_1 & l_2 & l_3 & -\b{l} \cdot \b{p} \\
0 & 0 & 0 & 1 \\
\rm
$$

{% note info %}
对于仿射变换的矩阵：

$$
T = \lm
A & \b{t} \\
\b{0}_3^T & 1 \\
\rm
$$

我们很容易验证其逆矩阵为：

$$
T^{-1} = \lm
A^{-1} & -A^{-1}\b{t} \\
\b{0}_3^T & 1 \\
\rm
$$
{% endnote %}

所以 $V$ 此时也是显然的了。只要清楚对于两两正交的单位向量 $\b{l}, \b{r}, \b{u}$ 有：

$$
(\b{l} \cdot \b{p})\b{l} + (\b{r} \cdot \b{p})\b{r} + (\b{u} \cdot \b{p})\b{u} = \b{p}
$$

即可知道：

$$
V = \lm
r_1 & u_1 & l_1 & p_1 \\
r_2 & u_2 & l_2 & p_2 \\
r_3 & u_3 & l_3 & p_3 \\
0 & 0 & 0 & 1 \\
\rm
$$

而 `glm.lookAt` 则是根据相机参数构建了矩阵 $V^{-1}$。