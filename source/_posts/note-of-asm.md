---
title: 《汇编语言程序设计》学习笔记
date: 2021-08-09 14:22:58
mathjax: true
category:
    - 计算机科学
---

这门课是 2021 年暑期学期开设的计算机系专业课，应该也算是为下学期的《计算机组成原理》课程做预备，所以还打算好好学一下。

<!-- more -->

# 课程基本介绍

## 汇编语言介绍

汇编语言可以认为是机器指令的一种表记方式，其表述了计算机硬件系统对外开放的主要接口和规格，是计算机系统之中的软硬件的分界。所以说要了解汇编语言，就首先需要了解机器指令。

机器指令系统一般分为两类：

- CLSC ，即**复杂指令系统**。一般而言具有多种指令，寻址方式复杂，单条指令的功能较为复杂。较为经典的代表是 X86 。

- RISC ，即**精简指令系统**。考虑到实际使用的指令大多都是简要指令，故该系统只具有常用的精简指令。在这样的条件下，该指令系统依赖于编译器产生高效的代码（依赖编译器优化）。较为经典的代表为 MIPS 。

目前， CLSC 和 RISC 之间的差别渐渐缩小。但是还是具有明显的区分方式的，即：

{% note info no-icon %}
It loads / stores [with / without] other operations.
{% endnote %}

借助于连接软硬件的机器指令集，计算机系统实现了软硬件解耦合。这样软硬件可以独立编写，从而促进了计算机的发展。

**注解：**软硬件的分离的一个重要基石是**图灵完备性**。也就是说软件使用的高级语言是图灵完备的，硬件的指令序列也是图灵完备的，这两者完全等价。这样才保证了分离的可行性。

## X86 指令集介绍

X86 指令集具有以下的基本特征：

- 向下兼容、变长指令、多种寻址方式

- 通用寄存器个数有限（ X86-32 具有 8 个通用寄存器， X86-64 具有 16 个通用寄存器）

- 至多允许一个操作数在内存中，另外一个操作数需要在寄存器中或者是立即数

{% note info no-icon %}
这里提到了寄存器。 X86 之中的寄存器命名为：

| 寄存器名称【 X86-64 名称】 | X86-32 名称 | 寄存器名称【 X86-64 名称】 | X86-32 名称 |
| :-: | :-: | :-: | :-: |
| `%rax` | `%eax` | `%r8` | `%r8d` |
| `%rdx` | `%edx` | `%r9` | `%r9d` |
| `%rcx` | `%ecx` | `%r10` | `%r10d` |
| `%rbx` | `%ebx` | `%r11` | `%r11d` |
| `%rsi` | `%esi` | `%r12` | `%r12d` |
| `%rdi` | `%edi` | `%r13` | `%r13d` |
| `%rsp` | `%esp` | `%r14` | `%r14d` |
| `%rbp` | `%ebp` | `%r15` | `%r15d` |

{% endnote %}

由于 X86 重视向下兼容，所以其指令集越来越趋向于庞杂，所以其一个缺点就是资源利用率低。

## MIPS 指令集介绍

MIPS 的设计思想是充分利用处理器的流水线结构，目标是让流水线各段负载均匀，这样可以让处理器频率得到提高。其特征包括：

- 以寄存器为中心，只有 Load 以及 Store 命令可以访问内存

- 所有计算操作均是从寄存器堆之中读取数据并将结果保存到寄存器堆

- 指令格式规整、定长，且操作码位置固定，指令类型少（ MIPS32 的指令只有 register / immediate / jump 三类）

- 寻址方式简单，每一条指令的操作过程简单

当然， MIPS 也具有一些被扩展过的扩展指令集，如 MIPS16e 等等。

此外， RISC-V 也是一种常用指令集。但其几乎和 MIPS 同源，故这里不作详细介绍。

# 整数的表示与计算

首先我们介绍一些简要表记，即 K / M / G / T / P / E 。符号 K 表示 $2^{10}$ ，之后有 ${\rm M} = 2^{10} \cdot {\rm K}$ 以及 ${\rm G} = 2^{10} \cdot {\rm M}$ ，依此类推。

同时我们将一个二进制位称为**比特（ bit ）**，将八个比特称为**字节（ byte ）**。在 X86 架构下，两个字节称为一个**字（ word ）**，而在 MIPS 架构下则是四个字节。

对于数的进制、二进制数的逻辑运算，这里不进行介绍。

## 机器字和字节序

首先引入**机器字**的概念，机器字指的是计算机进行一次整数运算所能处理的二进制数据组，也可以是一个数据地址。相应的，**机器字长**指的就是一个机器字的位数。对于 32 位字长的计算机，其地址能够表示的空间大小为 4GB 左右。机器字长越大的计算机，其地址的表示空间就越大。

机器字的定位为这个机器字第一个字节的地址，所以说相邻机器字的地址之差在 32 位系统之中为 4 ，而在 64 位系统之中为 8 。

**字节序**指的就是一个机器字所包含的字节在机器字之中的排列的顺序，分为**大端序（ Big endian ）**以及**小端序（ Little endian ）**。大端序指的是低位字节占据高地址，小端序则相反。

比如说十六进制数据 `0x01234567` ，如果这个机器字地址为 `0x100` 。那么在大端序之下， `0x100, 0x101, 0x102, 0x103` 的字节内容分别为 `01, 23, 45, 67`。而在小端序下则是 `67, 45, 23, 01` 。

## 整数的二进制编码

我们首先复习一下 C 语言之中各个数据类型的大小，这里以字节作为单位：

| 数据类型 | 经典 32 位系统 | X86-32 | X86-64 |
| :-: | :-: | :-: | :-: |
| `char` | 1 | 1 | 1 |
| `short` | 2 | 2 | 2 |
| `int` | 4 | 4 | 4 |
| `long` | 4 | 4 | 8 |
| `long long` | 8 | 8 | 8 |
| `float` | 4 | 4 | 4 |
| `double` | 8 | 8 | 8 |
| `long double` | 8 | 10 / 12 | 10 / 16 |
| 指针 | 4 | 4 | 8 |

这里我们为了简便，使用 16 位系统来演示整数的编码方式，也就是说机器字长为 16 位，一个整数使用 2 个字节表示。

### 有符号数的编码

对于非负的整数，显然可以直接使用其二进制表示作为其编码。比如说十进制数 `12345` ，其二进制表示为 `00110000 00111001` ，那么其编码就是 `00110000 00111001` 。

对于负数，一种解决方式是使用最高位表记符号，最高位为 `1` 的数为负数，为 `0` 的数为非负数。然而这样会导致加法器在运算的时候需要首先验证符号位，计算出结果后还需要计算符号为，比较繁杂。所以说这里引入了**补码（ two's complement ）**，用补码表示的整数可以简化有符号整数的计算。

非负数的补码就是其二进制表示，负数的补码是其绝对值的二进制表示按位取反之后加一。

比如说十进制数 `-12345` ，由于 `12345` 的二进制表示为 `00110000 00111001` ，首先按位取反得到 `11001111 11000110` ，最后加一得到其补码为 `11001111 11000111` 。

这个时候符号位依然存在，也就是说补码表示下负数最高位为 `1` ，非负数最高位为 `0` 。

{% note info no-icon %}
补码的优越性在于简化了有符号整数的加法计算。如果我们使用 ${\rm TC}_w(x)$ 表示字长为 $w$ 的系统下整数 $x$ 的补码（比如 `-12345` 的补码为 `11001111 11000111` ，后者直接转换为十进制表示的是 `53191` ，那么定义 ${\rm TC}_w(-12345) = 53191$ ）。实际上可以发现对于非负数 ${\rm TC}_w(x)=x$ ，而对于负数：

$$
{\rm TC}_w(x) = 1 + \mathop{\sim}(-x)
$$

而对于字长为 $w$ 的系统， $x + (\mathop{\sim}x) = 2^w - 1$ ，所以说对于负数 $x$ 有：

$$
{\rm TC}_w(x) = 1 + 2^w - 1 - (-x) = 2^w + x
$$

所以无论如何我们都可以断定：

$$
{\rm TC}_w(x) \equiv x\ ({\rm mod}\ 2^w)
$$

在这样的条件下做加法是简单的，因为一个整数和其补码在模 $2^w$ 意义下等价。后面讨论补码条件下的加法的时候，即使出现截断，由于所截断的 `1` 必然位于不低于 $2^w$ 的位上，所以截断还是不会影响模的结果。
{% endnote %}

对于字长为 $w$ 的系统，按照补码表示的有符号数系统之中，最大的数为 $2^{w - 1} - 1$ ，而最小的数为 $-2^{w - 1}$ 。

### 无符号数的编码

无符号数的编码是简单的，因为其只需要考虑非负数，所以直接使用二进制表示作为编码就可以了。

这种系统之下，最大的数为 $2^w - 1$ ，而最小的数为 $0$ 。

### 有符号数和无符号数的关系和转换

现在我们已经给出了有符号和无符号整数的表示方式了。现在考虑将一个有符号整数强制类型转换为无符号整数，比如说在机器字长为 4 的时候， `-4` 的补码为 `1010` ，而强转为无符号整数的时候， `1010` 则表示 `12` 。其实不难证明对于字长为 $w$ 的系统，有这样的关系：

$$
(\text{unsigned})x = \\begin{cases}
x & x \\geq 0 \\\\
x + 2^w & x < 0
\\end{cases}
$$

这里提一下，在 C 语言的比较运算之中如果同时出现有符号数和无符号数，则会将有符号数强制转换为无符号数。当然，如果两边都是有符号数，则按照有符号数的比较规则进行。

事实上，由于这样的隐式转换，如果我们给声明为无符号整数的变量赋予一个负数值，就有可能被强制转换为一个大整数，从而导致违反直觉的结果，甚至导致错误。所以说我们应当谨慎使用无符号整数，一般而言，只有涉及到**模运算**或者单纯使用**位运算**的时候无符号整数比较适合。

## 整数的计算

### 无符号整数的加法

对于字长为 $w$ 的系统，两个整数的加法可能会需要 $w + 1$ 位才能表示，这个时候就会发生**溢出**。计算机的一般处理方式是舍去最高位，强制仅用 $w$ 位表达计算结果，其实相当于对 $2^w$ 取了模。也就是说，字长为 $w$ 的、带有截断的无符号整数加法为（这里，符号 $+^{\text u}_w$ 表示的是字长为 $w$ 的系统下无符号整数的加法）：

$$
x +^{\text{u}}_w y =\\begin{cases}
x + y & x + y < 2^w \\\\
x + y - 2^w & x + y \\geq 2^w
\\end{cases}
$$

### 有符号整数的加法

在字长为 $w$ 的、使用补码的系统下，对于有符号整数 $x, y$ ，其加法是有可能溢出的。

一种是两个大正数相加，超越了补码能表示的最大整数。此时补码的符号位承接了较低位溢出的 `1` ，也就是说补码之和实际上代表一个负数。由于负数 $u$ 的补码 ${\rm TC}_w(u) = u + 2^w$ ，这个负数实际上就是 $x + y - 2^w$ 。这种情况被称为**正溢出**。

另外一种是两个绝对值很大的负数相加，超越了补码能表示的最小整数。此时补码符号位两个 `1` 相加得到 `10` ，溢出为 $w + 1$ 位数，但是最高位的 `1` 被截断。另外，较低的 $w - 1$ 位不会向上进位（绝对值很大的负数的补码较低位所表示的数实际上会很小）。此时结果的补码符号位为 `0` ，代表一个正数。由于负数 $u$ 的补码 ${\rm TC}_w(u) = u + 2^w$ ，考虑到截断了一个 `1` ，所以该正数为：

$$
(x + 2^w) + (y + 2^w) - 2^w = x + y + 2^w
$$

这种情况被称为**负溢出**。

对于求和结果在表示范围内的，补码的和（截断为 $w$ 位后）就是和的补码。这是因为 $x, y$ 的补码相加后截断，所代表的数与 $x + y$ 模 $2^w$ 同余，而 $x + y$ 位于补码能表示的范围内，所以 $x, y$ 的补码相加后截断得到的就是 $x + y$ 的补码。

总而言之，字长为 $w$ 的、带有截断的有符号整数加法为（这里，符号 $+^{\text t}_w$ 表示的是字长为 $w$ 的系统下无符号整数的加法）：

$$
x +^{\text{t}}_w y =\\begin{cases}
x + y - 2^w & x + y \\geq 2^{w - 1} \\\\
x + y & -2^{w - 1} \\leq x + y < 2^{w - 1} \\\\
x + y + 2^w & x + y < -2^{w - 1}
\\end{cases}
$$

### 无符号整数除以 2 的幂

一般而言在计算机中，除法计算消耗的时间是相当长的。但是对于除数是 2 的幂的情况，我们可以使用移位的方式简化计算。

左移是很好理解的，溢出的部分会被截断，低位会用 `0` 补齐。但是右移的时候，低位截断是自然的，但是高位如何补齐则有两种方式。如果高位用 `0` 补齐，这种移位称为**逻辑右移**。如果用原数的最高位补齐（这里的最高位可以是 `0` ，比如 16 位系统之中的 `00000000 00000001` 的最高位为 `0` ），这种移位称为**算术右移**。

在字长为 $w$ 的系统下，我们将无符号的逻辑右移标记为 $>^{\text{ul}}_w$ ，无符号的算术右移则标记为 $>^{\text{um}}_w$ 。

**注解：**有符号的右移则将上标的 $\text{u}$ 替换为 $\text{t}$ 。

其实对于无符号整数 $x$ 不难得到：

$$
x >^{\text{ul}}_w k = \\left\\lfloor \\frac{x}{2^k} \\right\\rfloor
$$

### 有符号整数除以 2 的幂

首先说明，我们希望除法的结果**向 0 舍入**，也就是说 `23.6` 舍为 `23` ， `-24.6` 舍为 `-24` 。

这里我们依然使用右移来简化除法计算。但是我们注意到负数除以 2 的幂之后必然还是负数，所以不能使用逻辑右移，只能使用算数右移。这个时候，对于有符号整数 $x$ 我们可以简单地使用 $x >^{\text{tm}}_w k$ 来计算 $x / 2^k$ 。

对于正数，这样的计算显然是正确的。但是对于负数，比如说 `-15213` ，其补码为 `11000100 10010011` 。我们计算其除以 `256` 的商，按照上面的计算方式即将其补码算术右移 `8` 位，得到 `11111111 11000100` ，结果为 `-60` 。然而我们知道实际的结果应当为 `-59.43` ，按照舍入应当保留为 `-59` 。

{% note info no-icon %}
事实上我们可以说明：

$$
x >^{\text{tm}}_w k = \\left\\lfloor \\frac{x}{2^k} \\right\\rfloor
$$

也就是说**使用算术右移计算有符号整数的时候永远得到向下舍入的结果**。我们只要说明负数的情况即可，对于负数 $x$ 的补码 $x_{w - 1}x_{w - 2} \\cdots x_0$ ，我们设二进制数 $x_{w - 1}x_{w - 2} \\cdots x_k$ 表示数 $x'$ ，二进制数 $x_{k - 1}x_{k - 2} \\cdots x_0$ 表示数 $x'' < 2^k$ 。显然：

$$
2^k x' + x'' = {\rm TC}_w(x) = 2^w + x
$$

而 $x >^{\\text{tm}}\_w k$ 得到的是 $x\_{w - 1}x\_{w - 1} \\cdots x\_{w - 1}x\_{w - 2} \\cdots x\_k$ ，其表示数：

$$
x' + \\sum_{i = w - k}^{w - 1} 2^i = x' + 2^{w - k}(2^k - 1)
$$

按照补码去解读这个二进制串的话，其结果为 $x' + 2^{w - k}(2^k - 1) - 2^w = x' - 2^{w - k}$ 。也就能够计算得到：

$$
\\left\\lfloor \\frac{x}{2^k} \\right\\rfloor = \\left\\lfloor \\frac{2^k x' + x'' - 2^w}{2^k} \\right\\rfloor = \\left\\lfloor x' - 2^{w - k} + \\frac{x''}{2^k} \\right\\rfloor = x' - 2^{w - k} = x >^{\\text{tm}}\_w k
$$
{% endnote %}

为了修正这个舍入问题，我们可以尝试使用这样的一个性质：

$$
\\left\\lceil \\frac{x}{y} \\right\\rceil = \\left\\lfloor \\frac{x + y - 1}{y} \\right\\rfloor\\ (y > 0)
$$

也就是说我们只要在计算负数 $x$ 的时候改变为：

$$
\\left\\lfloor \\frac{x + 2^k - 1}{2^k} \\right\\rfloor = [x +^{\text{t}}_w (2^k - 1)] >^{\text{tm}}_w k
$$

即可。

# 小数的表示

## IEEE 浮点数标准

对于一个有小数部分的数 $B$ ，我们总是能找到唯一的 $s \\in \\{0, 1\\}$ 以及实数 $M \\in [1, 2)$ 和整数 $E$ 满足：

$$
B = (-1)^s M \\cdot 2^E
$$

这里 $s, E, M$ 分别称为**符号**、**阶码**和**尾数**。

基于这样的性质，我们可以给出小数的表示方式。将一片数据区域的最高位用于放置符号位 $s$ ，然后后面分割为两部分，即 **exp 域**和 **frac 域**，分别放置 $E$ 以及 $M$ 。 exp 域和 frac 域的具体大小有两种常见的制式（即**单精度浮点**和**双精度浮点**）。当然还有一些不太常用的分区方式，具体见表：

| 标准 | exp 域长度 | frac 域长度 | 浮点总长 | 备注 |
| :-: | :-: | :-: | :-: | :-: |
| 单精度浮点 | 8 bits | 23 bits | 4 字节 | |
| 双精度浮点 | 11 bits | 52 bits | 8 字节 | |
| 扩展精度浮点 | 15 bits | 63 bits | 10 字节 | 空置 1 bit |
| 半精度浮点 | 5 bits | 10 bits | 2 字节 | |

在具体存储的时候，尾数由于整数部分必然为 `1` ，所以只需要将小数部分按顺序存储即可，而阶码使用无符号整数方法存储。

这里注意，阶码理应是有可能为负数的，但一般存储的时候会将阶码加上一个固定的偏置变成正数之后存储。如果阶码长度为 $e$ ，那么这个偏置就是 $b = 2^{e - 1} - 1$ 。

比如说按照单精度浮点的方式存储数 `15213.0` ，其二进制表示为 $1.1101101101101 \\times 2^{13}$ 。所以符号位为 `0` ，尾数取小数部分前 23 位，即 `1101101 10110100 00000000` 。阶码为 `13` ，加上偏置 $2^{7} - 1 = 127$ 得到 `140` ，即 `10001100` 。所以最后的存储方式为：

{% codeblock lang:assembly Assembly %}
01000110 01101101 10110100 00000000
{% endcodeblock %}

## 浮点数的非规格化

事实上，浮点数标准保留一部分阶码用于表示特殊的数字。一般而言，阶码全 `1` 和全 `0` 是被保留的。具体而言，阶码全 `1` 和全 `0` 的、表述特殊数字的浮点数被称为**非规格化浮点数（ denormalized float point ）**，其余的被称为**规格化浮点数（ normalized float point ）**。

全 `0` 的阶码如果按照上述的标准解读的话，表示的是相当接近于零的小数。但是由于默认了尾数的整数部分为 `1` ，所以说还按照原有解读方式的话，浮点数无法表示 `0` 。这个时候作出规定，就是**阶码全 `0` 的时候，尾数的整数部分变为 `0`** 。相应的，为了配合尾数解读方式的调整，**阶码的偏置减去一**。

假设某浮点数标准之中阶码长为 $e$ ，尾数长为 $m$ 。那么规格化的条件下最小的正浮点数应当是阶码为 `00...01` ，尾数全 `0` 。此时表示的数为 $2^{1 - (2^{e - 1} - 1)} = 2^{2 - 2^{e - 1}}$ 。在非规格化条件下，如果将尾数按照无符号整数解析得到的非负整数标记为 $n$ ，那么该浮点数应该为 $2^{2 - 2^{e - 1}} \\cdot 2^{-m}n$ 。这里非负整数 $n$ 取值范围为 $0$ 到 $2^m - 1$ 。

所以说非规格化的浮点数所能表述的非负数序列为：

$$
0, \\ 2^{2 - 2^{e - 1}} \\cdot 2^{-m} \\cdot 1, \\ \\cdots, \\ 2^{2 - 2^{e - 1}} \\cdot 2^{-m}(2^m - 1)
$$

这是一个公差为 $2^{2 - 2^{e - 1}} \\cdot 2^{-m}$ 的等差数列，而且最后正好可以和规格化浮点数所表述的最小正数 $2^{2 - 2^{e - 1}}$ “无缝衔接”。所以说非规格化浮点数是一个合理的拓展。

但是，注意非规格化浮点数之中有 `+0` 和 `-0` 的区别。

全 `1` 的阶码用于表示很大的浮点数。一般而言尾数全 `0` 的时候该浮点数被保留用于表示无穷。而尾数有非 `0` 位的时候，该浮点数被保留用于表示 `NaN` 。

---

现在补全了非规格化浮点数之后，可以发现浮点数的大小比较实际上几乎可以按照无符号整数从高位直接比较到低位的逻辑进行。因为阶码大的数一定大，阶码一样的时候尾数大的数一定大，包括无穷大也可以纳入进来。但是要考虑这样的例外：

- 考虑符号位

- 考虑 `+0` 和 `-0` 的特例

- 考虑 `NaN` 的问题

## 浮点数的舍入问题

由于部分数不能表述为有限的二进制小数，所以在转化为浮点数表示的时候需要舍入。一般而言向上舍入、向下舍入、向零舍入都会带来统计误差，而计算机之中常常使用**向偶数舍入**。其舍入的规则是向最接近的数舍入。如果向两边舍入的距离一致，那么优先舍入到偶数。比如说下列数之中，向百分位的舍入为：

$$
\\begin{aligned}
& 12.324999 \\Rightarrow 12.32 \\\\
& 12.325001 \\Rightarrow 12.33 \\\\
& 12.325000 \\Rightarrow 12.32 \\\\
& 12.335000 \\Rightarrow 12.34 \\\\
\\end{aligned}
$$

回到二进制上的话，由于十进制的 `0.5` 相当于二进制的 `0.1` 。也就是说如果二进制小数之中后面需要舍去的部分大于 `100...` 则向上舍入，小于 `100...` 则向下舍入，恰好是 `100...` 则向偶数舍入（舍入完毕后尾数为 `0` ）。

这里要注意一点，舍入是有可能导致溢出。

---

至此，小数的计算机编码方式基本就介绍完毕了。其具体过程为：

- 根据使用的浮点数标准，判定使用规格化的浮点数还是非规格化的浮点数

- 据此判定符号位、阶码和尾数

- 对尾数进行舍入后转化为二进制表示

## C 语言的浮点数

C 语言之中， `int` 类型以及 `float` 类型是 4 字节的， `double` 则是 8 字节。它们之间的互相转换满足这样的规则：

- `int` 可以精确转换为 `double` 类型

- `int` 转换为 `float` 类型不会溢出，但有可能被舍入

- `float` 以及 `double` 转换为 `int` 时尾数截断，如果发生溢出则产生 UB