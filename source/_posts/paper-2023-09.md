---
title: 2023 年 9 月论文笔记
date: 2023-09-01 23:32:51
category:
    - 【论文笔记】计算机
mathjax: true
---

博士生涯正式开始了，首先先看看论文吧。

<!-- more -->

# Nebula - Reliable Low-latency Video Transmission for Mobile Cloud Gaming

## Introduction

云游戏（Mobile Cloud Gaming / MCG）系统的目标是高质量传输游戏内容，一般而言具有下列特征：

- 轻量级的客户端（手机等终端）
- 相对重量级的云端服务器
- 分布广泛但是具有不可预测性的移动网络

现行的云游戏系统往往针对家用定点游戏（原文是 sedentary gaming at home，我猜是类似主机游戏或者用户一般不会到处走动的手游），这类云游戏系统往往通过 WebRTC 等协议实现较低传输延迟，然而可能会导致较低的画质，从而影响 QoE。但是移动网络的带宽不确定性、丢包率高、公网传输不稳定等问题也是一大挑战。

目前，ABR 算法常用于应对带宽波动，FEC（Forward Error Correction，前向纠错）算法常用于应对丢包。然而，ABR 受限于难以精确预测可用带宽，FEC 受限于较高的成本。此外，这两类算法也较少同时使用。

然后就是本文：

{% note success no-icon %}
In this paper, we introduce Nebula, the first end-to-end framework combining (1) **video distortion propagation modelling** with (2) **adaptive frame-level FEC** and (3) **joint video encoding bitrate** and (4) **FEC redundancy control** for MCG over mobile networks (see Figure 1).
{% endnote %}

说实话四层 buff 确实让人看得有点迷糊。

Nebula 的基础是对误差在多个游戏帧之间的传播情况建模，以考虑视频信号的失真情况。这种方案相较于直接在整组图片（Group of Pictures / GoP）上应用 FEC，Nebula 使用了帧级别的 FEC，从而 GoP 中的帧将会按照时间顺序的接近程度被不同程度地保护。这是显然的，因为 Nebula 毕竟考虑的是错误传播，越远的帧上的错误传播情况自然更加难以把握。这样的操作可以尽可能压缩端到端传输延迟，并且显著减少错误在 GoP 之中的传播。此外，Nebula 显然也采用了一些用来应对带宽波动的算法，但是这显然不是文章的重点。

采用的 baseline 有标准 TCP Cubic based、标准 WebRTC based、BO 和 ESCOT。具体的一些评估还是看后面具体叙述吧。

## Background & Related Works

这一部分不局限于云游戏，还一并叙述了实时视频传输场景的一些工作（Question #1 - 实时视频传输是不是指的是直播场景呢？）。

首先是简单讲了一下实时视频传输场景的工作，首先讨论了聚焦于 FEC 算法的工作。本文指出这些工作虽然成功通过 FEC 实现了较为可靠的传输，但是难以满足低延迟的要求。在 FEC 算法之外，本文讨论了常见的实时视频传输场景中的常用算法架构。首先 WebRTC 偏好降低延迟以实现实时传输而非提高画质，此外 TCP Cubic 等方法并不将延迟纳入考虑，这些算法或多或少的偏颇考量导致了这些方法难以做到两全。

而和云游戏相关的工作本文似乎并没有介绍很多，但是点出了这么一句话：

{% note success no-icon %}
A few works target specifically MCG due to its novelty. 
{% endnote %}

感觉和学长和我说的“现在云游戏相关的论文好发表”有一种异曲同工之妙。

文章之中所有和云游戏相关的工作都是采用了 GoP-level FEC，这虽然保证了较为正确的传输，但是也使得 MTP latency 很高。MTP latency 就是 Motion to Photon Latency，指的是游戏中玩家作出操作后反映到画面变化上所产生的延迟。显然，过重的纠错负担会使得构建新的视频帧和解码新视频帧耗时增加，明显加重了 MTP latency。在这之后，自然是吹一下自己使用的 frame-level FEC 在降低延迟上具有相当的实力。

## Modelling the Joint Source/FEC Rate Problem

这一章主要讲解了如何针对现有问题建模。云游戏为了保证实时性，或多或少依赖于有损压缩和传输，然而云游戏对 MTP latency 有着相当高的要求。

FEC 算法虽然能一定程度上抑制传输失真，但是由于 FEC 的冗余带来了新的传输成本，这导致了可用带宽降低。另外一方面，网络拥塞可能导致连续大量的丢包（文中描述为 burst of losses），此时 FEC 也很难做到恢复原有信号，而这种拥塞也有可能是 FEC 自身导致的。当前的工作也基本都将 FEC 应用在整个 GoP 上，导致 MTP latency 大幅上升（原因似乎是在展示某个 GoP 的任何一张图片前，必须完整解码整个 GoP，和我之前想的有一些不同），并且导致在有限带宽条件下画质降低。

本文首先提出了一个误差函数。对于 $K$ 个分辨率为 $M \times N$ 的帧，对 $1 \leq m \leq M, 1 \leq n \leq N, 1 \leq k \leq K$，定义函数 $f_k(m, n)$ 表示传输前第 $k$ 帧在 $(m, n)$ 坐标上的像素值，$\hat f_k(m, n)$ 则是传输后解码得到的像素值。使用均方差的方式定义传输误差：

$$
{\rm MSE} := \frac{1}{MNK} \sum_{k = 1}^K \sum_{m = 1}^M \sum_{n = 1}^N [f_k(m, n) - \hat f_k(m, n)]^2
$$

下面我们需要考虑全过程中可能产生失真的地方，这里主要考虑三处。

第一是**编码失真** $D_e$。对于编码率 $R_e$，编码失真描述为：

$$
D_e := \frac{\theta_1}{R_e - R_0}
$$

这里 $\theta_1, R_0$ 均为适当的参数，事实上这就描述了编码失真和编码率大致成反比例函数关系。

第二是**传输失真** $D_c$。传输失真的衡量较为简单，记丢包率为 $\Pi$，则：

$$
D_c := \theta_2\Pi
$$

这里 $\theta_2$ 是适当的参数，传输失真与传输丢包率成正比例关系。

第三是**解码失真** $D_d$。在以往的工作中，将 FEC 应用在 GoP level 时，由于在不考虑 burst package loss 的条件下 GoP 内部丢包时均能正确解码，所以这里不需要考虑错误传播。然而将 FEC 应用在 frame level 时，就需要考虑 GoP 内部丢失帧导致的错误传播。若将 I 帧出现频率记为 $\beta$，那么解码失真描述为：

$$
D_d := \frac{\theta_3\Pi}{\beta}
$$

这里 $\theta_3$ 是适当的参数，这表明丢包率越高，解码失真越高，并且 I 帧率越高，其恢复能力越强，从而使得解码失真越低。

综合得到全过程失真为：

$$
D := D_e + D_c + D_d = \frac{\theta_1}{R_e - R_0} + \theta_2\Pi + \frac{\theta_3\Pi}{\beta}
$$

那么可以得到这一套系统的峰值信噪比（即 PSNR）为：

$$
{\rm PSNR} = 20\log_{10}({\rm MAX}_I) - 10\log_{10}\left(\frac{\theta_1}{R_e - R_0} + \left(\theta_2 + \frac{\theta_3}{\beta}\right)\Pi\right)
$$

{% note info no-icon %}
PSNR 的定义是：

$$
{\rm PSNR} := 10\log_{10}\left(\frac{\mathrm{MAX}_I^2}{\mathrm{MSE}}\right) = 20\log_{10}({\rm MAX}_I) - 10\log_{10}(\mathrm{MSE})
$$

这里 ${\rm MAX}_I$ 指的是每个像素点可能的最大取值。具体而言，如果某一类图像中每个像素均使用 $B$ 位二进制表示，那么 ${\rm MAX}_I = 2^B - 1$。

而这里 ${\rm MSE}$ 就是上面提到的传输前后的均方差误差，在这一篇文章中就是三重失真叠加得到的 $D$。
{% endnote %}

综上所述，本文对失真所采用的建模方式可以展现为：

![](/uploads/paper-2023-09/1.png)

但这里有个比较奇妙的地方就是，图的注释里面说了 $\Pi = 0.1\%$，每一张图也都给定了 $\beta$，那么为何 $D_c, D_d$ 还会跟随 $R_e$ 变化而线性变化呢？我找了一下原论文，里面也说 $\theta_{1, 2, 3}$ 都是常数，理应不变化的，这里就有点不太理解了。

---

在此基础上，云游戏系统的目标应当是在满足实时性的约束下最小化失真，所以可以使用有约束优化问题的方式建模云游戏问题。我们能获取到客户端测量的部分网络参数，如往返时延 ${\rm RTT}$、丢包率 $\Pi$、最大可用带宽 $\mu$、MTP latency ${\rm MTP}$，此外，我们还知晓编码率 $R_e$ 和最大容忍延迟 $T_d$。

云游戏最重要的一项指标就是 MTP latency，而 MTP latency 与发送速率 $R = R_e + R_r$（这里 $R_r$ 是冗余率）以及可用带宽 $\mu$ 均不成反比，和排队延迟 $Q_d = {\rm RTT} - {\rm RTT}_{\rm min}$ 成正比。

基于此，每一帧都可以有以下建模。首先定义优化目标为：

$$
\{R_e, R_r\} = \mathop{\rm argmin}(D + \varphi{\rm MTP})
$$

其中：

$$
\begin{aligned}
D &= \frac{\theta_1}{R_e - R_0} + \theta_2\Pi + \frac{\theta_3\Pi}{\beta} \\
{\rm MTP} &= \frac{\alpha_1}{\mu} + \frac{\alpha_2}{R_e + R_r} + \alpha_3Q_d + \alpha_4 \\
\end{aligned}
$$

优化约束则为：

$$
\begin{cases}
{\rm MTP} \leq T_d \\
R_e + R_r \leq \mu \\
\end{cases}
$$

这里 $\varphi$ 是超参数，$\theta_{1, 2, 3}, R_0$ 都是根据编码器设定的，而 $\alpha_{1, 2, 3, 4}$ 则是根据回归方式得到的有 95\% 置信度的参数，回归所使用的数据集涵盖了有线和 WiFi 等多种网络环境。

在给定帧位置 $k$ 和丢包率 $\Pi(t)$ 的条件下，在发送到该帧时发送的总包数为：

$$
n := \begin{cases}
k & \Pi(t) = 0 \\
\max(k + 1, \lceil k(1 + \omega(F - f)\Pi(t))\rceil) & \Pi(t) > 0, {\rm cut}\ D_d \\
\max(k + 1, \lceil k(1 + \Pi(t))\rceil) & {\rm otherwise} \\
\end{cases}
$$

这里需要说明第二项之中的 $\omega, F, f$ 参数。首先我们能够注意到，当 I 帧率 $\beta$ 降低的时候，由于错误传递的链条增长，解码失真会更加严重。这里本文提出的方法是对 GoP 中的帧做不均匀保护，这也就是这些参数的来源。其中 $f$ 是该帧在 GoP 之中的位置，$F$ 则是总帧数，针对该帧的冗余率则是 $k\omega\Pi(F - f)$，其中 $0 < \omega < 0.4$ 是一个经验参数，根据丢包率 $\Pi$ 调节。可以发现，离 I 帧越近的帧（即更小的 $f$），会带来更多的冗余以及保护。

{% note info no-icon %}
说实话不是很懂这里提出 $n$ 的公式的目的，因为暂且看不到这个公式可以应用到哪里，似乎也和问题建模并没有很大的关系。但毕竟引出了 Nebula 系统 GoP 内不均衡保护各帧的设计，可能用意在这里。
{% endnote %}

---

综上所述，本文将云游戏的问题建模为一个带约束的优化问题，即在满足即时性（MTP latency 用上界限制）和预防网络过载（发送速率用上界限制）的条件下尽可能地降低失真，通过在每个离散时间点求解该优化问题即可得到下一段时间使用的编码率 $R_e$ 和冗余率 $R_r$。

## Distortion Minimization Framework

然后就是系统架构了：

![](/uploads/paper-2023-09/2.png)