---
title: 2023 年 9 月论文笔记
date: 2023-09-01 23:32:51
category:
    - 【论文笔记】计算机
mathjax: true
---

博士生涯正式开始了，首先先看看论文吧。

<!-- more -->

# Nebula - Reliable Low-latency Video Transmission for Mobile Cloud Gaming

## Introduction

云游戏（Mobile Cloud Gaming / MCG）系统的目标是高质量传输游戏内容，一般而言具有下列特征：

- 轻量级的客户端（手机等终端）
- 相对重量级的云端服务器
- 分布广泛但是具有不可预测性的移动网络

现行的云游戏系统往往针对家用定点游戏（原文是 sedentary gaming at home，我猜是类似主机游戏或者用户一般不会到处走动的手游），这类云游戏系统往往通过 WebRTC 等协议实现较低传输延迟，然而可能会导致较低的画质，从而影响 QoE。但是移动网络的带宽不确定性、丢包率高、公网传输不稳定等问题也是一大挑战。

目前，ABR 算法常用于应对带宽波动，FEC（Forward Error Correction，前向纠错）算法常用于应对丢包。然而，ABR 受限于难以精确预测可用带宽，FEC 受限于较高的成本。此外，这两类算法也较少同时使用。

然后就是本文：

{% note success no-icon %}
In this paper, we introduce Nebula, the first end-to-end framework combining (1) **video distortion propagation modelling** with (2) **adaptive frame-level FEC** and (3) **joint video encoding bitrate** and (4) **FEC redundancy control** for MCG over mobile networks (see Figure 1).
{% endnote %}

说实话四层 buff 确实让人看得有点迷糊。

Nebula 的基础是对误差在多个游戏帧之间的传播情况建模，以考虑视频信号的失真情况。这种方案相较于直接在整组图片（Group of Pictures / GoP）上应用 FEC，Nebula 使用了帧级别的 FEC，从而 GoP 中的帧将会按照时间顺序的接近程度被不同程度地保护。这是显然的，因为 Nebula 毕竟考虑的是错误传播，越远的帧上的错误传播情况自然更加难以把握。这样的操作可以尽可能压缩端到端传输延迟，并且显著减少错误在 GoP 之中的传播。此外，Nebula 显然也采用了一些用来应对带宽波动的算法，但是这显然不是文章的重点。

采用的 baseline 有标准 TCP Cubic based、标准 WebRTC based、BO 和 ESCOT。具体的一些评估还是看后面具体叙述吧。

## Background & Related Works

这一部分不局限于云游戏，还一并叙述了实时视频传输场景的一些工作（Question #1 - 实时视频传输是不是指的是直播场景呢？）。

首先是简单讲了一下实时视频传输场景的工作，首先讨论了聚焦于 FEC 算法的工作。本文指出这些工作虽然成功通过 FEC 实现了较为可靠的传输，但是难以满足低延迟的要求。在 FEC 算法之外，本文讨论了常见的实时视频传输场景中的常用算法架构。首先 WebRTC 偏好降低延迟以实现实时传输而非提高画质，此外 TCP Cubic 等方法并不将延迟纳入考虑，这些算法或多或少的偏颇考量导致了这些方法难以做到两全。

而和云游戏相关的工作本文似乎并没有介绍很多，但是点出了这么一句话：

{% note success no-icon %}
A few works target specifically MCG due to its novelty. 
{% endnote %}

感觉和学长和我说的“现在云游戏相关的论文好发表”有一种异曲同工之妙。

文章之中所有和云游戏相关的工作都是采用了 GoP-level FEC，这虽然保证了较为正确的传输，但是也使得 MTP latency 很高。MTP latency 就是 Motion to Photon Latency，指的是游戏中玩家作出操作后反映到画面变化上所产生的延迟。显然，过重的纠错负担会使得构建新的视频帧和解码新视频帧耗时增加，明显加重了 MTP latency。在这之后，自然是吹一下自己使用的 frame-level FEC 在降低延迟上具有相当的实力。

## Modelling the Joint Source/FEC Rate Problem

这一章主要讲解了如何针对现有问题建模。云游戏为了保证实时性，或多或少依赖于有损压缩和传输，然而云游戏对 MTP latency 有着相当高的要求。

FEC 算法虽然能一定程度上抑制传输失真，但是由于 FEC 的冗余带来了新的传输成本，这导致了可用带宽降低。另外一方面，网络拥塞可能导致连续大量的丢包（文中描述为 burst of losses），此时 FEC 也很难做到恢复原有信号，而这种拥塞也有可能是 FEC 自身导致的。当前的工作也基本都将 FEC 应用在整个 GoP 上，导致 MTP latency 大幅上升（原因似乎是在展示某个 GoP 的任何一张图片前，必须完整解码整个 GoP，和我之前想的有一些不同），并且导致在有限带宽条件下画质降低。

本文首先提出了一个误差函数。对于 $K$ 个分辨率为 $M \times N$ 的帧，对 $1 \leq m \leq M, 1 \leq n \leq N, 1 \leq k \leq K$，定义函数 $f_k(m, n)$ 表示传输前第 $k$ 帧在 $(m, n)$ 坐标上的像素值，$\hat f_k(m, n)$ 则是传输后解码得到的像素值。使用均方差的方式定义传输误差：

$$
{\rm MSE} := \frac{1}{MNK} \sum_{k = 1}^K \sum_{m = 1}^M \sum_{n = 1}^N [f_k(m, n) - \hat f_k(m, n)]^2
$$

下面我们需要考虑全过程中可能产生失真的地方，这里主要考虑三处。

第一是**编码失真** $D_e$。对于编码率 $R_e$，编码失真描述为：

$$
D_e := \frac{\theta_1}{R_e - R_0}
$$

这里 $\theta_1, R_0$ 均为适当的参数，事实上这就描述了编码失真和编码率大致成反比例函数关系。

第二是**传输失真** $D_c$。传输失真的衡量较为简单，记丢包率为 $\Pi$，则：

$$
D_c := \theta_2\Pi
$$

这里 $\theta_2$ 是适当的参数，传输失真与传输丢包率成正比例关系。

第三是**解码失真** $D_d$。在以往的工作中，将 FEC 应用在 GoP level 时，由于在不考虑 burst package loss 的条件下 GoP 内部丢包时均能正确解码，所以这里不需要考虑错误传播。然而将 FEC 应用在 frame level 时，就需要考虑 GoP 内部丢失帧导致的错误传播。若将 I 帧出现频率记为 $\beta$，那么解码失真描述为：

$$
D_d := \frac{\theta_3\Pi}{\beta}
$$

这里 $\theta_3$ 是适当的参数，这表明丢包率越高，解码失真越高，并且 I 帧率越高，其恢复能力越强，从而使得解码失真越低。

综合得到全过程失真为：

$$
D := D_e + D_c + D_d = \frac{\theta_1}{R_e - R_0} + \theta_2\Pi + \frac{\theta_3\Pi}{\beta}
$$

那么可以得到这一套系统的峰值信噪比（即 PSNR）为：

$$
{\rm PSNR} = 20\log_{10}({\rm MAX}_I) - 10\log_{10}\left(\frac{\theta_1}{R_e - R_0} + \left(\theta_2 + \frac{\theta_3}{\beta}\right)\Pi\right)
$$

{% note info no-icon %}
PSNR 的定义是：

$$
{\rm PSNR} := 10\log_{10}\left(\frac{\mathrm{MAX}_I^2}{\mathrm{MSE}}\right) = 20\log_{10}({\rm MAX}_I) - 10\log_{10}(\mathrm{MSE})
$$

这里 ${\rm MAX}_I$ 指的是每个像素点可能的最大取值。具体而言，如果某一类图像中每个像素均使用 $B$ 位二进制表示，那么 ${\rm MAX}_I = 2^B - 1$。

而这里 ${\rm MSE}$ 就是上面提到的传输前后的均方差误差，在这一篇文章中就是三重失真叠加得到的 $D$。
{% endnote %}

综上所述，本文所采用的建模方式可以展现为：

![](/uploads/paper-2023-09/1.png)

但这里有个比较奇妙的地方就是，图的注释里面说了 $\Pi = 0.1\%$，每一张图也都给定了 $\beta$，那么为何 $D_c, D_d$ 还会跟随 $R_e$ 变化而线性变化呢？我找了一下原论文，里面也说 $\theta_{1, 2, 3}$ 都是常数，理应不变化的，这里就有点不太理解了。