<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CMonaco:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;ashitemaru.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;width&quot;:280,&quot;display&quot;:&quot;always&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:&quot;disqusjs&quot;,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;path&quot;:&quot;&#x2F;search.xml&quot;,&quot;localsearch&quot;:{&quot;enable&quot;:true,&quot;trigger&quot;:&quot;manual&quot;,&quot;top_n_per_article&quot;:1,&quot;unescape&quot;:false,&quot;preload&quot;:false}}</script><script src="/js/config.js"></script>
<meta name="description" content="这门课是 2021 年暑期学期开设的计算机系专业课，应该也算是为下学期的《计算机组成原理》课程做预备，所以还打算好好学一下。">
<meta property="og:type" content="article">
<meta property="og:title" content="《汇编语言程序设计》学习笔记">
<meta property="og:url" content="https://ashitemaru.github.io/2021/08/09/note-of-asm/index.html">
<meta property="og:site_name" content="Ashitemaru">
<meta property="og:description" content="这门课是 2021 年暑期学期开设的计算机系专业课，应该也算是为下学期的《计算机组成原理》课程做预备，所以还打算好好学一下。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-08-09T14:22:58.000Z">
<meta property="article:modified_time" content="2021-08-09T14:22:58.000Z">
<meta property="article:author" content="Ashitemaru">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://ashitemaru.github.io/2021/08/09/note-of-asm/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;https:&#x2F;&#x2F;ashitemaru.github.io&#x2F;2021&#x2F;08&#x2F;09&#x2F;note-of-asm&#x2F;&quot;,&quot;path&quot;:&quot;2021&#x2F;08&#x2F;09&#x2F;note-of-asm&#x2F;&quot;,&quot;title&quot;:&quot;《汇编语言程序设计》学习笔记&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>《汇编语言程序设计》学习笔记 | Ashitemaru</title>
  



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/twikoo@1.4.1/dist/twikoo.all.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js"></script>
<script>
function getURL(e) {
    http = e.slice(0,4)
    https = e.slice(0,5)
    if (http == "http" || https == "https" ) {
        return e
    } else if (e == "" || e == null || e == undefined) {
        return e
    } else {
        e = 'http://' + e
        return e
    }
}

function newcomment() {
    twikoo.getRecentComments({
        envId: 'https://vercel-deploy-two.vercel.app',
        pageSize: 7,
        includeReply: false
    }).then(function (res) {
        var hotComments = $("#hot-comments");
        for (var i = 0; i < res.length; i++) {
            var nick = res[i].nick;
            var content = res[i].commentText;
            var newcontent = content.substring(0, 50);
            var url = res[i].url;
            var avatar = res[i].avatar;
            var link = getURL(res[i].link);
            var updatedAt = res[i].relativeTime;
            var commentId = '#' + res[i].id;
            hotComments.append(
                `<li class="px1 pb2 flex items-center">
                    <img style="width:40px;height:40px" class="circle mx1 listavatar" src="${avatar}">
                    <div style="display:flex;flex-direction:column;width:100%;">
                        <div style="display:flex;justify-content:space-between;flex-direction:row;align-items:center;">
                            <div class="h5 listauthor overflow-hidden" title="${nick}">
                                <a target="_blank" rel="noopener external nofollow noreferrer" href="${link}">${nick}</a>
                            </div>
                            <div class="h6 mr1 listdate wenzi hang1" style="color:#777777;">${updatedAt}</div>
                        </div>
                        <div style="display:flex;flex-direction:row;width:100%;">
                            <a class="h5 list-comcontent" style="overflow:hidden;display:flex;border-bottom:0px;text-overflow:ellipsis;line-height:1.5;text-align:left" href="${url}${commentId}">${newcontent}</a>
                        </div>
                    </div>
                </li>`
            );
        }
    }).catch(function (err) {
        console.error(err);
    });
}

$(function () {
    newcomment();
});
</script>

<!-- CSS -->
<link href="https://fonts.googleapis.com/css2?family=Mulish&amp;display=swap" rel="stylesheet" media="all" onload="this.media=&quot;all&quot;">
<link href="https://cdn.jsdelivr.net/gh/heson10/pic@master/css/app.min.css" rel="stylesheet">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Ashitemaru</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">课程基本介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.</span> <span class="nav-text">汇编语言介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#X86-%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.2.</span> <span class="nav-text">X86 指令集介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MIPS-%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.3.</span> <span class="nav-text">MIPS 指令集介绍</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%AE%A1%E7%AE%97"><span class="nav-number">2.</span> <span class="nav-text">整数的表示与计算</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E5%AD%97%E5%92%8C%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="nav-number">2.1.</span> <span class="nav-text">机器字和字节序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81"><span class="nav-number">2.2.</span> <span class="nav-text">整数的二进制编码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E7%BC%96%E7%A0%81"><span class="nav-number">2.2.1.</span> <span class="nav-text">有符号数的编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E7%BC%96%E7%A0%81"><span class="nav-number">2.2.2.</span> <span class="nav-text">无符号数的编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB%E5%92%8C%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.2.3.</span> <span class="nav-text">有符号数和无符号数的关系和转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-number">2.3.</span> <span class="nav-text">整数的计算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E7%9A%84%E5%8A%A0%E6%B3%95"><span class="nav-number">2.3.1.</span> <span class="nav-text">无符号整数的加法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E7%9A%84%E5%8A%A0%E6%B3%95"><span class="nav-number">2.3.2.</span> <span class="nav-text">有符号整数的加法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E9%99%A4%E4%BB%A5-2-%E7%9A%84%E5%B9%82"><span class="nav-number">2.3.3.</span> <span class="nav-text">无符号整数除以 2 的幂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E9%99%A4%E4%BB%A5-2-%E7%9A%84%E5%B9%82"><span class="nav-number">2.3.4.</span> <span class="nav-text">有符号整数除以 2 的幂</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%8F%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-number">3.</span> <span class="nav-text">小数的表示</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#IEEE-%E6%B5%AE%E7%82%B9%E6%95%B0%E6%A0%87%E5%87%86"><span class="nav-number">3.1.</span> <span class="nav-text">IEEE 浮点数标准</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E9%9D%9E%E8%A7%84%E6%A0%BC%E5%8C%96"><span class="nav-number">3.2.</span> <span class="nav-text">浮点数的非规格化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%88%8D%E5%85%A5%E9%97%AE%E9%A2%98"><span class="nav-number">3.3.</span> <span class="nav-text">浮点数的舍入问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E8%AF%AD%E8%A8%80%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="nav-number">3.4.</span> <span class="nav-text">C 语言的浮点数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="nav-number">4.</span> <span class="nav-text">汇编语言基本知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.</span> <span class="nav-text">汇编语言的数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><span class="nav-number">4.2.</span> <span class="nav-text">汇编语言的数据操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-number">4.3.</span> <span class="nav-text">汇编语言的寻址方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#X86-%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-number">4.3.1.</span> <span class="nav-text">X86 系统的变址寻址方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%AF%BB%E5%9D%80%E8%BF%9B%E8%A1%8C%E6%95%B4%E6%95%B0%E8%AE%A1%E7%AE%97"><span class="nav-number">4.3.2.</span> <span class="nav-text">利用寻址进行整数计算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B4%E6%95%B0%E8%AE%A1%E7%AE%97%E5%91%BD%E4%BB%A4"><span class="nav-number">4.4.</span> <span class="nav-text">汇编语言常用的整数计算命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%A0%81%E4%B8%8E%E5%85%B6%E5%BA%94%E7%94%A8"><span class="nav-number">5.</span> <span class="nav-text">条件码与其应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A8%E7%9F%A5%E6%93%8D%E4%BD%9C%E6%95%B0%E5%85%B3%E7%B3%BB"><span class="nav-number">5.1.</span> <span class="nav-text">推知操作数关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%A8%8B%E5%BA%8F%E8%B7%B3%E8%BD%AC"><span class="nav-number">5.2.</span> <span class="nav-text">实现程序跳转</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%A8%8B%E5%BA%8F%E5%BE%AA%E7%8E%AF"><span class="nav-number">5.3.</span> <span class="nav-text">实现程序循环</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%B8%8E%E7%A8%8B%E5%BA%8F%E6%A0%88"><span class="nav-number">6.</span> <span class="nav-text">函数调用与程序栈</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ashitemaru"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Ashitemaru</p>
  <div class="site-description" itemprop="description">A cat that likes Sakana.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Ashitemaru" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ashitemaru" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:qhd19@mails.tsinghua.edu.cn" title="E-Mail → mailto:qhd19@mails.tsinghua.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Friends
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.unidy.cn/" title="https:&#x2F;&#x2F;www.unidy.cn" rel="noopener" target="_blank">UNIDY</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.dilant.cn/" title="https:&#x2F;&#x2F;www.dilant.cn" rel="noopener" target="_blank">Dilant</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://zcy.moe/" title="https:&#x2F;&#x2F;zcy.moe" rel="noopener" target="_blank">猫猫</a>
        </li>
    </ul>
  </div>
<div class="sidebar-1 mybox relative">
    <div class="p2">
        <i class="fab fa-facebook-messenger mr1"></i>
        Latest Comments
    </div>
    <div id="hot-comments"></div>
</div>
          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Ashitemaru" class="github-corner" title="Come here for fun." aria-label="Come here for fun." rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ashitemaru.github.io/2021/08/09/note-of-asm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Ashitemaru">
      <meta itemprop="description" content="A cat that likes Sakana.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ashitemaru">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《汇编语言程序设计》学习笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-09 14:22:58" itemprop="dateCreated datePublished" datetime="2021-08-09T14:22:58+00:00">2021-08-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-08-09 14:22:58" itemprop="dateModified" datetime="2021-08-09T14:22:58+00:00">2021-08-09</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
        </span>
    </span>

  
    <span id="/2021/08/09/note-of-asm/" class="post-meta-item twikoo_visitors" data-flag-title="《汇编语言程序设计》学习笔记" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="twikoo_visitors"></span>
    </span>
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>这门课是 2021 年暑期学期开设的计算机系专业课，应该也算是为下学期的《计算机组成原理》课程做预备，所以还打算好好学一下。</p>
<span id="more"></span>

<h1 id="课程基本介绍"><a href="#课程基本介绍" class="headerlink" title="课程基本介绍"></a>课程基本介绍</h1><h2 id="汇编语言介绍"><a href="#汇编语言介绍" class="headerlink" title="汇编语言介绍"></a>汇编语言介绍</h2><p>汇编语言可以认为是机器指令的一种表记方式，其表述了计算机硬件系统对外开放的主要接口和规格，是计算机系统之中的软硬件的分界。所以说要了解汇编语言，就首先需要了解机器指令。</p>
<p>机器指令系统一般分为两类：</p>
<ul>
<li><p>CLSC ，即<strong>复杂指令系统</strong>。一般而言具有多种指令，寻址方式复杂，单条指令的功能较为复杂。较为经典的代表是 X86 。</p>
</li>
<li><p>RISC ，即<strong>精简指令系统</strong>。考虑到实际使用的指令大多都是简要指令，故该系统只具有常用的精简指令。在这样的条件下，该指令系统依赖于编译器产生高效的代码（依赖编译器优化）。较为经典的代表为 MIPS 。</p>
</li>
</ul>
<p>目前， CLSC 和 RISC 之间的差别渐渐缩小。但是还是具有明显的区分方式的，即：</p>
<div class="note info no-icon"><p>It loads / stores [with / without] other operations.</p>
</div>

<p>借助于连接软硬件的机器指令集，计算机系统实现了软硬件解耦合。这样软硬件可以独立编写，从而促进了计算机的发展。</p>
<p><strong>注解：</strong>软硬件的分离的一个重要基石是<strong>图灵完备性</strong>。也就是说软件使用的高级语言是图灵完备的，硬件的指令序列也是图灵完备的，这两者完全等价。这样才保证了分离的可行性。</p>
<h2 id="X86-指令集介绍"><a href="#X86-指令集介绍" class="headerlink" title="X86 指令集介绍"></a>X86 指令集介绍</h2><p>X86 指令集具有以下的基本特征：</p>
<ul>
<li><p>向下兼容、变长指令、多种寻址方式</p>
</li>
<li><p>通用寄存器个数有限（ X86-32 具有 8 个通用寄存器， X86-64 具有 16 个通用寄存器）</p>
</li>
<li><p>至多允许一个操作数在内存中，另外一个操作数需要在寄存器中或者是立即数</p>
</li>
</ul>
<div class="note info no-icon"><p>这里提到了寄存器。 X86 之中的寄存器命名为：</p>
<table>
<thead>
<tr>
<th align="center">寄存器名称【 X86-64 名称】</th>
<th align="center">X86-32 名称</th>
<th align="center">寄存器名称【 X86-64 名称】</th>
<th align="center">X86-32 名称</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>%rax</code></td>
<td align="center"><code>%eax</code></td>
<td align="center"><code>%r8</code></td>
<td align="center"><code>%r8d</code></td>
</tr>
<tr>
<td align="center"><code>%rdx</code></td>
<td align="center"><code>%edx</code></td>
<td align="center"><code>%r9</code></td>
<td align="center"><code>%r9d</code></td>
</tr>
<tr>
<td align="center"><code>%rcx</code></td>
<td align="center"><code>%ecx</code></td>
<td align="center"><code>%r10</code></td>
<td align="center"><code>%r10d</code></td>
</tr>
<tr>
<td align="center"><code>%rbx</code></td>
<td align="center"><code>%ebx</code></td>
<td align="center"><code>%r11</code></td>
<td align="center"><code>%r11d</code></td>
</tr>
<tr>
<td align="center"><code>%rsi</code></td>
<td align="center"><code>%esi</code></td>
<td align="center"><code>%r12</code></td>
<td align="center"><code>%r12d</code></td>
</tr>
<tr>
<td align="center"><code>%rdi</code></td>
<td align="center"><code>%edi</code></td>
<td align="center"><code>%r13</code></td>
<td align="center"><code>%r13d</code></td>
</tr>
<tr>
<td align="center"><code>%rsp</code></td>
<td align="center"><code>%esp</code></td>
<td align="center"><code>%r14</code></td>
<td align="center"><code>%r14d</code></td>
</tr>
<tr>
<td align="center"><code>%rbp</code></td>
<td align="center"><code>%ebp</code></td>
<td align="center"><code>%r15</code></td>
<td align="center"><code>%r15d</code></td>
</tr>
</tbody></table>
</div>

<p>由于 X86 重视向下兼容，所以其指令集越来越趋向于庞杂，所以其一个缺点就是资源利用率低。</p>
<h2 id="MIPS-指令集介绍"><a href="#MIPS-指令集介绍" class="headerlink" title="MIPS 指令集介绍"></a>MIPS 指令集介绍</h2><p>MIPS 的设计思想是充分利用处理器的流水线结构，目标是让流水线各段负载均匀，这样可以让处理器频率得到提高。其特征包括：</p>
<ul>
<li><p>以寄存器为中心，只有 Load 以及 Store 命令可以访问内存</p>
</li>
<li><p>所有计算操作均是从寄存器堆之中读取数据并将结果保存到寄存器堆</p>
</li>
<li><p>指令格式规整、定长，且操作码位置固定，指令类型少（ MIPS32 的指令只有 register / immediate / jump 三类）</p>
</li>
<li><p>寻址方式简单，每一条指令的操作过程简单</p>
</li>
</ul>
<p>当然， MIPS 也具有一些被扩展过的扩展指令集，如 MIPS16e 等等。</p>
<p>此外， RISC-V 也是一种常用指令集。但其几乎和 MIPS 同源，故这里不作详细介绍。</p>
<h1 id="整数的表示与计算"><a href="#整数的表示与计算" class="headerlink" title="整数的表示与计算"></a>整数的表示与计算</h1><p>首先我们介绍一些简要表记，即 K / M / G / T / P / E 。符号 K 表示 $2^{10}$ ，之后有 ${\rm M} = 2^{10} \cdot {\rm K}$ 以及 ${\rm G} = 2^{10} \cdot {\rm M}$ ，依此类推。</p>
<p>同时我们将一个二进制位称为<strong>比特（ bit ）</strong>，将八个比特称为<strong>字节（ byte ）</strong>。在 X86 架构下，两个字节称为一个<strong>字（ word ）</strong>，而在 MIPS 架构下则是四个字节。</p>
<p>对于数的进制、二进制数的逻辑运算，这里不进行介绍。</p>
<h2 id="机器字和字节序"><a href="#机器字和字节序" class="headerlink" title="机器字和字节序"></a>机器字和字节序</h2><p>首先引入<strong>机器字</strong>的概念，机器字指的是计算机进行一次整数运算所能处理的二进制数据组，也可以是一个数据地址。相应的，<strong>机器字长</strong>指的就是一个机器字的位数。对于 32 位字长的计算机，其地址能够表示的空间大小为 4GB 左右。机器字长越大的计算机，其地址的表示空间就越大。</p>
<p>机器字的定位为这个机器字第一个字节的地址，所以说相邻机器字的地址之差在 32 位系统之中为 4 ，而在 64 位系统之中为 8 。</p>
<p><strong>字节序</strong>指的就是一个机器字所包含的字节在机器字之中的排列的顺序，分为<strong>大端序（ Big endian ）</strong>以及<strong>小端序（ Little endian ）</strong>。大端序指的是低位字节占据高地址，小端序则相反。</p>
<p>比如说十六进制数据 <code>0x01234567</code> ，如果这个机器字地址为 <code>0x100</code> 。那么在大端序之下， <code>0x100, 0x101, 0x102, 0x103</code> 的字节内容分别为 <code>01, 23, 45, 67</code>。而在小端序下则是 <code>67, 45, 23, 01</code> 。</p>
<h2 id="整数的二进制编码"><a href="#整数的二进制编码" class="headerlink" title="整数的二进制编码"></a>整数的二进制编码</h2><p>我们首先复习一下 C 语言之中各个数据类型的大小，这里以字节作为单位：</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">经典 32 位系统</th>
<th align="center">X86-32</th>
<th align="center">X86-64</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>char</code></td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center"><code>short</code></td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center"><code>int</code></td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center"><code>long</code></td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center"><code>long long</code></td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center"><code>float</code></td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center"><code>double</code></td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center"><code>long double</code></td>
<td align="center">8</td>
<td align="center">10 / 12</td>
<td align="center">10 / 16</td>
</tr>
<tr>
<td align="center">指针</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">8</td>
</tr>
</tbody></table>
<p>这里我们为了简便，使用 16 位系统来演示整数的编码方式，也就是说机器字长为 16 位，一个整数使用 2 个字节表示。</p>
<h3 id="有符号数的编码"><a href="#有符号数的编码" class="headerlink" title="有符号数的编码"></a>有符号数的编码</h3><p>对于非负的整数，显然可以直接使用其二进制表示作为其编码。比如说十进制数 <code>12345</code> ，其二进制表示为 <code>00110000 00111001</code> ，那么其编码就是 <code>00110000 00111001</code> 。</p>
<p>对于负数，一种解决方式是使用最高位表记符号，最高位为 <code>1</code> 的数为负数，为 <code>0</code> 的数为非负数。然而这样会导致加法器在运算的时候需要首先验证符号位，计算出结果后还需要计算符号为，比较繁杂。所以说这里引入了<strong>补码（ two’s complement ）</strong>，用补码表示的整数可以简化有符号整数的计算。</p>
<p>非负数的补码就是其二进制表示，负数的补码是其绝对值的二进制表示按位取反之后加一。</p>
<p>比如说十进制数 <code>-12345</code> ，由于 <code>12345</code> 的二进制表示为 <code>00110000 00111001</code> ，首先按位取反得到 <code>11001111 11000110</code> ，最后加一得到其补码为 <code>11001111 11000111</code> 。</p>
<p>这个时候符号位依然存在，也就是说补码表示下负数最高位为 <code>1</code> ，非负数最高位为 <code>0</code> 。</p>
<div class="note info no-icon"><p>补码的优越性在于简化了有符号整数的加法计算。如果我们使用 ${\rm TC}_w(x)$ 表示字长为 $w$ 的系统下整数 $x$ 的补码（比如 <code>-12345</code> 的补码为 <code>11001111 11000111</code> ，后者直接转换为十进制表示的是 <code>53191</code> ，那么定义 ${\rm TC}_w(-12345) = 53191$ ）。实际上可以发现对于非负数 ${\rm TC}_w(x)=x$ ，而对于负数：</p>
<p>$$<br>{\rm TC}_w(x) = 1 + \mathop{\sim}(-x)<br>$$</p>
<p>而对于字长为 $w$ 的系统， $x + (\mathop{\sim}x) = 2^w - 1$ ，所以说对于负数 $x$ 有：</p>
<p>$$<br>{\rm TC}_w(x) = 1 + 2^w - 1 - (-x) = 2^w + x<br>$$</p>
<p>所以无论如何我们都可以断定：</p>
<p>$$<br>{\rm TC}_w(x) \equiv x\ ({\rm mod}\ 2^w)<br>$$</p>
<p>在这样的条件下做加法是简单的，因为一个整数和其补码在模 $2^w$ 意义下等价。后面讨论补码条件下的加法的时候，即使出现截断，由于所截断的 <code>1</code> 必然位于不低于 $2^w$ 的位上，所以截断还是不会影响模的结果。</p>
</div>

<p>对于字长为 $w$ 的系统，按照补码表示的有符号数系统之中，最大的数为 $2^{w - 1} - 1$ ，而最小的数为 $-2^{w - 1}$ 。</p>
<h3 id="无符号数的编码"><a href="#无符号数的编码" class="headerlink" title="无符号数的编码"></a>无符号数的编码</h3><p>无符号数的编码是简单的，因为其只需要考虑非负数，所以直接使用二进制表示作为编码就可以了。</p>
<p>这种系统之下，最大的数为 $2^w - 1$ ，而最小的数为 $0$ 。</p>
<h3 id="有符号数和无符号数的关系和转换"><a href="#有符号数和无符号数的关系和转换" class="headerlink" title="有符号数和无符号数的关系和转换"></a>有符号数和无符号数的关系和转换</h3><p>现在我们已经给出了有符号和无符号整数的表示方式了。现在考虑将一个有符号整数强制类型转换为无符号整数，比如说在机器字长为 4 的时候， <code>-4</code> 的补码为 <code>1010</code> ，而强转为无符号整数的时候， <code>1010</code> 则表示 <code>12</code> 。其实不难证明对于字长为 $w$ 的系统，有这样的关系：</p>
<p>$$<br>(\text{unsigned})x = \begin{cases}<br>x &amp; x \geq 0 \\<br>x + 2^w &amp; x &lt; 0<br>\end{cases}<br>$$</p>
<p>这里提一下，在 C 语言的比较运算之中如果同时出现有符号数和无符号数，则会将有符号数强制转换为无符号数。当然，如果两边都是有符号数，则按照有符号数的比较规则进行。</p>
<p>事实上，由于这样的隐式转换，如果我们给声明为无符号整数的变量赋予一个负数值，就有可能被强制转换为一个大整数，从而导致违反直觉的结果，甚至导致错误。所以说我们应当谨慎使用无符号整数，一般而言，只有涉及到<strong>模运算</strong>或者单纯使用<strong>位运算</strong>的时候无符号整数比较适合。</p>
<h2 id="整数的计算"><a href="#整数的计算" class="headerlink" title="整数的计算"></a>整数的计算</h2><h3 id="无符号整数的加法"><a href="#无符号整数的加法" class="headerlink" title="无符号整数的加法"></a>无符号整数的加法</h3><p>对于字长为 $w$ 的系统，两个整数的加法可能会需要 $w + 1$ 位才能表示，这个时候就会发生<strong>溢出</strong>。计算机的一般处理方式是舍去最高位，强制仅用 $w$ 位表达计算结果，其实相当于对 $2^w$ 取了模。也就是说，字长为 $w$ 的、带有截断的无符号整数加法为（这里，符号 $+^{\text u}_w$ 表示的是字长为 $w$ 的系统下无符号整数的加法）：</p>
<p>$$<br>x +^{\text{u}}_w y =\begin{cases}<br>x + y &amp; x + y &lt; 2^w \\<br>x + y - 2^w &amp; x + y \geq 2^w<br>\end{cases}<br>$$</p>
<h3 id="有符号整数的加法"><a href="#有符号整数的加法" class="headerlink" title="有符号整数的加法"></a>有符号整数的加法</h3><p>在字长为 $w$ 的、使用补码的系统下，对于有符号整数 $x, y$ ，其加法是有可能溢出的。</p>
<p>一种是两个大正数相加，超越了补码能表示的最大整数。此时补码的符号位承接了较低位溢出的 <code>1</code> ，也就是说补码之和实际上代表一个负数。由于负数 $u$ 的补码 ${\rm TC}_w(u) = u + 2^w$ ，这个负数实际上就是 $x + y - 2^w$ 。这种情况被称为<strong>正溢出</strong>。</p>
<p>另外一种是两个绝对值很大的负数相加，超越了补码能表示的最小整数。此时补码符号位两个 <code>1</code> 相加得到 <code>10</code> ，溢出为 $w + 1$ 位数，但是最高位的 <code>1</code> 被截断。另外，较低的 $w - 1$ 位不会向上进位（绝对值很大的负数的补码较低位所表示的数实际上会很小）。此时结果的补码符号位为 <code>0</code> ，代表一个正数。由于负数 $u$ 的补码 ${\rm TC}_w(u) = u + 2^w$ ，考虑到截断了一个 <code>1</code> ，所以该正数为：</p>
<p>$$<br>(x + 2^w) + (y + 2^w) - 2^w = x + y + 2^w<br>$$</p>
<p>这种情况被称为<strong>负溢出</strong>。</p>
<p>对于求和结果在表示范围内的，补码的和（截断为 $w$ 位后）就是和的补码。这是因为 $x, y$ 的补码相加后截断，所代表的数与 $x + y$ 模 $2^w$ 同余，而 $x + y$ 位于补码能表示的范围内，所以 $x, y$ 的补码相加后截断得到的就是 $x + y$ 的补码。</p>
<p>总而言之，字长为 $w$ 的、带有截断的有符号整数加法为（这里，符号 $+^{\text t}_w$ 表示的是字长为 $w$ 的系统下无符号整数的加法）：</p>
<p>$$<br>x +^{\text{t}}_w y =\begin{cases}<br>x + y - 2^w &amp; x + y \geq 2^{w - 1} \\<br>x + y &amp; -2^{w - 1} \leq x + y &lt; 2^{w - 1} \\<br>x + y + 2^w &amp; x + y &lt; -2^{w - 1}<br>\end{cases}<br>$$</p>
<h3 id="无符号整数除以-2-的幂"><a href="#无符号整数除以-2-的幂" class="headerlink" title="无符号整数除以 2 的幂"></a>无符号整数除以 2 的幂</h3><p>一般而言在计算机中，除法计算消耗的时间是相当长的。但是对于除数是 2 的幂的情况，我们可以使用移位的方式简化计算。</p>
<p>左移是很好理解的，溢出的部分会被截断，低位会用 <code>0</code> 补齐。但是右移的时候，低位截断是自然的，但是高位如何补齐则有两种方式。如果高位用 <code>0</code> 补齐，这种移位称为<strong>逻辑右移</strong>。如果用原数的最高位补齐（这里的最高位可以是 <code>0</code> ，比如 16 位系统之中的 <code>00000000 00000001</code> 的最高位为 <code>0</code> ），这种移位称为<strong>算术右移</strong>。</p>
<p>在字长为 $w$ 的系统下，我们将无符号的逻辑右移标记为 $&gt;^{\text{ul}}_w$ ，无符号的算术右移则标记为 $&gt;^{\text{um}}_w$ 。</p>
<p><strong>注解：</strong>有符号的右移则将上标的 $\text{u}$ 替换为 $\text{t}$ 。</p>
<p>其实对于无符号整数 $x$ 不难得到：</p>
<p>$$<br>x &gt;^{\text{ul}}_w k = \left\lfloor \frac{x}{2^k} \right\rfloor<br>$$</p>
<h3 id="有符号整数除以-2-的幂"><a href="#有符号整数除以-2-的幂" class="headerlink" title="有符号整数除以 2 的幂"></a>有符号整数除以 2 的幂</h3><p>首先说明，我们希望除法的结果<strong>向 0 舍入</strong>，也就是说 <code>23.6</code> 舍为 <code>23</code> ， <code>-24.6</code> 舍为 <code>-24</code> 。</p>
<p>这里我们依然使用右移来简化除法计算。但是我们注意到负数除以 2 的幂之后必然还是负数，所以不能使用逻辑右移，只能使用算数右移。这个时候，对于有符号整数 $x$ 我们可以简单地使用 $x &gt;^{\text{tm}}_w k$ 来计算 $x / 2^k$ 。</p>
<p>对于正数，这样的计算显然是正确的。但是对于负数，比如说 <code>-15213</code> ，其补码为 <code>11000100 10010011</code> 。我们计算其除以 <code>256</code> 的商，按照上面的计算方式即将其补码算术右移 <code>8</code> 位，得到 <code>11111111 11000100</code> ，结果为 <code>-60</code> 。然而我们知道实际的结果应当为 <code>-59.43</code> ，按照舍入应当保留为 <code>-59</code> 。</p>
<div class="note info no-icon"><p>事实上我们可以说明：</p>
<p>$$<br>x &gt;^{\text{tm}}_w k = \left\lfloor \frac{x}{2^k} \right\rfloor<br>$$</p>
<p>也就是说<strong>使用算术右移计算有符号整数的时候永远得到向下舍入的结果</strong>。我们只要说明负数的情况即可，对于负数 $x$ 的补码 $x_{w - 1}x_{w - 2} \cdots x_0$ ，我们设二进制数 $x_{w - 1}x_{w - 2} \cdots x_k$ 表示数 $x’$ ，二进制数 $x_{k - 1}x_{k - 2} \cdots x_0$ 表示数 $x’’ &lt; 2^k$ 。显然：</p>
<p>$$<br>2^k x’ + x’’ = {\rm TC}_w(x) = 2^w + x<br>$$</p>
<p>而 $x &gt;^{\text{tm}}_w k$ 得到的是 $x_{w - 1}x_{w - 1} \cdots x_{w - 1}x_{w - 2} \cdots x_k$ ，其表示数：</p>
<p>$$<br>x’ + \sum_{i = w - k}^{w - 1} 2^i = x’ + 2^{w - k}(2^k - 1)<br>$$</p>
<p>按照补码去解读这个二进制串的话，其结果为 $x’ + 2^{w - k}(2^k - 1) - 2^w = x’ - 2^{w - k}$ 。也就能够计算得到：</p>
<p>$$<br>\left\lfloor \frac{x}{2^k} \right\rfloor = \left\lfloor \frac{2^k x’ + x’’ - 2^w}{2^k} \right\rfloor = \left\lfloor x’ - 2^{w - k} + \frac{x’’}{2^k} \right\rfloor = x’ - 2^{w - k} = x &gt;^{\text{tm}}_w k<br>$$</p>
</div>

<p>为了修正这个舍入问题，我们可以尝试使用这样的一个性质：</p>
<p>$$<br>\left\lceil \frac{x}{y} \right\rceil = \left\lfloor \frac{x + y - 1}{y} \right\rfloor\ (y &gt; 0)<br>$$</p>
<p>也就是说我们只要在计算负数 $x$ 的时候改变为：</p>
<p>$$<br>\left\lfloor \frac{x + 2^k - 1}{2^k} \right\rfloor = [x +^{\text{t}}_w (2^k - 1)] &gt;^{\text{tm}}_w k<br>$$</p>
<p>即可。</p>
<h1 id="小数的表示"><a href="#小数的表示" class="headerlink" title="小数的表示"></a>小数的表示</h1><h2 id="IEEE-浮点数标准"><a href="#IEEE-浮点数标准" class="headerlink" title="IEEE 浮点数标准"></a>IEEE 浮点数标准</h2><p>对于一个有小数部分的数 $B$ ，我们总是能找到唯一的 $s \in \{0, 1\}$ 以及实数 $M \in [1, 2)$ 和整数 $E$ 满足：</p>
<p>$$<br>B = (-1)^s M \cdot 2^E<br>$$</p>
<p>这里 $s, E, M$ 分别称为<strong>符号</strong>、<strong>阶码</strong>和<strong>尾数</strong>。</p>
<p>基于这样的性质，我们可以给出小数的表示方式。将一片数据区域的最高位用于放置符号位 $s$ ，然后后面分割为两部分，即 <strong>exp 域</strong>和 <strong>frac 域</strong>，分别放置 $E$ 以及 $M$ 。 exp 域和 frac 域的具体大小有两种常见的制式（即<strong>单精度浮点</strong>和<strong>双精度浮点</strong>）。当然还有一些不太常用的分区方式，具体见表：</p>
<table>
<thead>
<tr>
<th align="center">标准</th>
<th align="center">exp 域长度</th>
<th align="center">frac 域长度</th>
<th align="center">浮点总长</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">单精度浮点</td>
<td align="center">8 bits</td>
<td align="center">23 bits</td>
<td align="center">4 字节</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">双精度浮点</td>
<td align="center">11 bits</td>
<td align="center">52 bits</td>
<td align="center">8 字节</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">扩展精度浮点</td>
<td align="center">15 bits</td>
<td align="center">63 bits</td>
<td align="center">10 字节</td>
<td align="center">空置 1 bit</td>
</tr>
<tr>
<td align="center">半精度浮点</td>
<td align="center">5 bits</td>
<td align="center">10 bits</td>
<td align="center">2 字节</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>在具体存储的时候，尾数由于整数部分必然为 <code>1</code> ，所以只需要将小数部分按顺序存储即可，而阶码使用无符号整数方法存储。</p>
<p>这里注意，阶码理应是有可能为负数的，但一般存储的时候会将阶码加上一个固定的偏置变成正数之后存储。如果阶码长度为 $e$ ，那么这个偏置就是 $b = 2^{e - 1} - 1$ 。</p>
<p>比如说按照单精度浮点的方式存储数 <code>15213.0</code> ，其二进制表示为 $1.1101101101101 \times 2^{13}$ 。所以符号位为 <code>0</code> ，尾数取小数部分前 23 位，即 <code>1101101 10110100 00000000</code> 。阶码为 <code>13</code> ，加上偏置 $2^{7} - 1 = 127$ 得到 <code>140</code> ，即 <code>10001100</code> 。所以最后的存储方式为：</p>
<figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01000110 01101101 10110100 00000000</span><br></pre></td></tr></table></figure>

<h2 id="浮点数的非规格化"><a href="#浮点数的非规格化" class="headerlink" title="浮点数的非规格化"></a>浮点数的非规格化</h2><p>事实上，浮点数标准保留一部分阶码用于表示特殊的数字。一般而言，阶码全 <code>1</code> 和全 <code>0</code> 是被保留的。具体而言，阶码全 <code>1</code> 和全 <code>0</code> 的、表述特殊数字的浮点数被称为<strong>非规格化浮点数（ denormalized float point ）</strong>，其余的被称为<strong>规格化浮点数（ normalized float point ）</strong>。</p>
<p>全 <code>0</code> 的阶码如果按照上述的标准解读的话，表示的是相当接近于零的小数。但是由于默认了尾数的整数部分为 <code>1</code> ，所以说还按照原有解读方式的话，浮点数无法表示 <code>0</code> 。这个时候作出规定，就是<strong>阶码全 <code>0</code> 的时候，尾数的整数部分变为 <code>0</code></strong> 。相应的，为了配合尾数解读方式的调整，<strong>阶码的偏置减去一</strong>。</p>
<p>假设某浮点数标准之中阶码长为 $e$ ，尾数长为 $m$ 。那么规格化的条件下最小的正浮点数应当是阶码为 <code>00...01</code> ，尾数全 <code>0</code> 。此时表示的数为 $2^{1 - (2^{e - 1} - 1)} = 2^{2 - 2^{e - 1}}$ 。在非规格化条件下，如果将尾数按照无符号整数解析得到的非负整数标记为 $n$ ，那么该浮点数应该为 $2^{2 - 2^{e - 1}} \cdot 2^{-m}n$ 。这里非负整数 $n$ 取值范围为 $0$ 到 $2^m - 1$ 。</p>
<p>所以说非规格化的浮点数所能表述的非负数序列为：</p>
<p>$$<br>0, \ 2^{2 - 2^{e - 1}} \cdot 2^{-m} \cdot 1, \ \cdots, \ 2^{2 - 2^{e - 1}} \cdot 2^{-m}(2^m - 1)<br>$$</p>
<p>这是一个公差为 $2^{2 - 2^{e - 1}} \cdot 2^{-m}$ 的等差数列，而且最后正好可以和规格化浮点数所表述的最小正数 $2^{2 - 2^{e - 1}}$ “无缝衔接”。所以说非规格化浮点数是一个合理的拓展。</p>
<p>但是，注意非规格化浮点数之中有 <code>+0</code> 和 <code>-0</code> 的区别。</p>
<p>全 <code>1</code> 的阶码用于表示很大的浮点数。一般而言尾数全 <code>0</code> 的时候该浮点数被保留用于表示无穷。而尾数有非 <code>0</code> 位的时候，该浮点数被保留用于表示 <code>NaN</code> 。</p>
<hr>
<p>现在补全了非规格化浮点数之后，可以发现浮点数的大小比较实际上几乎可以按照无符号整数从高位直接比较到低位的逻辑进行。因为阶码大的数一定大，阶码一样的时候尾数大的数一定大，包括无穷大也可以纳入进来。但是要考虑这样的例外：</p>
<ul>
<li><p>考虑符号位</p>
</li>
<li><p>考虑 <code>+0</code> 和 <code>-0</code> 的特例</p>
</li>
<li><p>考虑 <code>NaN</code> 的问题</p>
</li>
</ul>
<h2 id="浮点数的舍入问题"><a href="#浮点数的舍入问题" class="headerlink" title="浮点数的舍入问题"></a>浮点数的舍入问题</h2><p>由于部分数不能表述为有限的二进制小数，所以在转化为浮点数表示的时候需要舍入。一般而言向上舍入、向下舍入、向零舍入都会带来统计误差，而计算机之中常常使用<strong>向偶数舍入</strong>。其舍入的规则是向最接近的数舍入。如果向两边舍入的距离一致，那么优先舍入到偶数。比如说下列数之中，向百分位的舍入为：</p>
<p>$$<br>\begin{aligned}<br>&amp; 12.324999 \Rightarrow 12.32 \\<br>&amp; 12.325001 \Rightarrow 12.33 \\<br>&amp; 12.325000 \Rightarrow 12.32 \\<br>&amp; 12.335000 \Rightarrow 12.34 \\<br>\end{aligned}<br>$$</p>
<p>回到二进制上的话，由于十进制的 <code>0.5</code> 相当于二进制的 <code>0.1</code> 。也就是说如果二进制小数之中后面需要舍去的部分大于 <code>100...</code> 则向上舍入，小于 <code>100...</code> 则向下舍入，恰好是 <code>100...</code> 则向偶数舍入（舍入完毕后尾数为 <code>0</code> ）。</p>
<p>这里要注意一点，舍入是有可能导致溢出。</p>
<hr>
<p>至此，小数的计算机编码方式基本就介绍完毕了。其具体过程为：</p>
<ul>
<li><p>根据使用的浮点数标准，判定使用规格化的浮点数还是非规格化的浮点数</p>
</li>
<li><p>据此判定符号位、阶码和尾数</p>
</li>
<li><p>对尾数进行舍入后转化为二进制表示</p>
</li>
</ul>
<h2 id="C-语言的浮点数"><a href="#C-语言的浮点数" class="headerlink" title="C 语言的浮点数"></a>C 语言的浮点数</h2><p>C 语言之中， <code>int</code> 类型以及 <code>float</code> 类型是 4 字节的， <code>double</code> 则是 8 字节。它们之间的互相转换满足这样的规则：</p>
<ul>
<li><p><code>int</code> 可以精确转换为 <code>double</code> 类型</p>
</li>
<li><p><code>int</code> 转换为 <code>float</code> 类型不会溢出，但有可能被舍入</p>
</li>
<li><p><code>float</code> 以及 <code>double</code> 转换为 <code>int</code> 时尾数截断，如果发生溢出则产生 UB</p>
</li>
</ul>
<h1 id="汇编语言基本知识"><a href="#汇编语言基本知识" class="headerlink" title="汇编语言基本知识"></a>汇编语言基本知识</h1><p>在这一部分，我们使用<strong>指令集架构（ Instruction Set Architecture, ISA ）</strong>来定义机器级程序的行为。在这个架构之中， CPU 内有一个记录下一条指令在主存储器之中位置的<strong>指令寄存器（ Program Counter, PC ）</strong>，这个寄存器在 X86 体系中被命名为 <code>%rip</code> 。 CPU 之中同时还具有若干个<strong>寄存器</strong>，以及一个用于存储最近执行指令的结果状态信息的<strong>条件码寄存器</strong>。除去 CPU 外，这个架构之中还有<strong>主存储器</strong>，其可以认为是以字节为单元的一片连续的地址空间。</p>
<h2 id="汇编语言的数据类型"><a href="#汇编语言的数据类型" class="headerlink" title="汇编语言的数据类型"></a>汇编语言的数据类型</h2><p>和 C 语言不同，汇编语言不区分具体的数据类别，其不关心某一组二进制数据具体代表什么类型的数据。其不区分有符号和无符号的整数，甚至不区分指针和整数。其一般只区分数据的长度为字节、字、双字、四字。在处理这四种长度的数据的时候，指令的后缀分别为 <code>b, w, l, q</code> 。比如说传送数据的命令为 <code>mov</code> ，在传送字节的时候该命令写为 <code>movb</code> ，在传送单字的时候该命令写为 <code>movw</code> 等等。</p>
<h2 id="汇编语言的数据操作"><a href="#汇编语言的数据操作" class="headerlink" title="汇编语言的数据操作"></a>汇编语言的数据操作</h2><p>汇编语言的基本操作只包括对寄存器或主存数据进行运算、在寄存器和主存内部或者之间传递数据、转移程序执行位置这三种。</p>
<div class="note info no-icon"><p>在 X86-64 系统之下，寄存器是四字长的、通过名称访问的一片空间。但实际上有的时候指令可以不用访问整个四字长的寄存器空间，其可以通过 32 位操作访问四个字之中较低位的两个字，通过 16 位操作访问四个字中最低位的字，也可以通过字节操作访问最低位的字节。相应的，指代这一片寄存器空间的名称有所改变：</p>
<table>
<thead>
<tr>
<th align="center">64 位操作</th>
<th align="center">32 位操作</th>
<th align="center">16 位操作</th>
<th align="center">字节操作</th>
<th align="center">64 位操作</th>
<th align="center">32 位操作</th>
<th align="center">16 位操作</th>
<th align="center">字节操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>%rax</code></td>
<td align="center"><code>%eax</code></td>
<td align="center"><code>%ax</code></td>
<td align="center"><code>%al</code></td>
<td align="center"><code>%r8</code></td>
<td align="center"><code>%r8d</code></td>
<td align="center"><code>%r8w</code></td>
<td align="center"><code>%r8b</code></td>
</tr>
<tr>
<td align="center"><code>%rdx</code></td>
<td align="center"><code>%edx</code></td>
<td align="center"><code>%dx</code></td>
<td align="center"><code>%dl</code></td>
<td align="center"><code>%r9</code></td>
<td align="center"><code>%r9d</code></td>
<td align="center"><code>%r9w</code></td>
<td align="center"><code>%r9b</code></td>
</tr>
<tr>
<td align="center"><code>%rcx</code></td>
<td align="center"><code>%ecx</code></td>
<td align="center"><code>%cx</code></td>
<td align="center"><code>%cl</code></td>
<td align="center"><code>%r10</code></td>
<td align="center"><code>%r10d</code></td>
<td align="center"><code>%r10w</code></td>
<td align="center"><code>%r10b</code></td>
</tr>
<tr>
<td align="center"><code>%rbx</code></td>
<td align="center"><code>%ebx</code></td>
<td align="center"><code>%bx</code></td>
<td align="center"><code>%bl</code></td>
<td align="center"><code>%r11</code></td>
<td align="center"><code>%r11d</code></td>
<td align="center"><code>%r11w</code></td>
<td align="center"><code>%r11b</code></td>
</tr>
<tr>
<td align="center"><code>%rsi</code></td>
<td align="center"><code>%esi</code></td>
<td align="center"><code>%si</code></td>
<td align="center"><code>%sil</code></td>
<td align="center"><code>%r12</code></td>
<td align="center"><code>%r12d</code></td>
<td align="center"><code>%r12w</code></td>
<td align="center"><code>%r12b</code></td>
</tr>
<tr>
<td align="center"><code>%rdi</code></td>
<td align="center"><code>%edi</code></td>
<td align="center"><code>%di</code></td>
<td align="center"><code>%dil</code></td>
<td align="center"><code>%r13</code></td>
<td align="center"><code>%r13d</code></td>
<td align="center"><code>%r13w</code></td>
<td align="center"><code>%r13b</code></td>
</tr>
<tr>
<td align="center"><code>%rsp</code></td>
<td align="center"><code>%esp</code></td>
<td align="center"><code>%sp</code></td>
<td align="center"><code>%spl</code></td>
<td align="center"><code>%r14</code></td>
<td align="center"><code>%r14d</code></td>
<td align="center"><code>%r14w</code></td>
<td align="center"><code>%r14b</code></td>
</tr>
<tr>
<td align="center"><code>%rbp</code></td>
<td align="center"><code>%ebp</code></td>
<td align="center"><code>%bp</code></td>
<td align="center"><code>%bpl</code></td>
<td align="center"><code>%r15</code></td>
<td align="center"><code>%r15d</code></td>
<td align="center"><code>%r15w</code></td>
<td align="center"><code>%r15b</code></td>
</tr>
</tbody></table>
<p>实际上，有的时候我们还可以用字节操作访问 <code>%rax, %rbx, %rcx, %rdx</code> 这四个寄存器的倒数第二低位的字节，指代这一部分空间的名称则为 <code>%ah, %bh, %ch, %dh</code> 。</p>
</div>

<p>在具体进行操作的时候，一个机器指令往往需要跟随若干的操作数具体规定操作方法（如传送数据的时候，需要通过操作数指定传送的起始位置和终止位置）。操作数有三种表述方式：</p>
<ul>
<li><p><strong>立即数</strong>。其是一个整型的常数，写法为 <code>$</code> 后接上一个 C 风格的数字表示这个立即数的值。比如说 <code>$-521</code> 以及 <code>$0x4FD</code> 。</p>
</li>
<li><p><strong>寄存器数值</strong>。直接使用寄存器的名称访问，如 <code>%rbp</code> 就代表这个寄存器之中的数据。但是注意，寄存器 <code>%rsp</code> 一般而言是被保留的。</p>
</li>
<li><p><strong>主存数值</strong>。使用地址访问，其地址由某一个寄存器之中的数据指定，写法为寄存器名称加括号。比如说要访问某一个主存数值，其地址存储在寄存器 <code>%rax</code> 之中，那么其写法为 <code>(%rax)</code> 。</p>
</li>
</ul>
<h2 id="汇编语言的寻址方式"><a href="#汇编语言的寻址方式" class="headerlink" title="汇编语言的寻址方式"></a>汇编语言的寻址方式</h2><h3 id="X86-系统的变址寻址方式"><a href="#X86-系统的变址寻址方式" class="headerlink" title="X86 系统的变址寻址方式"></a>X86 系统的变址寻址方式</h3><p>但实际上，在 X86 系统中访问主存数值的方式（这也被称为<strong>寻址方式</strong>）并不是单一的。除去直接使用寄存器之中的数据作为地址去访问， X86 系统提供了包含变址、立即数偏移的寻址模式，其表记一般为 <code>IMM(a, b, s)</code> 。这里 <code>IMM</code> 为一个立即数，称为<strong>立即数偏移</strong>， <code>a, b</code> 为两个寄存器名，分别称为<strong>定址寄存器</strong>和<strong>变址寄存器</strong>， <code>s</code> 为 <code>1, 2, 4, 8</code> 之中的一个数，称为<strong>比例因子</strong>。这个记号所代表的地址为：</p>
<p>$$<br>{\rm IMM} + {\rm R}(a) + {\rm R}(b) \cdot s<br>$$</p>
<p>这里符号 ${\rm R}(a)$ 表示寄存器 <code>a</code> 之中的数据。</p>
<p>这个表记存在一系列简写：</p>
<ul>
<li><p>当不存在定址和变址寄存器的时候，简写为 <code>IMM</code> 。这个时候相当于不经过寄存器直接指定主存中的某一个地址，称为<strong>绝对寻址</strong>。</p>
</li>
<li><p>当 <code>IMM</code> 为 <code>0</code> ，不存在变址寄存器的时候，简写为 <code>(a)</code> 。这也就是最简单的寻址方式，即直接将寄存器数值作为地址解读，称为<strong>间接寻址</strong>。</p>
</li>
<li><p>当存在变址寄存器但 <code>s</code> 为 <code>1</code> 的时候，简写为 <code>IMM(a, b)</code> 。</p>
</li>
</ul>
<hr>
<p>现在我们就可以尝试解读一些汇编代码了，比如：</p>
<figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movq $-147, (%rax)</span><br></pre></td></tr></table></figure>

<p>这个指令的意思是按照四字数据转移的方式，将立即数 <code>-147</code> 写入主存，写入地址为寄存器 <code>%rax</code> 的数值。</p>
<h3 id="利用寻址进行整数计算"><a href="#利用寻址进行整数计算" class="headerlink" title="利用寻址进行整数计算"></a>利用寻址进行整数计算</h3><p>地址实际上也可以被解读为整数，而机器进行寻址的时候实际上就在完成整数计算。根据上面给出的变址寻址方式，我们可以利用寻址命令来计算类似 $x + ky$ 的整数算式。</p>
<p>首先需要知道指令：</p>
<figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leaq [SRC], [DEST]</span><br></pre></td></tr></table></figure>

<p>这里 <code>[SRC]</code> 是一个寻址表达式，其计算出来的结果将赋给 <code>[DEST]</code> 。比如 <code>leaq (%rdi, %rdi, 2), %rax</code> 会将前面寻址计算出来的地址赋予寄存器 <code>%rax</code> 。</p>
<p>实际上在编译器优化之中，部分整数运算都会被优化为地址计算。比如说 <code>x * 12</code> 这个代码有可能会被转化为如下的汇编代码：</p>
<figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leaq (%rdi, %rdi, 2), %rax</span><br><span class="line">salq $2, %rax</span><br></pre></td></tr></table></figure>

<p>第一步使用地址计算实际上计算了 <code>x + x * 2</code> ，即三倍的 <code>x</code> 。第二步命令为左移，左移两位即再次乘以 <code>4</code> 得到最后结果。</p>
<h2 id="汇编语言常用的整数计算命令"><a href="#汇编语言常用的整数计算命令" class="headerlink" title="汇编语言常用的整数计算命令"></a>汇编语言常用的整数计算命令</h2><p>汇编语言计算整数运算的时候，会有如下表所列出的常用命令。</p>
<table>
<thead>
<tr>
<th align="center">命令格式</th>
<th align="center">等价的 C 代码</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>addq [SRC], [DEST]</code></td>
<td align="center"><code>DEST = DEST + SRC</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>subq [SRC], [DEST]</code></td>
<td align="center"><code>DEST = DEST - SRC</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>imulq [SRC], [DEST]</code></td>
<td align="center"><code>DEST = DEST * SRC</code></td>
<td align="center">结果取较低的 64 位截断</td>
</tr>
<tr>
<td align="center"><code>salq [SRC], [DEST]</code></td>
<td align="center"><code>DEST = DEST &lt;&lt; SRC</code></td>
<td align="center">与逻辑左移 <code>shll</code> 等价</td>
</tr>
<tr>
<td align="center"><code>sarq [SRC], [DEST]</code></td>
<td align="center"><code>DEST = DEST &gt;&gt; SRC</code></td>
<td align="center">算术右移</td>
</tr>
<tr>
<td align="center"><code>shrq [SRC], [DEST]</code></td>
<td align="center"><code>DEST = DEST &gt;&gt; SRC</code></td>
<td align="center">逻辑右移</td>
</tr>
<tr>
<td align="center"><code>xorq [SRC], [DEST]</code></td>
<td align="center"><code>DEST = DEST ^ SRC</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>andq [SRC], [DEST]</code></td>
<td align="center"><code>DEST = DEST &amp; SRC</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>orq [SRC], [DEST]</code></td>
<td align="center"><code>DEST = DEST &#124; SRC</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>incq [DEST]</code></td>
<td align="center"><code>DEST = DEST + 1</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>decq [DEST]</code></td>
<td align="center"><code>DEST = DEST - 1</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>negq [DEST]</code></td>
<td align="center"><code>DEST = -DEST</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>notq [DEST]</code></td>
<td align="center"><code>DEST = ~DEST</code></td>
<td align="center"></td>
</tr>
</tbody></table>
<h1 id="条件码与其应用"><a href="#条件码与其应用" class="headerlink" title="条件码与其应用"></a>条件码与其应用</h1><p>当程序运行的时候，部分和当前程序运行状态相关的数据将会被 CPU 保存。我们已经介绍过指向下一条指令的程序计数器 <code>%rip</code> ，存储临时数据的寄存器堆。另外我们要提到的是被保留的寄存器 <code>%rsp</code> 其用于存储<strong>栈顶地址</strong>。另外提一下条件码，条件码一般分为四个：</p>
<table>
<thead>
<tr>
<th align="center">条件码标记</th>
<th align="center">名称</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>CF</code></td>
<td align="center">Carry Flag</td>
<td align="center">进位标记</td>
</tr>
<tr>
<td align="center"><code>ZF</code></td>
<td align="center">Zero Flag</td>
<td align="center">运算数为零标记</td>
</tr>
<tr>
<td align="center"><code>SF</code></td>
<td align="center">Sign Flag</td>
<td align="center">运算数符号标记</td>
</tr>
<tr>
<td align="center"><code>OF</code></td>
<td align="center">Overflow Flag</td>
<td align="center">补码运算溢出标记</td>
</tr>
</tbody></table>
<p>条件码一般是由算术指令运算过程中隐含地设定的，具体如何设定条件码需要查看具体的命令运行方式。这里额外指出， <strong><code>leaq</code> 指令计算的时候不设置条件码</strong>。</p>
<h2 id="推知操作数关系"><a href="#推知操作数关系" class="headerlink" title="推知操作数关系"></a>推知操作数关系</h2><p>若干以 <code>set</code> 为前缀的命令可以读取条件码的内容并存入某寄存器的最低位字节（使用字节操作）。比如说 <code>setle</code> 命令实际上会读取 <code>SF, OF, ZF</code> 三个条件码，将 <code>(SF ^ OF) | ZF</code> 的计算结果存入指定字节。</p>
<p>这个计算结果其实就代表了两个操作数之间的一个关系。比如说 <code>cmpq [SRC], [DEST]</code> 指令在 <code>SRC == DEST</code> 的时候会将 <code>ZF</code> 置真，在 <code>DEST - SRC &lt; 0</code> 的时候将 <code>SF</code> 置真，在运算溢出的时候将 <code>OF</code> 置真。那么 <code>setle</code> 所计算的结果为真实际上就代表 <code>DEST &lt;= SRC</code> 。</p>
<p>这里给出具体示例，比如以下 C 语言代码：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gt</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt; y; &#125;</span><br></pre></td></tr></table></figure>

<p>会被汇编为：</p>
<figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmpq   %rsi, %rdi</span><br><span class="line">setg   %al</span><br><span class="line">movzbl %al, %eax</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>其含义为首先使用 <code>cmpq</code> 命令更新条件码，然后使用 <code>setg</code> 命令读取条件码，最后使用 <code>movzbl</code> 将计算结果移动到表示函数返回值的寄存器。</p>
<h2 id="实现程序跳转"><a href="#实现程序跳转" class="headerlink" title="实现程序跳转"></a>实现程序跳转</h2><p>对于 C 语言之中的 <code>if, goto</code> 等涉及到程序跳转的语句，汇编之中也应当有相应的可以跳转执行的命令，而条件码及其相关运算结果会控制程序是否跳转。与 <code>set</code> 系列命令一致，汇编之中还有 <code>j</code> 系列命令，如 <code>je</code> 。其会读取条件码并计算，结果为真则会触发程序跳转。</p>
<p>比如这样的 C 代码：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">absdiff</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) result = x - y;</span><br><span class="line">    <span class="keyword">else</span> result = y - x;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>会被汇编为：</p>
<figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">absdiff:</span><br><span class="line">    cmpq %rsi, %rdi</span><br><span class="line">    jle  .L4</span><br><span class="line">    movq %rdi, %rax</span><br><span class="line">    subq %rsi, %rax</span><br><span class="line">    ret</span><br><span class="line">.L4:</span><br><span class="line">    movq %rsi, %rax</span><br><span class="line">    subq %rdi, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>这里第三行就会读取 <code>cmpq</code> 命令设置的条件码，如果满足了跳转条件，就会跳转到 <code>.L4</code> 标记处继续执行，否则向下继续执行。</p>
<p>实际上，汇编代码的跳转基本和 C 语言之中的 <code>goto</code> 类似，所以我们可以将 <code>if</code> 转为等价的 <code>goto</code> 表达式，这样的话就可以得到和汇编代码形式类似的 C 代码。对于以下的 C 代码：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (CASE) &#123; <span class="comment">/* IF BLOCK */</span> &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">/* ELSE BLOCK */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>实际上等价于以下 C 代码：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!CASE) <span class="keyword">goto</span> Else;</span><br><span class="line">    <span class="comment">/* IF BLOCK */</span></span><br><span class="line">    <span class="keyword">goto</span> Done;</span><br><span class="line">Else:</span><br><span class="line">    <span class="comment">/* ELSE BLOCK*/</span></span><br><span class="line">Done:</span><br></pre></td></tr></table></figure>

<div class="note info no-icon"><p>使用条件码实现程序跳转的方式称为<strong>条件跳转</strong>。但实际上，条件跳转一般会拖慢整个系统的速度。这是因为现代的流水线式处理器一般要求系统能够基本精确得知接下来应当运行的指令是什么，这样才能保证并发执行，获得高效率。</p>
<p>为了解决这个问题，一种方法是提高处理器对下面具体运行哪一个分支的预测准确率，一种方法是使用<strong>条件转移</strong>。</p>
<p>条件转移指的是将两个分支的结果都计算出来，最后再根据条件码决定取用哪一个。比如说上面的 <code>absdiff</code> 函数，现代编译器一般会把 <code>x - y</code> 和 <code>y - x</code> 都计算出来，最后根据条件码取其中一个放到返回值寄存器上。</p>
<p>但是条件转移的使用是有局限性的，比如说下面两种情况就并不适合：</p>
<ul>
<li><p>某一个分支有副作用，比如说修改了某些其他数据</p>
</li>
<li><p>某一个分支的计算量过于庞大</p>
</li>
</ul>
</div>

<p>除去 <code>if</code> ， C 语言中还可以使用 <code>switch</code> 语句实现程序跳转。 <code>switch</code> 语句可以翻译为若干的 <code>if-else</code> 组，但是更常见的解读方式是<strong>构建跳转表</strong>。</p>
<p><code>TODO</code></p>
<h2 id="实现程序循环"><a href="#实现程序循环" class="headerlink" title="实现程序循环"></a>实现程序循环</h2><p>C 语言之中使用关键字 <code>do, while, for</code> 可以实现程序循环，同样我们可以使用条件码和 <code>j</code> 系列命令完成等价汇编代码编写，实际上我们只需要改写为等价的 <code>goto</code> 表达的 C 代码就可以。</p>
<p>对于 <code>do ... while</code> 循环，等价改写为：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* do ... while */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123; <span class="comment">/* CONTENT */</span> &#125; <span class="keyword">while</span> (CASE)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* goto */</span></span><br><span class="line"></span><br><span class="line">Loop:</span><br><span class="line">    <span class="comment">/* CONTENT */</span></span><br><span class="line"><span class="keyword">if</span> (CASE) <span class="keyword">goto</span> Loop;</span><br></pre></td></tr></table></figure>

<p>对于 <code>while</code> 循环，等价改写为：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* while */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (CASE) &#123; <span class="comment">/* CONTENT */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* goto v1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> Test;</span><br><span class="line">Loop:</span><br><span class="line">    <span class="comment">/* CONTENT */</span></span><br><span class="line">Test:</span><br><span class="line">    <span class="keyword">if</span> (CASE) <span class="keyword">goto</span> Loop;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* goto v2 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!CASE) <span class="keyword">goto</span> Done;</span><br><span class="line">Loop:</span><br><span class="line">    <span class="comment">/* CONTENT */</span></span><br><span class="line"><span class="keyword">if</span> (CASE) <span class="keyword">goto</span> Loop;</span><br><span class="line">Done:</span><br></pre></td></tr></table></figure>

<p>而 <code>for</code> 循环一般是改写为等价的 <code>while</code> 循环后再改写为 <code>goto</code> 版本：</p>
<figure class="highlight cpp"><figcaption><span>C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* for */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="comment">/* INIT */</span>; CASE; <span class="comment">/* UPDATE */</span>) &#123; <span class="comment">/* CONTENT */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* while */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* INIT */</span></span><br><span class="line"><span class="keyword">while</span> (CASE) &#123;</span><br><span class="line">    <span class="comment">/* CONTENT */</span></span><br><span class="line">    <span class="comment">/* UPDATE */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="函数调用与程序栈"><a href="#函数调用与程序栈" class="headerlink" title="函数调用与程序栈"></a>函数调用与程序栈</h1>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/07/10/paper-nlp-01/" rel="prev" title="《Making Pre-trained Language Models Better Few-shot Learners》阅读笔记">
                  <i class="fa fa-chevron-left"></i> 《Making Pre-trained Language Models Better Few-shot Learners》阅读笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/08/16/note-of-qi/" rel="next" title="《量子计算研讨课》学习笔记">
                  《量子计算研讨课》学习笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments"><div id="twikoo-comments"></div></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ashitemaru</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">66k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:01</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>




  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{&quot;enable&quot;:true,&quot;tags&quot;:&quot;none&quot;,&quot;js&quot;:{&quot;url&quot;:&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;mathjax@3.1.4&#x2F;es5&#x2F;tex-mml-chtml.js&quot;,&quot;integrity&quot;:&quot;sha256-ncNI9OXOS5Ek4tzVYiOMmN&#x2F;KKCPZ6V0Cpv2P&#x2F;zHntiA&#x3D;&quot;}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="twikoo" type="application/json">{&quot;enable&quot;:true,&quot;visitor&quot;:true,&quot;envId&quot;:&quot;https:&#x2F;&#x2F;vercel-deploy-two.vercel.app&quot;,&quot;el&quot;:&quot;#twikoo-comments&quot;}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.twikoo.el)
    .then(() => NexT.utils.getScript(
      'https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js',
      { condition: window.twikoo }
    ))
    .then(() => {
      twikoo.init(CONFIG.twikoo);
    });
});
</script>

</body>
</html>
